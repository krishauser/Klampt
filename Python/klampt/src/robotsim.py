# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Klamp't Core Python bindings 
------------------------------
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _robotsim
else:
    import _robotsim

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _robotsim.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _robotsim.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _robotsim.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _robotsim.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _robotsim.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _robotsim.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _robotsim.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _robotsim.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _robotsim.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _robotsim.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _robotsim.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _robotsim.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _robotsim.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _robotsim.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _robotsim.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _robotsim.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _robotsim.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _robotsim:
_robotsim.SwigPyIterator_swigregister(SwigPyIterator)

class doubleArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _robotsim.doubleArray_swiginit(self, _robotsim.new_doubleArray(nelements))
    __swig_destroy__ = _robotsim.delete_doubleArray

    def __getitem__(self, index: "size_t") -> "double":
        return _robotsim.doubleArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "double") -> "void":
        return _robotsim.doubleArray___setitem__(self, index, value)

    def cast(self) -> "double *":
        return _robotsim.doubleArray_cast(self)

    @staticmethod
    def frompointer(t: "double *") -> "doubleArray *":
        return _robotsim.doubleArray_frompointer(t)

# Register doubleArray in _robotsim:
_robotsim.doubleArray_swigregister(doubleArray)

def doubleArray_frompointer(t: "double *") -> "doubleArray *":
    return _robotsim.doubleArray_frompointer(t)

class floatArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _robotsim.floatArray_swiginit(self, _robotsim.new_floatArray(nelements))
    __swig_destroy__ = _robotsim.delete_floatArray

    def __getitem__(self, index: "size_t") -> "float":
        return _robotsim.floatArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "float") -> "void":
        return _robotsim.floatArray___setitem__(self, index, value)

    def cast(self) -> "float *":
        return _robotsim.floatArray_cast(self)

    @staticmethod
    def frompointer(t: "float *") -> "floatArray *":
        return _robotsim.floatArray_frompointer(t)

# Register floatArray in _robotsim:
_robotsim.floatArray_swigregister(floatArray)

def floatArray_frompointer(t: "float *") -> "floatArray *":
    return _robotsim.floatArray_frompointer(t)

class intArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _robotsim.intArray_swiginit(self, _robotsim.new_intArray(nelements))
    __swig_destroy__ = _robotsim.delete_intArray

    def __getitem__(self, index: "size_t") -> "int":
        return _robotsim.intArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "int") -> "void":
        return _robotsim.intArray___setitem__(self, index, value)

    def cast(self) -> "int *":
        return _robotsim.intArray_cast(self)

    @staticmethod
    def frompointer(t: "int *") -> "intArray *":
        return _robotsim.intArray_frompointer(t)

# Register intArray in _robotsim:
_robotsim.intArray_swigregister(intArray)

def intArray_frompointer(t: "int *") -> "intArray *":
    return _robotsim.intArray_frompointer(t)

class stringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _robotsim.stringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _robotsim.stringVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _robotsim.stringVector___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _robotsim.stringVector___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _robotsim.stringVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _robotsim.stringVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _robotsim.stringVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _robotsim.stringVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _robotsim.stringVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _robotsim.stringVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _robotsim.stringVector_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _robotsim.stringVector_append(self, x)

    def empty(self) -> "bool":
        return _robotsim.stringVector_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _robotsim.stringVector_size(self)

    def swap(self, v: "stringVector") -> "void":
        return _robotsim.stringVector_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _robotsim.stringVector_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _robotsim.stringVector_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _robotsim.stringVector_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _robotsim.stringVector_rend(self)

    def clear(self) -> "void":
        return _robotsim.stringVector_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _robotsim.stringVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _robotsim.stringVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _robotsim.stringVector_erase(self, *args)

    def __init__(self, *args):
        _robotsim.stringVector_swiginit(self, _robotsim.new_stringVector(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _robotsim.stringVector_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _robotsim.stringVector_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _robotsim.stringVector_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _robotsim.stringVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _robotsim.stringVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _robotsim.stringVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _robotsim.stringVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _robotsim.stringVector_capacity(self)
    __swig_destroy__ = _robotsim.delete_stringVector

# Register stringVector in _robotsim:
_robotsim.stringVector_swigregister(stringVector)

class doubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _robotsim.doubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _robotsim.doubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _robotsim.doubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _robotsim.doubleVector___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        return _robotsim.doubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _robotsim.doubleVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        return _robotsim.doubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _robotsim.doubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _robotsim.doubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _robotsim.doubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _robotsim.doubleVector_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _robotsim.doubleVector_append(self, x)

    def empty(self) -> "bool":
        return _robotsim.doubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _robotsim.doubleVector_size(self)

    def swap(self, v: "doubleVector") -> "void":
        return _robotsim.doubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _robotsim.doubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _robotsim.doubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _robotsim.doubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _robotsim.doubleVector_rend(self)

    def clear(self) -> "void":
        return _robotsim.doubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _robotsim.doubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _robotsim.doubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _robotsim.doubleVector_erase(self, *args)

    def __init__(self, *args):
        _robotsim.doubleVector_swiginit(self, _robotsim.new_doubleVector(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _robotsim.doubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _robotsim.doubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _robotsim.doubleVector_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        return _robotsim.doubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _robotsim.doubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _robotsim.doubleVector_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _robotsim.doubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _robotsim.doubleVector_capacity(self)
    __swig_destroy__ = _robotsim.delete_doubleVector

# Register doubleVector in _robotsim:
_robotsim.doubleVector_swigregister(doubleVector)

class floatVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _robotsim.floatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _robotsim.floatVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _robotsim.floatVector___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _robotsim.floatVector___len__(self)

    def __getslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "std::vector< float,std::allocator< float > > *":
        return _robotsim.floatVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _robotsim.floatVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "void":
        return _robotsim.floatVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _robotsim.floatVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _robotsim.floatVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _robotsim.floatVector___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _robotsim.floatVector_pop(self)

    def append(self, x: "std::vector< float >::value_type const &") -> "void":
        return _robotsim.floatVector_append(self, x)

    def empty(self) -> "bool":
        return _robotsim.floatVector_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _robotsim.floatVector_size(self)

    def swap(self, v: "floatVector") -> "void":
        return _robotsim.floatVector_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _robotsim.floatVector_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _robotsim.floatVector_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _robotsim.floatVector_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _robotsim.floatVector_rend(self)

    def clear(self) -> "void":
        return _robotsim.floatVector_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _robotsim.floatVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _robotsim.floatVector_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _robotsim.floatVector_erase(self, *args)

    def __init__(self, *args):
        _robotsim.floatVector_swiginit(self, _robotsim.new_floatVector(*args))

    def push_back(self, x: "std::vector< float >::value_type const &") -> "void":
        return _robotsim.floatVector_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _robotsim.floatVector_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _robotsim.floatVector_back(self)

    def assign(self, n: "std::vector< float >::size_type", x: "std::vector< float >::value_type const &") -> "void":
        return _robotsim.floatVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _robotsim.floatVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _robotsim.floatVector_insert(self, *args)

    def reserve(self, n: "std::vector< float >::size_type") -> "void":
        return _robotsim.floatVector_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _robotsim.floatVector_capacity(self)
    __swig_destroy__ = _robotsim.delete_floatVector

# Register floatVector in _robotsim:
_robotsim.floatVector_swigregister(floatVector)

class intVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _robotsim.intVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _robotsim.intVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _robotsim.intVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _robotsim.intVector___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _robotsim.intVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _robotsim.intVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _robotsim.intVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _robotsim.intVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _robotsim.intVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _robotsim.intVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _robotsim.intVector_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _robotsim.intVector_append(self, x)

    def empty(self) -> "bool":
        return _robotsim.intVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _robotsim.intVector_size(self)

    def swap(self, v: "intVector") -> "void":
        return _robotsim.intVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _robotsim.intVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _robotsim.intVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _robotsim.intVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _robotsim.intVector_rend(self)

    def clear(self) -> "void":
        return _robotsim.intVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _robotsim.intVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _robotsim.intVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _robotsim.intVector_erase(self, *args)

    def __init__(self, *args):
        _robotsim.intVector_swiginit(self, _robotsim.new_intVector(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _robotsim.intVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _robotsim.intVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _robotsim.intVector_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _robotsim.intVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _robotsim.intVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _robotsim.intVector_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _robotsim.intVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _robotsim.intVector_capacity(self)
    __swig_destroy__ = _robotsim.delete_intVector

# Register intVector in _robotsim:
_robotsim.intVector_swigregister(intVector)

class doubleMatrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _robotsim.doubleMatrix_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _robotsim.doubleMatrix___nonzero__(self)

    def __bool__(self) -> "bool":
        return _robotsim.doubleMatrix___bool__(self)

    def __len__(self) -> "std::vector< std::vector< double > >::size_type":
        return _robotsim.doubleMatrix___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< double > >::difference_type", j: "std::vector< std::vector< double > >::difference_type") -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *":
        return _robotsim.doubleMatrix___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _robotsim.doubleMatrix___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< double > >::difference_type", j: "std::vector< std::vector< double > >::difference_type") -> "void":
        return _robotsim.doubleMatrix___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _robotsim.doubleMatrix___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< double > >::value_type const &":
        return _robotsim.doubleMatrix___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _robotsim.doubleMatrix___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< double > >::value_type":
        return _robotsim.doubleMatrix_pop(self)

    def append(self, x: "doubleVector") -> "void":
        return _robotsim.doubleMatrix_append(self, x)

    def empty(self) -> "bool":
        return _robotsim.doubleMatrix_empty(self)

    def size(self) -> "std::vector< std::vector< double > >::size_type":
        return _robotsim.doubleMatrix_size(self)

    def swap(self, v: "doubleMatrix") -> "void":
        return _robotsim.doubleMatrix_swap(self, v)

    def begin(self) -> "std::vector< std::vector< double > >::iterator":
        return _robotsim.doubleMatrix_begin(self)

    def end(self) -> "std::vector< std::vector< double > >::iterator":
        return _robotsim.doubleMatrix_end(self)

    def rbegin(self) -> "std::vector< std::vector< double > >::reverse_iterator":
        return _robotsim.doubleMatrix_rbegin(self)

    def rend(self) -> "std::vector< std::vector< double > >::reverse_iterator":
        return _robotsim.doubleMatrix_rend(self)

    def clear(self) -> "void":
        return _robotsim.doubleMatrix_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< double > >::allocator_type":
        return _robotsim.doubleMatrix_get_allocator(self)

    def pop_back(self) -> "void":
        return _robotsim.doubleMatrix_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< double > >::iterator":
        return _robotsim.doubleMatrix_erase(self, *args)

    def __init__(self, *args):
        _robotsim.doubleMatrix_swiginit(self, _robotsim.new_doubleMatrix(*args))

    def push_back(self, x: "doubleVector") -> "void":
        return _robotsim.doubleMatrix_push_back(self, x)

    def front(self) -> "std::vector< std::vector< double > >::value_type const &":
        return _robotsim.doubleMatrix_front(self)

    def back(self) -> "std::vector< std::vector< double > >::value_type const &":
        return _robotsim.doubleMatrix_back(self)

    def assign(self, n: "std::vector< std::vector< double > >::size_type", x: "doubleVector") -> "void":
        return _robotsim.doubleMatrix_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _robotsim.doubleMatrix_resize(self, *args)

    def insert(self, *args) -> "void":
        return _robotsim.doubleMatrix_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< double > >::size_type") -> "void":
        return _robotsim.doubleMatrix_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< double > >::size_type":
        return _robotsim.doubleMatrix_capacity(self)
    __swig_destroy__ = _robotsim.delete_doubleMatrix

# Register doubleMatrix in _robotsim:
_robotsim.doubleMatrix_swigregister(doubleMatrix)

class stringMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _robotsim.stringMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _robotsim.stringMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _robotsim.stringMap___bool__(self)

    def __len__(self) -> "std::map< std::string,std::string >::size_type":
        return _robotsim.stringMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::mapped_type const &":
        return _robotsim.stringMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::string >::key_type const &") -> "void":
        return _robotsim.stringMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::string >::key_type const &") -> "bool":
        return _robotsim.stringMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _robotsim.stringMap_keys(self)

    def values(self) -> "PyObject *":
        return _robotsim.stringMap_values(self)

    def items(self) -> "PyObject *":
        return _robotsim.stringMap_items(self)

    def __contains__(self, key: "std::map< std::string,std::string >::key_type const &") -> "bool":
        return _robotsim.stringMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _robotsim.stringMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _robotsim.stringMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _robotsim.stringMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _robotsim.stringMap_asdict(self)

    def __init__(self, *args):
        _robotsim.stringMap_swiginit(self, _robotsim.new_stringMap(*args))

    def empty(self) -> "bool":
        return _robotsim.stringMap_empty(self)

    def size(self) -> "std::map< std::string,std::string >::size_type":
        return _robotsim.stringMap_size(self)

    def swap(self, v: "stringMap") -> "void":
        return _robotsim.stringMap_swap(self, v)

    def begin(self) -> "std::map< std::string,std::string >::iterator":
        return _robotsim.stringMap_begin(self)

    def end(self) -> "std::map< std::string,std::string >::iterator":
        return _robotsim.stringMap_end(self)

    def rbegin(self) -> "std::map< std::string,std::string >::reverse_iterator":
        return _robotsim.stringMap_rbegin(self)

    def rend(self) -> "std::map< std::string,std::string >::reverse_iterator":
        return _robotsim.stringMap_rend(self)

    def clear(self) -> "void":
        return _robotsim.stringMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::string >::allocator_type":
        return _robotsim.stringMap_get_allocator(self)

    def count(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::size_type":
        return _robotsim.stringMap_count(self, x)

    def erase(self, *args) -> "void":
        return _robotsim.stringMap_erase(self, *args)

    def find(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        return _robotsim.stringMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        return _robotsim.stringMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        return _robotsim.stringMap_upper_bound(self, x)
    __swig_destroy__ = _robotsim.delete_stringMap

# Register stringMap in _robotsim:
_robotsim.stringMap_swigregister(stringMap)


import numpy as np
import types

class TriangleMesh(object):
    r"""


    A 3D indexed triangle mesh class.  

    Attributes:  

        vertices (numpy array):  an n x 3 array of vertices.
        indices (numpy int32 array): an m x 3 list of triangle vertices, given
            as indices into the vertices list, i.e., [[a1,b1,c2], [a2,b2,c2], ...]  

    Examples::  

        m = TriangleMesh()
        m.addVertex((0,0,0))
        m.addVertex((1,0,0))
        m.addVertex((0,1,0))
        m.addTriangle(0,1,2)
        print(len(m.vertices))  #prints 3
        print(len(m.indices))   #prints 1


    C++ includes: geometry.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _robotsim.delete_TriangleMesh

    def __init__(self, *args):
        r"""
        __init__(TriangleMesh self) -> TriangleMesh
        __init__(TriangleMesh self, TriangleMesh rhs) -> TriangleMesh


        """
        _robotsim.TriangleMesh_swiginit(self, _robotsim.new_TriangleMesh(*args))

    def copy(self) -> "TriangleMesh":
        r"""
        copy(TriangleMesh self) -> TriangleMesh


        Creates a standalone object that is a copy of this.  

        """
        return _robotsim.TriangleMesh_copy(self)

    def set(self, arg2: "TriangleMesh") -> "void":
        r"""
        set(TriangleMesh self, TriangleMesh arg2)


        Copies the data of the argument into this.  

        """
        return _robotsim.TriangleMesh_set(self, arg2)

    def getVertices(self) -> "void":
        r"""
        getVertices(TriangleMesh self)


        Retrieves an array view of the vertices.  

        Returns:  

            ndarray: an nx3 Numpy array. Setting elements of this array will
            change the vertices.
         Return type: np.ndarray  

        """
        return _robotsim.TriangleMesh_getVertices(self)

    def setVertices(self, np_array2: "double *") -> "void":
        r"""
        setVertices(TriangleMesh self, double * np_array2)


        Sets all vertices to the given nx3 Numpy array.  

        """
        return _robotsim.TriangleMesh_setVertices(self, np_array2)

    def addVertex(self, p: "double [3]") -> "void":
        r"""
        addVertex(TriangleMesh self, double [3] p)


        Adds a new vertex.  

        """
        return _robotsim.TriangleMesh_addVertex(self, p)

    def getIndices(self) -> "void":
        r"""
        getIndices(TriangleMesh self)


        Retrieves an array view of the triangle indices.  

        Returns:  

            ndarray: an mx3 Numpy array of int32 type. Setting elements of this
            array will change the triangle indices.
         Return type: np.ndarray  

        """
        return _robotsim.TriangleMesh_getIndices(self)

    def setIndices(self, np_array2: "int *") -> "void":
        r"""
        setIndices(TriangleMesh self, int * np_array2)


        Sets all indices to the given mx3 Numpy array.  

        """
        return _robotsim.TriangleMesh_setIndices(self, np_array2)

    def addTriangleIndices(self, t: "int [3]") -> "void":
        r"""
        addTriangleIndices(TriangleMesh self, int [3] t)


        Adds a new triangle.  

        """
        return _robotsim.TriangleMesh_addTriangleIndices(self, t)

    def translate(self, t: "double const [3]") -> "void":
        r"""
        translate(TriangleMesh self, double const [3] t)


        Translates all the vertices by v=v+t.  

        """
        return _robotsim.TriangleMesh_translate(self, t)

    def _transform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _transform(TriangleMesh self, double const [9] R, double const [3] t)


        Transforms all the vertices by the rigid transform v=R*v+t.  

        """
        return _robotsim.TriangleMesh__transform(self, R, t)
    dataPtr = property(_robotsim.TriangleMesh_dataPtr_get, _robotsim.TriangleMesh_dataPtr_set, doc=r"""dataPtr : p.void""")
    isStandalone = property(_robotsim.TriangleMesh_isStandalone_get, _robotsim.TriangleMesh_isStandalone_set, doc=r"""isStandalone : bool""")

    def transform(self, R_or_T : Union[Matrix3,RigidTransform], t :Optional[Vector3] = None):
        """
        Transforms all the vertices by the rigid transform v=R*v+t
        """
        if t is not None:
            self._transform(R_or_T,t)
        else:
            self._transform(*R_or_T);

    def triangle(self, i) -> Tuple[Tuple[float,float,float],Tuple[float,float,float],Tuple[float,float,float]]:
        """
        Returns the i'th triangle of the mesh as a tuple of 3 3-tuples.
        """
        a,b,c = self.indices[i]
        v = self.vertices
        return (v[a],v[b],v[c])

    def triangleNormals(self) -> np.ndarray:
        """
        Computes outward triangle normals.

        Returns:
            An N x 3 matrix of triangle normals with N the number of triangles.
        """
        verts=self.vertices
        tris=self.indices
        dba = verts[tris[:,1]]-verts[tris[:,0]]
        dca = verts[tris[:,2]]-verts[tris[:,0]]
        n = np.cross(dba,dca)
        norms = np.linalg.norm(n,axis=1)[:, np.newaxis]
        n = np.divide(n,norms,where=norms!=0)
        return n

    def vertexNormals(self, area_weighted=True) -> np.ndarray:
        """
        Computes outward vertex normals.

        Args:
            area_weighted (bool): whether to compute area-weighted average or
                simple average.

        Returns:
            An N x 3 matrix of vertex normals with N the number of vertices.
        """
        verts=self.vertices
        tris=self.indices
        dba = verts[tris[:,1]]-verts[tris[:,0]]
        dca = verts[tris[:,2]]-verts[tris[:,0]]
        n = np.cross(dba,dca)
        normals = [np.zeros(3) for i in range(len(verts))]
        if area_weighted:
            for i,t in enumerate(tris):
                for j in range(3):
                    normals[t[j]] += n[i]
        else:
            norms = np.linalg.norm(n,axis=1)[:, np.newaxis]
            n = np.divide(n,norms,where=norms!=0)
            for i,t in enumerate(tris):
                for j in range(3):
                    normals[t[j]] += n[i]
        normals = np.array(normals)
        norms = np.linalg.norm(normals,axis=1)[:, np.newaxis]
        return np.divide(normals,norms,where=norms!=0)

    def __reduce__(self):
        from klampt.io import loader
        jsonobj = loader.to_json(self,'TriangleMesh')
        return (loader.from_json,(jsonobj,'TriangleMesh'))

    vertices = property(getVertices, setVertices)
    """An Nx3 matrix of vertex positions"""
    indices = property(getIndices, setIndices)
    """An Mx3 matrix of indices into the vertices array, where M is the number of triangles.
    Each row is a triangle, with the 3 columns giving the indices of the vertices."""


# Register TriangleMesh in _robotsim:
_robotsim.TriangleMesh_swigregister(TriangleMesh)

class ConvexHull(object):
    r"""


    Stores a set of points to be set into a ConvexHull type. Note: These may not
    actually be the vertices of the convex hull; the actual convex hull may be
    computed internally for some datatypes.  

    Attributes:  

        points (numpy array): an nx3 numpy array of points.


    C++ includes: geometry.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _robotsim.delete_ConvexHull

    def __init__(self, *args):
        r"""
        __init__(ConvexHull self) -> ConvexHull
        __init__(ConvexHull self, ConvexHull rhs) -> ConvexHull


        """
        _robotsim.ConvexHull_swiginit(self, _robotsim.new_ConvexHull(*args))

    def copy(self) -> "ConvexHull":
        r"""
        copy(ConvexHull self) -> ConvexHull


        Creates a standalone object that is a copy of this.  

        """
        return _robotsim.ConvexHull_copy(self)

    def set(self, arg2: "ConvexHull") -> "void":
        r"""
        set(ConvexHull self, ConvexHull arg2)


        Copies the data of the argument into this.  

        """
        return _robotsim.ConvexHull_set(self, arg2)

    def getPoints(self) -> "void":
        r"""
        getPoints(ConvexHull self)


        Retrieves a view of the points.  

        Returns:  

            ndarray: an nx3 Numpy array. Setting elements of this array will
            immediately take effect.
         Return type: np.ndarray  

        """
        return _robotsim.ConvexHull_getPoints(self)

    def setPoints(self, np_array2: "double *") -> "void":
        r"""
        setPoints(ConvexHull self, double * np_array2)


        Sets all points to the given nx3 Numpy array.  

        """
        return _robotsim.ConvexHull_setPoints(self, np_array2)

    def addPoint(self, pt: "double const [3]") -> "void":
        r"""
        addPoint(ConvexHull self, double const [3] pt)


        Adds a point.  

        """
        return _robotsim.ConvexHull_addPoint(self, pt)

    def translate(self, t: "double const [3]") -> "void":
        r"""
        translate(ConvexHull self, double const [3] t)


        Translates all the vertices by v=v+t.  

        """
        return _robotsim.ConvexHull_translate(self, t)

    def _transform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _transform(ConvexHull self, double const [9] R, double const [3] t)


        Transforms all the vertices by the rigid transform v=R*v+t.  

        """
        return _robotsim.ConvexHull__transform(self, R, t)
    dataPtr = property(_robotsim.ConvexHull_dataPtr_get, _robotsim.ConvexHull_dataPtr_set, doc=r"""dataPtr : p.void""")
    isStandalone = property(_robotsim.ConvexHull_isStandalone_get, _robotsim.ConvexHull_isStandalone_set, doc=r"""isStandalone : bool""")

    points = property(getPoints, setPoints)

    def transform(self, R_or_T : Union[Matrix3,RigidTransform], t :Optional[Vector3] = None):
        """
        Transforms all the vertices by the rigid transform v=R*v+t
        """
        if t is not None:
            self._transform(R_or_T,t)
        else:
            self._transform(*R_or_T);

    def __reduce__(self):
        from klampt.io import loader
        jsonobj = loader.to_json(self,'ConvexHull')
        return (loader.from_json,(jsonobj,'ConvexHull'))


# Register ConvexHull in _robotsim:
_robotsim.ConvexHull_swigregister(ConvexHull)

class PointCloud(object):
    r"""


    A 3D point cloud class.  

    Attributes:  

        vertices (numpy array): a n x 3 array of vertices.
        properties (numpy array): a n x k array of vertex properties.  The
           name of each property is either anonymous or retrieved by
           `getPropertyName`.  

    Property names are usually lowercase but follow PCL naming convention, and often
    include:  

    *   `normal_x`, `normal_y`, `normal_z`: the outward normal  
    *   `rgb`, `rgba`: integer encoding of RGB (24 bit int, format 0xrrggbb) or RGBA
        color (32 bit int, format 0xaarrggbb)  
    *   `opacity`: opacity, in range [0,1]  
    *   `c`: opacity, in range [0,255]  
    *   `r,g,b,a`: color channels, in range [0,1]  
    *   `u,v`: texture coordinate  
    *   `radius`: treats the point cloud as a collection of balls  

    Settings are usually lowercase but follow PCL naming convention, and often
    include:  

    *   `version`: version of the PCL file, typically "0.7"  
    *   `id`: integer id  
    *   `width`: the width (in pixels) of a structured point cloud  
    *   `height`: the height (in pixels) of a structured point cloud  
    *   `viewpoint`: Camera position and orientation in the form `ox oy oz qw qx qy
        qz`, with (ox,oy,oz) the focal point and (qw,qx,qy,qz) the quaternion
        representation of the orientation (canonical representation, with X right, Y
        down, Z forward).  

    Examples::  

        pc = PointCloud()
        pc.addProperty('rgb')
        #add 1 point with coordinates (0,0,0) and color #000000 (black)
        pc.addPoint((0,0,0))
        pc.setProperty(0,0)
        print(len(pc.points)) # prints 1
        #add another point with coordinates (1,2,3)
        pc.addPoint([1,2,3])
        #this prints 2
        print(len(pc.points))
        print(pc.points)   #prints [[0,0,0],[1,2,3]]
        #this prints (2,1), because there is 1 property category x 2 points
        print(pc.properties.shape)
        #this prints 0; this is the default value added when addPoint was called
        print(pc.getProperty(1,0) )


    C++ includes: geometry.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _robotsim.delete_PointCloud

    def __init__(self, *args):
        r"""
        __init__(PointCloud self) -> PointCloud
        __init__(PointCloud self, PointCloud rhs) -> PointCloud


        """
        _robotsim.PointCloud_swiginit(self, _robotsim.new_PointCloud(*args))

    def copy(self) -> "PointCloud":
        r"""
        copy(PointCloud self) -> PointCloud


        Creates a standalone object that is a copy of this.  

        """
        return _robotsim.PointCloud_copy(self)

    def set(self, arg2: "PointCloud") -> "void":
        r"""
        set(PointCloud self, PointCloud arg2)


        Copies the data of the argument into this.  

        """
        return _robotsim.PointCloud_set(self, arg2)

    def getPoints(self) -> "void":
        r"""
        getPoints(PointCloud self)


        Returns a view of the points.  

        Returns:  

            ndarray: an nx3 Numpy array. Setting elements of this array will
            change the points.
         Return type: np.ndarray  

        """
        return _robotsim.PointCloud_getPoints(self)

    def setPoints(self, np_array2: "double *") -> "void":
        r"""
        setPoints(PointCloud self, double * np_array2)


        Sets all the points to the given nx3 Numpy array.  

        """
        return _robotsim.PointCloud_setPoints(self, np_array2)

    def addPoint(self, p: "double const [3]") -> "int":
        r"""
        addPoint(PointCloud self, double const [3] p) -> int


        Adds a point. Sets all its properties to 0.  

        Slow if properties are already set. Setting the points and properties as
        matrices is faster.  

        Returns the point's index.  

        """
        return _robotsim.PointCloud_addPoint(self, p)

    def setPoint(self, index: "int", p: "double const [3]") -> "void":
        r"""
        setPoint(PointCloud self, int index, double const [3] p)


        Sets the position of the point at the given index to p.  

        """
        return _robotsim.PointCloud_setPoint(self, index, p)

    def getPoint(self, index: "int") -> "void":
        r"""
        getPoint(PointCloud self, int index)


        Returns the position of the point at the given index.  

        Return type: Vector3  

        """
        return _robotsim.PointCloud_getPoint(self, index)

    def numProperties(self) -> "int":
        r"""
        numProperties(PointCloud self) -> int


        Returns the number of properties.  

        """
        return _robotsim.PointCloud_numProperties(self)

    def setPointsAndProperties(self, np_array2: "double *") -> "void":
        r"""
        setPointsAndProperties(PointCloud self, double * np_array2)


        Sets all the points and m properties from the given n x (3+k) array.  

        """
        return _robotsim.PointCloud_setPointsAndProperties(self, np_array2)

    def setProperties(self, np_array2: "double *") -> "void":
        r"""
        setProperties(PointCloud self, double * np_array2)


        Sets all the properties of all points to the given nxk array.  

        """
        return _robotsim.PointCloud_setProperties(self, np_array2)

    def getProperties(self) -> "void":
        r"""
        getProperties(PointCloud self)


        Returns all the properties of all points as an array view.  

        Returns:  

            ndarray: an nxk Numpy array. Setting elements of this array will
            change the vertices.
         Return type: np.ndarray  

        """
        return _robotsim.PointCloud_getProperties(self)

    def addProperty(self, *args) -> "int":
        r"""
        addProperty(PointCloud self, std::string const & pname) -> int
        addProperty(PointCloud self, std::string const & pname, double * np_array) -> int


        Adds a new property with name pname, and sets values for this property to the
        given length-n array.  

        """
        return _robotsim.PointCloud_addProperty(self, *args)

    def setPropertyName(self, pindex: "int", pname: "std::string const &") -> "void":
        r"""
        setPropertyName(PointCloud self, int pindex, std::string const & pname)


        Sets the name of a given property.  

        """
        return _robotsim.PointCloud_setPropertyName(self, pindex, pname)

    def getPropertyName(self, pindex: "int") -> "std::string":
        r"""
        getPropertyName(PointCloud self, int pindex) -> std::string


        Returns the name of a given property.  

        """
        return _robotsim.PointCloud_getPropertyName(self, pindex)

    def propertyIndex(self, pname: "std::string const &") -> "int":
        r"""
        propertyIndex(PointCloud self, std::string const & pname) -> int


        Returns the index of a named property or -1 if it does not exist.  

        """
        return _robotsim.PointCloud_propertyIndex(self, pname)

    def setProperty(self, *args) -> "void":
        r"""
        setProperty(PointCloud self, int index, int pindex, double value)
        setProperty(PointCloud self, int index, std::string const & pname, double value)


        Sets the property named pname of point index to the given value.  

        """
        return _robotsim.PointCloud_setProperty(self, *args)

    def getProperty(self, *args) -> "double":
        r"""
        getProperty(PointCloud self, int index, int pindex) -> double
        getProperty(PointCloud self, int index, std::string const & pname) -> double


        Returns the property named pname of point index.  

        """
        return _robotsim.PointCloud_getProperty(self, *args)

    def translate(self, t: "double const [3]") -> "void":
        r"""
        translate(PointCloud self, double const [3] t)


        Translates all the points by v=v+t.  

        """
        return _robotsim.PointCloud_translate(self, t)

    def _transform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _transform(PointCloud self, double const [9] R, double const [3] t)


        Transforms all the points by the rigid transform v=R*v+t.  

        """
        return _robotsim.PointCloud__transform(self, R, t)

    def join(self, pc: "PointCloud") -> "void":
        r"""
        join(PointCloud self, PointCloud pc)


        Adds the given point cloud to this one. They must share the same properties or
        else an exception is raised.  

        """
        return _robotsim.PointCloud_join(self, pc)

    def setSetting(self, key: "std::string const &", value: "std::string const &") -> "void":
        r"""
        setSetting(PointCloud self, std::string const & key, std::string const & value)


        Sets the given setting.  

        """
        return _robotsim.PointCloud_setSetting(self, key, value)

    def getSetting(self, key: "std::string const &") -> "std::string":
        r"""
        getSetting(PointCloud self, std::string const & key) -> std::string


        Returns the given setting.  

        """
        return _robotsim.PointCloud_getSetting(self, key)

    def setDepthImage_d(self, intrinsics: "double const [4]", np_array2: "double *", depth_scale: "double") -> "void":
        r"""
        setDepthImage_d(PointCloud self, double const [4] intrinsics, double * np_array2, double depth_scale)


        Sets a structured point cloud from a depth image. [fx,fy,cx,cy] are the
        intrinsics parameters. The depth is given as a size hxw array, top to bottom.  

        """
        return _robotsim.PointCloud_setDepthImage_d(self, intrinsics, np_array2, depth_scale)

    def setDepthImage_f(self, intrinsics: "double const [4]", np_depth2: "float *", depth_scale: "double") -> "void":
        r"""
        setDepthImage_f(PointCloud self, double const [4] intrinsics, float * np_depth2, double depth_scale)


        Sets a structured point cloud from a depth image. [fx,fy,cx,cy] are the
        intrinsics parameters. The depth is given as a size hxw array, top to bottom.  

        """
        return _robotsim.PointCloud_setDepthImage_f(self, intrinsics, np_depth2, depth_scale)

    def setDepthImage_s(self, intrinsics: "double const [4]", np_depth2: "unsigned short *", depth_scale: "double") -> "void":
        r"""
        setDepthImage_s(PointCloud self, double const [4] intrinsics, unsigned short * np_depth2, double depth_scale)


        Sets a structured point cloud from a depth image. [fx,fy,cx,cy] are the
        intrinsics parameters. The depth is given as a size hxw array, top to bottom.  

        """
        return _robotsim.PointCloud_setDepthImage_s(self, intrinsics, np_depth2, depth_scale)

    def setRGBDImages_i_d(self, intrinsics: "double const [4]", np_array2: "unsigned int *", np_depth2: "double *", depth_scale: "double") -> "void":
        r"""
        setRGBDImages_i_d(PointCloud self, double const [4] intrinsics, unsigned int * np_array2, double * np_depth2, double depth_scale)


        Sets a structured point cloud from an RGBD (color,depth) image pair.
        [fx,fy,cx,cy] are the intrinsics parameters. The RGB colors are packed in
        0xrrggbb order, size hxw, top to bottom.  

        """
        return _robotsim.PointCloud_setRGBDImages_i_d(self, intrinsics, np_array2, np_depth2, depth_scale)

    def setRGBDImages_i_f(self, intrinsics: "double const [4]", np_array2: "unsigned int *", np_depth2: "float *", depth_scale: "double") -> "void":
        r"""
        setRGBDImages_i_f(PointCloud self, double const [4] intrinsics, unsigned int * np_array2, float * np_depth2, double depth_scale)


        Sets a structured point cloud from an RGBD (color,depth) image pair.
        [fx,fy,cx,cy] are the intrinsics parameters. The RGB colors are packed in
        0xrrggbb order, size hxw, top to bottom.  

        """
        return _robotsim.PointCloud_setRGBDImages_i_f(self, intrinsics, np_array2, np_depth2, depth_scale)

    def setRGBDImages_i_s(self, intrinsics: "double const [4]", np_array2: "unsigned int *", np_depth2: "unsigned short *", depth_scale: "double") -> "void":
        r"""
        setRGBDImages_i_s(PointCloud self, double const [4] intrinsics, unsigned int * np_array2, unsigned short * np_depth2, double depth_scale)


        Sets a structured point cloud from an RGBD (color,depth) image pair.
        [fx,fy,cx,cy] are the intrinsics parameters. The RGB colors are packed in
        0xrrggbb order, size hxw, top to bottom.  

        """
        return _robotsim.PointCloud_setRGBDImages_i_s(self, intrinsics, np_array2, np_depth2, depth_scale)

    def setRGBDImages_b_d(self, intrinsics: "double const [4]", np_array3: "unsigned char *", np_depth2: "double *", depth_scale: "double") -> "void":
        r"""
        setRGBDImages_b_d(PointCloud self, double const [4] intrinsics, unsigned char * np_array3, double * np_depth2, double depth_scale)


        Sets a structured point cloud from an RGBD (color,depth) image pair.
        [fx,fy,cx,cy] are the intrinsics parameters. The RGB colors are packed in
        0xrrggbb order, size hxw, top to bottom.  

        """
        return _robotsim.PointCloud_setRGBDImages_b_d(self, intrinsics, np_array3, np_depth2, depth_scale)

    def setRGBDImages_b_f(self, intrinsics: "double const [4]", np_array3: "unsigned char *", np_depth2: "float *", depth_scale: "double") -> "void":
        r"""
        setRGBDImages_b_f(PointCloud self, double const [4] intrinsics, unsigned char * np_array3, float * np_depth2, double depth_scale)


        Sets a structured point cloud from an RGBD (color,depth) image pair.
        [fx,fy,cx,cy] are the intrinsics parameters. The RGB colors are an h x w x 3
        array, top to bottom.  

        """
        return _robotsim.PointCloud_setRGBDImages_b_f(self, intrinsics, np_array3, np_depth2, depth_scale)

    def setRGBDImages_b_s(self, intrinsics: "double const [4]", np_array3: "unsigned char *", np_depth2: "unsigned short *", depth_scale: "double") -> "void":
        r"""
        setRGBDImages_b_s(PointCloud self, double const [4] intrinsics, unsigned char * np_array3, unsigned short * np_depth2, double depth_scale)


        Sets a structured point cloud from an RGBD (color,depth) image pair.
        [fx,fy,cx,cy] are the intrinsics parameters. The RGB colors are an h x w x 3
        array, top to bottom.  

        """
        return _robotsim.PointCloud_setRGBDImages_b_s(self, intrinsics, np_array3, np_depth2, depth_scale)
    dataPtr = property(_robotsim.PointCloud_dataPtr_get, _robotsim.PointCloud_dataPtr_set, doc=r"""dataPtr : p.void""")
    isStandalone = property(_robotsim.PointCloud_isStandalone_get, _robotsim.PointCloud_isStandalone_set, doc=r"""isStandalone : bool""")

    points = property(getPoints, setPoints)
    """An Nx3 matrix of point positions, where N is the number of points."""
    properties = property(getProperties, setProperties)
    """An NxM matrix of point properties, where N is the number of points and M is
    the number of properties."""

    def transform(self, R_or_T : Union[Matrix3,RigidTransform], t :Optional[Vector3] = None):
        """
        Transforms all the points by the rigid transform p=R*p+t
        """
        if t is not None:
            self._transform(R_or_T,t)
        else:
            self._transform(*R_or_T);

    def getPropertyNames(self) -> List[str]:
        """
        Returns the names of the properties.
        """
        return [self.getPropertyName(i) for i in range(self.numProperties())]

    def __reduce__(self):
        from klampt.io import loader
        jsonobj = loader.to_json(self,'PointCloud')
        return (loader.from_json,(jsonobj,'PointCloud'))

    def setDepthImage(self,intrinsics:Union[Sequence[float],Dict[str,float]], depth : np.ndarray, depth_scale:float=1.0):
        """
        Sets a structured point cloud from a depth image.

        Args:
            intrinsics (list or dict): intrinsics parameters [fx,fy,cx,cy] or a
                dictionary containing keys 'fx', 'fy', 'cx', 'cy'.
            depth (np.ndarray): the depth values, of shape (h,w).  Should have
                dtype float, np.float32, or np.uint16 for best performance.
            depth_scale (float, optional): converts depth image values to real
                depth units.
        """
        if isinstance(intrinsics,dict):
            try:
                intrinsics = intrinsics['fx'],intrinsics['fy'],intrinsics['cx'],intrinsics['cy']
            except Exception:
                raise ValueError("Invalid value for the intrinsics parameters")
        elif len(intrinsics) != 4:
            raise ValueError("Invalid value for the intrinsics parameters")
        if depth.dtype == float:
            return self.setDepthImage_d(intrinsics,depth,depth_scale)
        elif depth.dtype == np.float32:
            return self.setDepthImage_f(intrinsics,depth,depth_scale)
        elif depth.dtype == np.uint16:
            return self.setDepthImage_s(intrinsics,depth,depth_scale)
        else:
            return self.setDepthImage_d(intrinsics,depth,depth_scale)

    def setRGBDImages(self,intrinsics:Union[Sequence[float],Dict[str,float]], color : np.ndarray, depth : np.ndarray, depth_scale:float=1.0):
        """
        Sets a structured point cloud from a color,depth image pair.

        Args:
            intrinsics (list or dict): intrinsics parameters [fx,fy,cx,cy] or a
                dictionary containing keys 'fx', 'fy', 'cx', 'cy'.
            color (np.ndarray): the color values, of shape (h,w) or (h,w,3).
                In first case, must have dtype np.uint32 with r,g,b values
                packed in 0xrrggbb order.  In second case, if dtype is
                np.uint8, min and max are [0,255].  If dtype is float or
                np.float32, min and max are [0,1].
            depth (np.ndarray): the depth values, of shape (h,w).  Should have
                dtype float, np.float32, or np.uint16 for best performance.
            depth_scale (float, optional): converts depth image values to real
                depth units.
        """
        if isinstance(intrinsics,dict):
            try:
                intrinsics = intrinsics['fx'],intrinsics['fy'],intrinsics['cx'],intrinsics['cy']
            except Exception:
                raise ValueError("Invalid value for the intrinsics parameters")
        elif len(intrinsics) != 4:
            raise ValueError("Invalid value for the intrinsics parameters")
        if color.shape[0] != depth.shape[0] or color.shape[1] != depth.shape[1]:
            raise ValueError("Color and depth images need to have matching dimensions")
        if len(color.shape)==3:
            if color.shape[2] != 3:
                raise ValueError("Color image can only have 3 channels")
            if color.dtype != np.uint8:
                color = (color*255.0).astype(np.uint8)
            if depth.dtype == float:
                return self.setRGBDImages_b_d(intrinsics,color,depth,depth_scale)
            elif depth.dtype == np.float32:
                return self.setRGBDImages_b_f(intrinsics,color,depth,depth_scale)
            elif depth.dtype == np.uint16:
                return self.setRGBDImages_b_s(intrinsics,color,depth,depth_scale)
            else:
                return self.setRGBDImages_b_d(intrinsics,color,depth,depth_scale)
        else:
            if depth.dtype == float:
                return self.setRGBDImages_i_d(intrinsics,color,depth,depth_scale)
            elif depth.dtype == np.float32:
                return self.setRGBDImages_i_f(intrinsics,color,depth,depth_scale)
            elif depth.dtype == np.uint16:
                return self.setRGBDImages_i_s(intrinsics,color,depth,depth_scale)
            else:
                return self.setRGBDImages_i_d(intrinsics,color,depth,depth_scale)

    def getColors(self, format='rgb') -> np.ndarray:
        """
        Returns the colors of the point cloud in the given format.  If the
        point cloud has no colors, this returns None.  If the point cloud has no
        colors but has opacity, this returns white colors.

        Args:
            format: describes the output color format, either:

                - 'rgb': packed 32bit int, with the hex format 0xrrggbb (only 24
                    bits used),
                - 'bgr': packed 32bit int, with the hex format 0xbbggrr (only 24
                    bits used),
                - 'rgba': packed 32bit int, with the hex format 0xrrggbbaa,
                - 'bgra': packed 32bit int, with the hex format 0xbbggrraa,
                - 'argb': packed 32bit int, with the hex format 0xaarrggbb,
                - 'abgr': packed 32bit int, with the hex format 0xaabbggrr,
                - ('r','g','b'): triple with each channel in range [0,1]
                - ('r','g','b','a'): tuple with each channel in range [0,1]
                - 'channels': returns a list of channels, in the form (r,g,b) or 
                    (r,g,b,a), where each value in the channel has range [0,1].
                - 'opacity': returns opacity only, in the range [0,1].

        Returns:
            A an array of len(pc.points) colors corresponding to 
            the points in the point cloud.  If format='channels', the return
            value is a tuple (r,g,b) or (r,g,b,a).
        """
        from klampt.model.geometry import point_cloud_colors
        return point_cloud_colors(self,format)

    def setColors(self, colors : Union[list,np.ndarray], color_format='rgb',pc_property='auto'):
        """
        Sets the colors of the point cloud.

        Args:
            colors (list or numpy.ndarray): the array of colors, and each color 
                can be either ints, tuples, or channels, depending on color_format.
            color_format: describes the format of each element of ``colors``, and
                can be:

                - 'rgb': packed 32bit int, with the hex format 0xrrggbb (only 24
                    bits used),
                - 'bgr': packed 32bit int, with the hex format 0xbbggrr (only 24
                    bits used),
                - 'rgba': packed 32bit int, with the hex format 0xrrggbbaa,
                - 'bgra': packed 32bit int, with the hex format 0xbbggrraa,
                - 'argb': packed 32bit int, with the hex format 0xaarrggbb,
                - 'abgr': packed 32bit int, with the hex format 0xaabbggrr,
                - ('r','g','b'): triple with each channel in range [0,1]. Also use
                    this if colors is an n x 3 numpy array.
                - ('r','g','b','a'): tuple with each channel in range [0,1]. Also 
                    use this if colors is an n x 4 numpy array.
                - 'channels': ``colors`` is a list of 3 or 4 channels, in the form
                    (r,g,b) or (r,g,b,a), where each element in a channel has range
                    [0,1].
                - 'opacity': opacity only, in the range [0,1].

            pc_property (str): describes to which property the colors should be
                set.  'auto' determines chooses the property from the point cloud
                if it's already colored, or color_format if not.  'channels' sets
                the 'r', 'g', 'b', and optionally 'a' properties.

        """
        from klampt.model.geometry import point_cloud_set_colors
        return point_cloud_set_colors(self,colors,color_format,pc_property)



# Register PointCloud in _robotsim:
_robotsim.PointCloud_swigregister(PointCloud)

class GeometricPrimitive(object):
    r"""


    A geometric primitive. So far only points, spheres, segments, and AABBs can be
    constructed manually in the Python API.  

    Attributes:  

        type (str): Can be "Point", "Sphere", "Segment", "Triangle",
            "Polygon", "AABB", and "Box".  Semi-supported types include
            "Ellipsoid", and "Cylinder".
        properties (numpy array): a list of parameters defining the
            primitive. The interpretation is type-specific.


    C++ includes: geometry.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _robotsim.delete_GeometricPrimitive

    def __init__(self, *args):
        r"""
        __init__(GeometricPrimitive self) -> GeometricPrimitive
        __init__(GeometricPrimitive self, GeometricPrimitive rhs) -> GeometricPrimitive


        """
        _robotsim.GeometricPrimitive_swiginit(self, _robotsim.new_GeometricPrimitive(*args))

    def copy(self) -> "GeometricPrimitive":
        r"""
        copy(GeometricPrimitive self) -> GeometricPrimitive


        Creates a standalone object that is a copy of this.  

        """
        return _robotsim.GeometricPrimitive_copy(self)

    def set(self, arg2: "GeometricPrimitive") -> "void":
        r"""
        set(GeometricPrimitive self, GeometricPrimitive arg2)


        Copies the data of the argument into this.  

        """
        return _robotsim.GeometricPrimitive_set(self, arg2)

    def setPoint(self, pt: "double const [3]") -> "void":
        r"""
        setPoint(GeometricPrimitive self, double const [3] pt)


        """
        return _robotsim.GeometricPrimitive_setPoint(self, pt)

    def setSphere(self, c: "double const [3]", r: "double") -> "void":
        r"""
        setSphere(GeometricPrimitive self, double const [3] c, double r)


        """
        return _robotsim.GeometricPrimitive_setSphere(self, c, r)

    def setSegment(self, a: "double const [3]", b: "double const [3]") -> "void":
        r"""
        setSegment(GeometricPrimitive self, double const [3] a, double const [3] b)


        """
        return _robotsim.GeometricPrimitive_setSegment(self, a, b)

    def setTriangle(self, a: "double const [3]", b: "double const [3]", c: "double const [3]") -> "void":
        r"""
        setTriangle(GeometricPrimitive self, double const [3] a, double const [3] b, double const [3] c)


        """
        return _robotsim.GeometricPrimitive_setTriangle(self, a, b, c)

    def setPolygon(self, verts: "doubleVector") -> "void":
        r"""
        setPolygon(GeometricPrimitive self, doubleVector verts)


        """
        return _robotsim.GeometricPrimitive_setPolygon(self, verts)

    def setAABB(self, bmin: "double const [3]", bmax: "double const [3]") -> "void":
        r"""
        setAABB(GeometricPrimitive self, double const [3] bmin, double const [3] bmax)


        """
        return _robotsim.GeometricPrimitive_setAABB(self, bmin, bmax)

    def setBox(self, ori: "double const [3]", R: "double const [9]", dims: "double const [3]") -> "void":
        r"""
        setBox(GeometricPrimitive self, double const [3] ori, double const [9] R, double const [3] dims)


        """
        return _robotsim.GeometricPrimitive_setBox(self, ori, R, dims)

    def getType(self) -> "std::string":
        r"""
        getType(GeometricPrimitive self) -> std::string


        """
        return _robotsim.GeometricPrimitive_getType(self)

    def getProperties(self) -> "void":
        r"""
        getProperties(GeometricPrimitive self)


        """
        return _robotsim.GeometricPrimitive_getProperties(self)

    def setProperties(self, np_array: "double *") -> "void":
        r"""
        setProperties(GeometricPrimitive self, double * np_array)


        """
        return _robotsim.GeometricPrimitive_setProperties(self, np_array)

    def loadString(self, str: "char const *") -> "bool":
        r"""
        loadString(GeometricPrimitive self, char const * str) -> bool


        """
        return _robotsim.GeometricPrimitive_loadString(self, str)

    def saveString(self) -> "std::string":
        r"""
        saveString(GeometricPrimitive self) -> std::string


        """
        return _robotsim.GeometricPrimitive_saveString(self)
    dataPtr = property(_robotsim.GeometricPrimitive_dataPtr_get, _robotsim.GeometricPrimitive_dataPtr_set, doc=r"""dataPtr : p.void""")
    isStandalone = property(_robotsim.GeometricPrimitive_isStandalone_get, _robotsim.GeometricPrimitive_isStandalone_set, doc=r"""isStandalone : bool""")

    type = property(getType)
    """The type of the geometric primitive."""

    properties = property(getProperties, setProperties)
    """The properties of the geometric primitive.  Type dependent.  Retrieved
    by value, so you will need to use setProperties (or properties=...) for
    updates to take effect.
    """

    def __reduce__(self):
        from klampt.io import loader
        jsonobj = loader.to_json(self,'GeometricPrimitive')
        return (loader.from_json,(jsonobj,'GeometricPrimitive'))


# Register GeometricPrimitive in _robotsim:
_robotsim.GeometricPrimitive_swigregister(GeometricPrimitive)

class ImplicitSurface(object):
    r"""


    An axis-aligned volumetric grid representing a signed distance transform with >
    0 indicating outside and < 0 indicating inside.  

    In general, values are associated with cells rather than vertices.  

    Cell (i,j,k) contains a value, and has size (w,d,h) =
    ((bmax[0]-bmin[0])/dims[0], (bmax[1]-bmin[1])/dims[1],
    (bmax[2]-bmin[2])/dims[2]). It ranges over the box [w*i,w*(i+1)) x [d*j,d*(j+1))
    x [h*k,h*(k+1)).  

    The field should be assumed sampled at the **centers** of cells, i.e., at
    (w*(i+1/2),d*(j+1/2),h*(k+1/2)).  

    Attributes:  

        bmin (array of 3 doubles): contains the minimum bounds.

        bmax (array of 3 doubles): contains the maximum bounds.

        values (numpy array): contains a 3D array of
             ``dims[0] x dims[1] x dims[2]`` values.

        truncationDistance (float): inf for SDFs, and the truncation distance
             for TSDFs. Cells whose values are >= d are considered "sufficiently
             far" and distance / tolerance queries outside of this range are
             usually not meaningful.


    C++ includes: geometry.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _robotsim.delete_ImplicitSurface

    def __init__(self, *args):
        r"""
        __init__(ImplicitSurface self) -> ImplicitSurface
        __init__(ImplicitSurface self, ImplicitSurface rhs) -> ImplicitSurface


        """
        _robotsim.ImplicitSurface_swiginit(self, _robotsim.new_ImplicitSurface(*args))

    def copy(self) -> "ImplicitSurface":
        r"""
        copy(ImplicitSurface self) -> ImplicitSurface


        Creates a standalone object that is a copy of this.  

        """
        return _robotsim.ImplicitSurface_copy(self)

    def getBmin(self) -> "void":
        r"""
        getBmin(ImplicitSurface self)


        """
        return _robotsim.ImplicitSurface_getBmin(self)

    def setBmin(self, bmin: "double const [3]") -> "void":
        r"""
        setBmin(ImplicitSurface self, double const [3] bmin)


        """
        return _robotsim.ImplicitSurface_setBmin(self, bmin)

    def getBmax(self) -> "void":
        r"""
        getBmax(ImplicitSurface self)


        """
        return _robotsim.ImplicitSurface_getBmax(self)

    def setBmax(self, bmax: "double const [3]") -> "void":
        r"""
        setBmax(ImplicitSurface self, double const [3] bmax)


        """
        return _robotsim.ImplicitSurface_setBmax(self, bmax)

    def resize(self, sx: "int", sy: "int", sz: "int") -> "void":
        r"""
        resize(ImplicitSurface self, int sx, int sy, int sz)


        Resizes the x, y, and z dimensions of the grid.  

        """
        return _robotsim.ImplicitSurface_resize(self, sx, sy, sz)

    def set(self, *args) -> "void":
        r"""
        set(ImplicitSurface self, ImplicitSurface arg2)
        set(ImplicitSurface self, double value)
        set(ImplicitSurface self, int i, int j, int k, double value)


        Sets a specific element of a cell.  

        """
        return _robotsim.ImplicitSurface_set(self, *args)

    def get(self, i: "int", j: "int", k: "int") -> "double":
        r"""
        get(ImplicitSurface self, int i, int j, int k) -> double


        Gets a specific element of a cell.  

        """
        return _robotsim.ImplicitSurface_get(self, i, j, k)

    def shift(self, dv: "double") -> "void":
        r"""
        shift(ImplicitSurface self, double dv)


        Shifts the value uniformly.  

        """
        return _robotsim.ImplicitSurface_shift(self, dv)

    def scale(self, cv: "double") -> "void":
        r"""
        scale(ImplicitSurface self, double cv)


        Scales the value uniformly.  

        """
        return _robotsim.ImplicitSurface_scale(self, cv)

    def getValues(self) -> "void":
        r"""
        getValues(ImplicitSurface self)


        Returns a 3D Numpy array view of the values. Changes to this array will
        immediately take effect.  

        Return type: np.ndarray  

        """
        return _robotsim.ImplicitSurface_getValues(self)

    def setValues(self, np_array3: "double *") -> "void":
        r"""
        setValues(ImplicitSurface self, double * np_array3)


        Sets the values to a 3D numpy array.  

        """
        return _robotsim.ImplicitSurface_setValues(self, np_array3)

    def setTruncationDistance(self, d: "double") -> "void":
        r"""
        setTruncationDistance(ImplicitSurface self, double d)


        Sets the truncation distance for TSDFs.  

        """
        return _robotsim.ImplicitSurface_setTruncationDistance(self, d)

    def getTruncationDistance(self) -> "double":
        r"""
        getTruncationDistance(ImplicitSurface self) -> double


        Retrieves the truncation distance for TSDFs.  

        """
        return _robotsim.ImplicitSurface_getTruncationDistance(self)
    dataPtr = property(_robotsim.ImplicitSurface_dataPtr_get, _robotsim.ImplicitSurface_dataPtr_set, doc=r"""dataPtr : p.void""")
    isStandalone = property(_robotsim.ImplicitSurface_isStandalone_get, _robotsim.ImplicitSurface_isStandalone_set, doc=r"""isStandalone : bool""")

    bmin = property(getBmin, setBmin)

    bmax = property(getBmax, setBmax)

    def setBounds(self, bounds : Sequence[float]):
        """
        @deprecated

        Provided for backwards compatibility
        """
        import warnings
        warnings.warn("ImplicitSurface.setBounds will be deprecated in favor of bmin, bmax attributes in a future version of Klampt",DeprecationWarning)
        self.bmin = bounds[0:3]
        self.bmax = bounds[3:6]

    def getBounds(self) -> Sequence[float]:
        """
        @deprecated

        Provided for backwards compatibility
        """
        import warnings
        warnings.warn("ImplicitSurface. getBounds will be deprecated in favor of bmin, bmax attributes in a future version of Klampt",DeprecationWarning)
        return list(self.bmin) + list(self.bmax)

    bounds = property(getBounds, setBounds)
    """Klampt 0.9 backwards compatibility accessor for the (bmin, bmax) pair."""

    values = property(getValues, setValues)

    def __reduce__(self):
        from klampt.io import loader
        jsonobj = loader.to_json(self,'ImplicitSurface')
        return (loader.from_json,(jsonobj,'ImplicitSurface'))


# Register ImplicitSurface in _robotsim:
_robotsim.ImplicitSurface_swigregister(ImplicitSurface)

class OccupancyGrid(object):
    r"""


    An occupancy grid with 1 indicating inside and 0 indicating outside. Can also be
    a fuzzy (probabilistic / density) grid.  

    In general, values are associated with cells rather than vertices.  

    Cell (i,j,k) contains an occupancy / density value, and has size (w,d,h) =
    ((bmax[0]-bmin[0])/dims[0], (bmax[1]-bmin[1])/dims[1],
    (bmax[2]-bmin[2])/dims[2]). It ranges over the box [w*i,w*(i+1)) x [d*j,d*(j+1))
    x [h*k,h*(k+1)).  

    Attributes:  

        bmin (array of 3 doubles): contains the minimum bounds.

        bmax (array of 3 doubles): contains the maximum bounds.

        values (numpy array): contains a 3D array of
             ``dims[0] x dims[1] x dims[2]`` values.

        occupancyThreshold (float): set to 0.5 by default. Collision
            detection treats all cells whose values are greater than this
            value as occupied.


    C++ includes: geometry.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _robotsim.delete_OccupancyGrid

    def __init__(self, *args):
        r"""
        __init__(OccupancyGrid self) -> OccupancyGrid
        __init__(OccupancyGrid self, OccupancyGrid rhs) -> OccupancyGrid


        """
        _robotsim.OccupancyGrid_swiginit(self, _robotsim.new_OccupancyGrid(*args))

    def copy(self) -> "OccupancyGrid":
        r"""
        copy(OccupancyGrid self) -> OccupancyGrid


        Creates a standalone object that is a copy of this.  

        """
        return _robotsim.OccupancyGrid_copy(self)

    def getBmin(self) -> "void":
        r"""
        getBmin(OccupancyGrid self)


        """
        return _robotsim.OccupancyGrid_getBmin(self)

    def setBmin(self, bmin: "double const [3]") -> "void":
        r"""
        setBmin(OccupancyGrid self, double const [3] bmin)


        """
        return _robotsim.OccupancyGrid_setBmin(self, bmin)

    def getBmax(self) -> "void":
        r"""
        getBmax(OccupancyGrid self)


        """
        return _robotsim.OccupancyGrid_getBmax(self)

    def setBmax(self, bmax: "double const [3]") -> "void":
        r"""
        setBmax(OccupancyGrid self, double const [3] bmax)


        """
        return _robotsim.OccupancyGrid_setBmax(self, bmax)

    def resize(self, sx: "int", sy: "int", sz: "int") -> "void":
        r"""
        resize(OccupancyGrid self, int sx, int sy, int sz)


        Resizes the x, y, and z dimensions of the grid.  

        """
        return _robotsim.OccupancyGrid_resize(self, sx, sy, sz)

    def set(self, *args) -> "void":
        r"""
        set(OccupancyGrid self, OccupancyGrid arg2)
        set(OccupancyGrid self, double value)
        set(OccupancyGrid self, int i, int j, int k, double value)


        Sets a specific element of a cell.  

        """
        return _robotsim.OccupancyGrid_set(self, *args)

    def get(self, i: "int", j: "int", k: "int") -> "double":
        r"""
        get(OccupancyGrid self, int i, int j, int k) -> double


        Gets a specific element of a cell.  

        """
        return _robotsim.OccupancyGrid_get(self, i, j, k)

    def shift(self, dv: "double") -> "void":
        r"""
        shift(OccupancyGrid self, double dv)


        Shifts the value uniformly.  

        """
        return _robotsim.OccupancyGrid_shift(self, dv)

    def scale(self, cv: "double") -> "void":
        r"""
        scale(OccupancyGrid self, double cv)


        Scales the value uniformly.  

        """
        return _robotsim.OccupancyGrid_scale(self, cv)

    def getValues(self) -> "void":
        r"""
        getValues(OccupancyGrid self)


        Returns a 3D Numpy array view of the values. Changes to this array will
        immediately take effect.  

        Return type: np.ndarray  

        """
        return _robotsim.OccupancyGrid_getValues(self)

    def setValues(self, np_array3: "double *") -> "void":
        r"""
        setValues(OccupancyGrid self, double * np_array3)


        Sets the values to a 3D numpy array.  

        """
        return _robotsim.OccupancyGrid_setValues(self, np_array3)

    def setOccupancyThreshold(self, threshold: "double") -> "void":
        r"""
        setOccupancyThreshold(OccupancyGrid self, double threshold)


        Sets the threshold for collision detection.  

        """
        return _robotsim.OccupancyGrid_setOccupancyThreshold(self, threshold)

    def getOccupancyThreshold(self) -> "double":
        r"""
        getOccupancyThreshold(OccupancyGrid self) -> double


        Gets the threshold for collision detection.  

        """
        return _robotsim.OccupancyGrid_getOccupancyThreshold(self)
    dataPtr = property(_robotsim.OccupancyGrid_dataPtr_get, _robotsim.OccupancyGrid_dataPtr_set, doc=r"""dataPtr : p.void""")
    isStandalone = property(_robotsim.OccupancyGrid_isStandalone_get, _robotsim.OccupancyGrid_isStandalone_set, doc=r"""isStandalone : bool""")

    bmin = property(getBmin, setBmin)
    bmax = property(getBmax, setBmax)

    def setBounds(self, bounds : Sequence[float]):
        """
        @deprecated

        Provided for backwards compatibility
        """
        import warnings
        warnings.warn("OccupancyGrid.setBounds will be deprecated in favor of bmin, bmax attributes in a future version of Klampt",DeprecationWarning)
        self.bmin = bounds[0:3]
        self.bmax = bounds[3:6]

    def getBounds(self) -> Sequence[float]:
        """
        @deprecated

        Provided for backwards compatibility
        """
        import warnings
        warnings.warn("OccupancyGrid. getBounds will be deprecated in favor of bmin, bmax attributes in a future version of Klampt",DeprecationWarning)
        return list(self.bmin) + list(self.bmax)

    bounds = property(getBounds, setBounds)
    """Klampt 0.9 backwards compatibility accessor for the (bmin, bmax) pair."""

    values = property(getValues, setValues)

    def __reduce__(self):
        from klampt.io import loader
        jsonobj = loader.to_json(self,'OccupancyGrid')
        return (loader.from_json,(jsonobj,'OccupancyGrid'))


# Register OccupancyGrid in _robotsim:
_robotsim.OccupancyGrid_swigregister(OccupancyGrid)

class Heightmap(object):
    r"""


    A height (elevation) map or a depth map.  

    In elevation-map form (`viewport.perspective=false`), the values are the
    z-height of the terrain at each grid point. In depth-map form
    (`viewport.perspective=true`), the values are the depths of each grid point (not
    distance) from the origin in the +z direction.  

    Note that unlike volume grid types, each grid entry is defined at a vertex, not
    a cell. In elevation map form, the (i,j) cell is associated with the vertex
    ((i-cx)/fx,(n-1-j-cy)/fy,heights[i,j]) where n is `heights.shape[1]`. Note that
    the y-axis is flipped in the heightmap compared to the viewport such that the
    image is given in standard top-down convention.  

    In depth map form, the (i,j) cell is associated with the vertex
    (d*(i-cx)/fx,d*(j-cy)/fy,d) where d=heights[i,j]. Note that the y-axis is not
    flipped in this convention.  

    Attributes:  

        viewport (Viewport): contains the size (w,h), projection (perspective)
             intrinsics (fx,fy,cx,cy), and pose (pose) of the heightmap
             reference coordinate system.  Note that to change the viewport, you
             will need to use `vp = hm.viewport; vp.w = ...; hm.viewport = vp`.

        heights (np.ndarray): contains a 2D array of (w,h) values.

        colorImage (np.ndarray): contains a 3D image array of colors in
             grayscale (h,w), RGB (h,w,3), or RGBA (h,w,4) format.


    C++ includes: geometry.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _robotsim.delete_Heightmap

    def __init__(self, *args):
        r"""
        __init__(Heightmap self) -> Heightmap
        __init__(Heightmap self, Heightmap rhs) -> Heightmap


        """
        _robotsim.Heightmap_swiginit(self, _robotsim.new_Heightmap(*args))

    def copy(self) -> "Heightmap":
        r"""
        copy(Heightmap self) -> Heightmap


        Creates a standalone object that is a copy of this.  

        """
        return _robotsim.Heightmap_copy(self)

    def resize(self, w: "int", h: "int") -> "void":
        r"""
        resize(Heightmap self, int w, int h)


        Resizes the height map.  

        """
        return _robotsim.Heightmap_resize(self, w, h)

    def setSize(self, width: "double", height: "double") -> "void":
        r"""
        setSize(Heightmap self, double width, double height)


        Sets an orthographic projection (elevation map) with the given width and height.  

        """
        return _robotsim.Heightmap_setSize(self, width, height)

    def setFOV(self, fovx: "double", fovy: "double"=-1) -> "void":
        r"""
        setFOV(Heightmap self, double fovx, double fovy=-1)


        Sets an perspective projection (depth map) with the given x and y fields of view
        and centered focal point. If fovy=-1, then it will be set so that pixels are
        square.  

        """
        return _robotsim.Heightmap_setFOV(self, fovx, fovy)

    def setIntrinsics(self, fx: "double", fy: "double", cx: "double"=-1, cy: "double"=-1) -> "void":
        r"""
        setIntrinsics(Heightmap self, double fx, double fy, double cx=-1, double cy=-1)


        Sets an perspective projection (depth map) with the given intrinsics fx, fy, cx,
        cy. If cx or cy are negative, then cx = (w-1)/2, cy = (h-1)/2.  

        """
        return _robotsim.Heightmap_setIntrinsics(self, fx, fy, cx, cy)

    def isPerspective(self) -> "bool":
        r"""
        isPerspective(Heightmap self) -> bool


        Returns true if the heightmaps is in perspective (depth map) mode.  

        """
        return _robotsim.Heightmap_isPerspective(self)

    def isOrthographic(self) -> "bool":
        r"""
        isOrthographic(Heightmap self) -> bool


        Returns true if the heightmaps is in orthographic (elevation map) mode.  

        """
        return _robotsim.Heightmap_isOrthographic(self)

    def getViewport(self) -> "Viewport":
        r"""
        getViewport(Heightmap self) -> Viewport


        Retrieves the viewport, which defines how the heightmap data is mapped to
        spatial coordinates. Note that this is returned by value. If you change an
        attribute of the viewport, you should call setViewport (or viewport=...) to
        update the heightmap's viewport.  

        """
        return _robotsim.Heightmap_getViewport(self)

    def setViewport(self, viewport: "Viewport") -> "void":
        r"""
        setViewport(Heightmap self, Viewport viewport)


        Sets the viewport.  

        """
        return _robotsim.Heightmap_setViewport(self, viewport)

    def set(self, *args) -> "void":
        r"""
        set(Heightmap self, Heightmap arg2)
        set(Heightmap self, double value)
        set(Heightmap self, int i, int j, double value)


        Sets the height of a vertex (note, indices are x and y units, which is reversed
        from image convention)  

        """
        return _robotsim.Heightmap_set(self, *args)

    def get(self, i: "int", j: "int") -> "double":
        r"""
        get(Heightmap self, int i, int j) -> double


        Gets the height of a vertex (note, indices are x and y units, which is reversed
        from image convention)  

        """
        return _robotsim.Heightmap_get(self, i, j)

    def getVertex(self, i: "int", j: "int") -> "void":
        r"""
        getVertex(Heightmap self, int i, int j)


        Gets the coordinates of a vertex (note, indices are x and y units, which is
        reversed from image convention)  

        """
        return _robotsim.Heightmap_getVertex(self, i, j)

    def getSize(self) -> "void":
        r"""
        getSize(Heightmap self)


        Returns the width/height of the heightmap in real coordinates. (only directly
        interpretable in orthographic mode; in perspective mode the returned value is
        the horizontal / vertical FOV in radians.)  

        """
        return _robotsim.Heightmap_getSize(self)

    def getResolution(self) -> "void":
        r"""
        getResolution(Heightmap self)


        Returns the width/height of each cell of the heightmap in real coordinates.
        (only directly interpretable in orthographic mode; in perspective mode the
        returned value is the resolution at 1 unit depth.)  

        """
        return _robotsim.Heightmap_getResolution(self)

    def shift(self, dh: "double") -> "void":
        r"""
        shift(Heightmap self, double dh)


        Shifts the height uniformly.  

        """
        return _robotsim.Heightmap_shift(self, dh)

    def scale(self, c: "double") -> "void":
        r"""
        scale(Heightmap self, double c)


        Scales the height uniformly.  

        """
        return _robotsim.Heightmap_scale(self, c)

    def getHeights(self) -> "void":
        r"""
        getHeights(Heightmap self)


        Returns a 2D Numpy array view of the values. Result has shape w x h and has
        float32 dtype. Modifications to the array are immediately reflected in the
        heightmap.  

        Return type: np.ndarray  

        """
        return _robotsim.Heightmap_getHeights(self)

    def setHeights_f(self, np_array2: "float *") -> "void":
        r"""
        setHeights_f(Heightmap self, float * np_array2)


        Sets the values to a 2D numpy array of shape w x h.  

        """
        return _robotsim.Heightmap_setHeights_f(self, np_array2)

    def hasColors(self) -> "bool":
        r"""
        hasColors(Heightmap self) -> bool


        Returns true if colors are present.  

        """
        return _robotsim.Heightmap_hasColors(self)

    def clearColors(self) -> "void":
        r"""
        clearColors(Heightmap self)


        Erases all colors.  

        """
        return _robotsim.Heightmap_clearColors(self)

    def setColor(self, *args) -> "void":
        r"""
        setColor(Heightmap self, double intensity)
        setColor(Heightmap self, double const [4] rgba)
        setColor(Heightmap self, int i, int j, double intensity)
        setColor(Heightmap self, int i, int j, double const [4] rgba)


        Gets the RGBA color of a vertex (note, indices are x and y units, which is
        reversed from image convention)  

        """
        return _robotsim.Heightmap_setColor(self, *args)

    def getColor(self, i: "int", j: "int") -> "void":
        r"""
        getColor(Heightmap self, int i, int j)


        Gets the RGBA color of a vertex (note, indices are x and y units, which is
        reversed from image convention)  

        Return type: Tuple[float,float,float,float]  

        """
        return _robotsim.Heightmap_getColor(self, i, j)

    def getColorImage(self) -> "void":
        r"""
        getColorImage(Heightmap self)


        Returns a 3D Numpy array view of the color image (h x w x (1, 3, or 4)), with
        rows ordered top to bottom.  

        Return type: np.ndarray  

        """
        return _robotsim.Heightmap_getColorImage(self)

    def setColorImage_b(self, np_array3: "unsigned char *") -> "void":
        r"""
        setColorImage_b(Heightmap self, unsigned char * np_array3)


        Sets the values to a 3D numpy array (h x w x 1, 3, or (1, 3, or 4)), with rows
        ordered top to bottom.  

        """
        return _robotsim.Heightmap_setColorImage_b(self, np_array3)

    def setColorImage_i(self, np_array2: "unsigned int *") -> "void":
        r"""
        setColorImage_i(Heightmap self, unsigned int * np_array2)


        Sets colors to a 32-bit RGBA image (size h x w) with rows ordered top to bottom.  

        """
        return _robotsim.Heightmap_setColorImage_i(self, np_array2)

    def getColorImage_i(self) -> "void":
        r"""
        getColorImage_i(Heightmap self)


        Retrieves a 32-bit RGBA image of the heightmap's colors (h x w)  

        Return type: np.ndarray  

        """
        return _robotsim.Heightmap_getColorImage_i(self)

    def getColorImage_d(self) -> "void":
        r"""
        getColorImage_d(Heightmap self)


        Retrieves a floating point RGB, RGBA, or L image (h x w x (1, 3, or 4)) with
        rows ordered from top to bottom.  

        Return type: np.ndarray  

        """
        return _robotsim.Heightmap_getColorImage_d(self)

    def numProperties(self) -> "int":
        r"""
        numProperties(Heightmap self) -> int


        Returns the number of properties.  

        """
        return _robotsim.Heightmap_numProperties(self)

    def addProperty(self, *args) -> "int":
        r"""
        addProperty(Heightmap self, std::string const & pname) -> int
        addProperty(Heightmap self, std::string const & pname, double * np_array2) -> int


        Adds a new property and sets it to an array of size (w x h)  

        """
        return _robotsim.Heightmap_addProperty(self, *args)

    def propertyIndex(self, pname: "std::string const &") -> "int":
        r"""
        propertyIndex(Heightmap self, std::string const & pname) -> int


        Retrieves the index associated with a property name.  

        """
        return _robotsim.Heightmap_propertyIndex(self, pname)

    def setProperty(self, i: "int", j: "int", np_array: "double *") -> "void":
        r"""
        setProperty(Heightmap self, int i, int j, double * np_array)


        Sets an individual pixel's property vector.  

        """
        return _robotsim.Heightmap_setProperty(self, i, j, np_array)

    def getProperty(self, i: "int", j: "int") -> "void":
        r"""
        getProperty(Heightmap self, int i, int j)


        Retrieves an individual pixel's property vector.  

        Return type: np.ndarray  

        """
        return _robotsim.Heightmap_getProperty(self, i, j)

    def setProperties(self, pindex: "int", np_array2: "double *") -> "void":
        r"""
        setProperties(Heightmap self, int pindex, double * np_array2)


        Sets a property to an array of size (w x h)  

        """
        return _robotsim.Heightmap_setProperties(self, pindex, np_array2)

    def getProperties(self, pindex: "int") -> "void":
        r"""
        getProperties(Heightmap self, int pindex)


        Retrieves a view of the property of size (w x h)  

        Return type: np.ndarray  

        """
        return _robotsim.Heightmap_getProperties(self, pindex)
    dataPtr = property(_robotsim.Heightmap_dataPtr_get, _robotsim.Heightmap_dataPtr_set, doc=r"""dataPtr : p.void""")
    isStandalone = property(_robotsim.Heightmap_isStandalone_get, _robotsim.Heightmap_isStandalone_set, doc=r"""isStandalone : bool""")

    def __reduce__(self):
        from klampt.io import loader
        jsonobj = loader.to_json(self,'Heightmap')
        return (loader.from_json,(jsonobj,'Heightmap'))

    def setHeights(self, arr : 'np.ndarray'):
        """
        Sets heights from a numpy array.  Handles conversions to float32. 

        Note that the x,y indexing differs from image orientation.  If you want
        to set heights from an image with (row,col) ordering, use
        setHeightImage.

        Args:
            arr (np.ndarray): the height values, of shape (w,h).
        """
        self.setHeights_f(arr.astype(np.float32))

    def setHeightImage(self, img : 'np.ndarray', height_scale : float = 1.0):
        """
        Sets heights from a height image.  Handles image orientation.

        Args:
            img (np.ndarray): the height values, of shape (h,w).  Should have
                dtype float, np.float32, or np.uint16 for best performance.
            height_scale (float, optional): converts depth image values to real
                depth units.
        """
        if len(img.shape) != 2:
            raise ValueError("Invalid shape for the height image")
        img = img.swapaxes(0,1)
        return self.setHeights(img*height_scale)

    def getHeightImage(self) -> 'np.ndarray':
        """
        Gets heights as a height image.  Handles image orientation.
        Result has float32 dtype.

        Returns:
            np.ndarray: the height values, of shape (h,w).
        """
        img = self.getHeights()
        return img.swapaxes(0,1)

    def getHeightImage_b(self) -> Tuple['np.ndarray',float]:
        """
        Gets heights as a uint8 height image.  Handles image orientation.

        Returns:
            np.ndarray, float: the height values, of shape (h,w) and dtype
            uint8, and the height scale.

        """
        himg = self.getHeightImage()
        h_max = np.max(himg)
        return (np.clip((himg/h_max)*255.0,0,255).astype(np.uint8),h_max)

    def getHeightImage_s(self) -> Tuple['np.ndarray',float]:
        """
        Gets heights as a uint16 height image.  Handles image orientation.

        Returns:
            np.ndarray, float: the height values, of shape (h,w) and dtype
            uint16, and the height scale.

        """
        himg = self.getHeightImage()
        h_max = np.max(himg)
        return (np.clip((himg/h_max)*65535.0,0,65535).astype(np.uint16),h_max)

    def setColorImage(self, img : 'np.ndarray'):
        """
        Sets colors from a color image.

        Args:
            img (np.ndarray): the color values, of shape (h,w) or (h,w,3) or
                (h,w,4). Should have dtype float, np.float32, np.uint32
                (RGBA 32-bit), or np.uint8.
        """
        if len(img.shape) != 2 and len(img.shape) != 3:
            raise ValueError("Invalid shape for the color image")
        if len(img.shape) == 2:
            if img.dtype == np.uint32:
                return self.setColorImage_i(img)
            elif img.dtype == np.uint8:
                return self.setColorImage_b(img.reshape(img.shape[0],img.shape[1],1))
            elif img.dtype == float or img.dtype == np.float32:
                return self.setColorImage_b((img.reshape(img.shape[0],img.shape[1],1)*255.0).astype(np.uint8))
            else:
                raise ValueError("Invalid dtype for the color image, can use np.uint32, np.uint8, or float")
        else:
            if img.shape[2] != 3 and img.shape[2] != 4:
                raise ValueError("Invalid shape for the color image")
            if img.dtype == np.uint8:
                return self.setColorImage_b(img)
            elif img.dtype == float or img.dtype == np.float32:
                return self.setColorImage_b((img*255.0).astype(np.uint8))
            else:
                raise ValueError("Invalid dtype for the height image, can use float or np.uint8")

    def setPropertyImage(self, pindex : int, img : 'np.ndarray'):
        """
        Sets property channel pindex to a numpy image.

        Handles image orientation.

        Args:
            pindex (int): the property index.
            img (np.ndarray): the property values, of shape (h,w).
        """
        if len(img.shape) != 2:
            raise ValueError("Invalid shape for the property image")
        img = img.swapaxes(0,1)
        return self.setProperties(pindex,img)

    heights = property(getHeights, setHeights)
    colorImage = property(getColorImage, setColorImage)
    viewport = property(getViewport, setViewport)


# Register Heightmap in _robotsim:
_robotsim.Heightmap_swigregister(Heightmap)

class DistanceQuerySettings(object):
    r"""


    Configures the _ext distance queries of :class:`~klampt.Geometry3D`.  

    The calculated result satisfies :math:`Dcalc \leq D(1+relErr) + absErr` unless
    :math:`D \geq upperBound`, in which case Dcalc=upperBound may be returned.  

    Attributes:  

        relErr (float, optional): Allows a relative error in the reported
            distance to speed up computation.  Default 0.
        absErr (float, optional): Allows an absolute error in the reported
            distance to speed up computation.  Default 0.
        upperBound (float, optional): The calculation may branch if D exceeds
            this bound.


    C++ includes: geometry.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(DistanceQuerySettings self) -> DistanceQuerySettings


        """
        _robotsim.DistanceQuerySettings_swiginit(self, _robotsim.new_DistanceQuerySettings())
    relErr = property(_robotsim.DistanceQuerySettings_relErr_get, _robotsim.DistanceQuerySettings_relErr_set, doc=r"""relErr : double""")
    absErr = property(_robotsim.DistanceQuerySettings_absErr_get, _robotsim.DistanceQuerySettings_absErr_set, doc=r"""absErr : double""")
    upperBound = property(_robotsim.DistanceQuerySettings_upperBound_get, _robotsim.DistanceQuerySettings_upperBound_set, doc=r"""upperBound : double""")
    __swig_destroy__ = _robotsim.delete_DistanceQuerySettings

# Register DistanceQuerySettings in _robotsim:
_robotsim.DistanceQuerySettings_swigregister(DistanceQuerySettings)

class DistanceQueryResult(object):
    r"""


    The result from a "fancy" distance query of :class:`~klampt.Geometry3D`.  

    Attributes:  

        d (float): The calculated distance, with negative values indicating
            penetration.  Can also be upperBound if the branch was hit.
        hasClosestPoints (bool):  If true, the closest point information is
            given in cp0 and cp1, and elem1 and elem2
        hasGradients (bool):  f true, distance gradient information is given
            in grad0 and grad1.
        cp1, cp2 (list of 3 floats, optional): closest points on self vs other,
            both given in world coordinates
        grad1, grad2 (list of 3 floats, optional): the gradients of the
            objects' signed distance fields at the closest points.  Given in
            world coordinates.

            I.e., to move object1 to touch object2, move it in direction
            grad1 by distance -d.  Note that grad2 is always -grad1.
        elems1, elems2 (int): for compound objects, these are the
            element indices corresponding to the closest points.


    C++ includes: geometry.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(DistanceQueryResult self) -> DistanceQueryResult


        """
        _robotsim.DistanceQueryResult_swiginit(self, _robotsim.new_DistanceQueryResult())
    d = property(_robotsim.DistanceQueryResult_d_get, _robotsim.DistanceQueryResult_d_set, doc=r"""d : double""")
    hasClosestPoints = property(_robotsim.DistanceQueryResult_hasClosestPoints_get, _robotsim.DistanceQueryResult_hasClosestPoints_set, doc=r"""hasClosestPoints : bool""")
    hasGradients = property(_robotsim.DistanceQueryResult_hasGradients_get, _robotsim.DistanceQueryResult_hasGradients_set, doc=r"""hasGradients : bool""")
    cp1 = property(_robotsim.DistanceQueryResult_cp1_get, _robotsim.DistanceQueryResult_cp1_set, doc=r"""cp1 : std::vector<(double,std::allocator<(double)>)>""")
    cp2 = property(_robotsim.DistanceQueryResult_cp2_get, _robotsim.DistanceQueryResult_cp2_set, doc=r"""cp2 : std::vector<(double,std::allocator<(double)>)>""")
    grad1 = property(_robotsim.DistanceQueryResult_grad1_get, _robotsim.DistanceQueryResult_grad1_set, doc=r"""grad1 : std::vector<(double,std::allocator<(double)>)>""")
    grad2 = property(_robotsim.DistanceQueryResult_grad2_get, _robotsim.DistanceQueryResult_grad2_set, doc=r"""grad2 : std::vector<(double,std::allocator<(double)>)>""")
    elem1 = property(_robotsim.DistanceQueryResult_elem1_get, _robotsim.DistanceQueryResult_elem1_set, doc=r"""elem1 : int""")
    elem2 = property(_robotsim.DistanceQueryResult_elem2_get, _robotsim.DistanceQueryResult_elem2_set, doc=r"""elem2 : int""")
    __swig_destroy__ = _robotsim.delete_DistanceQueryResult

# Register DistanceQueryResult in _robotsim:
_robotsim.DistanceQueryResult_swigregister(DistanceQueryResult)

class ContactQueryResult(object):
    r"""


    The result from a contact query of :class:`~klampt.Geometry3D`. The number of
    contacts n is variable.  

    Attributes:  

        depths (list of n floats): penetration depths for each contact point.
            The depth is measured with respect to the padded geometry, and must
            be nonnegative. A value of 0 indicates that depth cannot be
            determined accurately.
        points1, points2 (list of n lists of floats): contact points on self vs
            other,  The top level list has n entries, and each entry is a
            3-list expressed in world coordinates.  If an object is padded,
            these points are on the surface of the padded geometry.
        normals (list of n lists of floats): the outward-facing contact normal
            from this to other at each contact point, given in world
            coordinates.  Each entry is a 3-list, and can be a unit vector,
            or [0,0,0] if the the normal cannot be computed properly.
        elems1, elems2 (list of n ints): for compound objects, these are the
            element indices corresponding to each contact.


    C++ includes: geometry.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(ContactQueryResult self) -> ContactQueryResult


        """
        _robotsim.ContactQueryResult_swiginit(self, _robotsim.new_ContactQueryResult())
    depths = property(_robotsim.ContactQueryResult_depths_get, _robotsim.ContactQueryResult_depths_set, doc=r"""depths : std::vector<(double,std::allocator<(double)>)>""")
    points1 = property(_robotsim.ContactQueryResult_points1_get, _robotsim.ContactQueryResult_points1_set, doc=r"""points1 : std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)>""")
    points2 = property(_robotsim.ContactQueryResult_points2_get, _robotsim.ContactQueryResult_points2_set, doc=r"""points2 : std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)>""")
    normals = property(_robotsim.ContactQueryResult_normals_get, _robotsim.ContactQueryResult_normals_set, doc=r"""normals : std::vector<(std::vector<(double,std::allocator<(double)>)>,std::allocator<(std::vector<(double,std::allocator<(double)>)>)>)>""")
    elems1 = property(_robotsim.ContactQueryResult_elems1_get, _robotsim.ContactQueryResult_elems1_set, doc=r"""elems1 : std::vector<(int,std::allocator<(int)>)>""")
    elems2 = property(_robotsim.ContactQueryResult_elems2_get, _robotsim.ContactQueryResult_elems2_set, doc=r"""elems2 : std::vector<(int,std::allocator<(int)>)>""")
    __swig_destroy__ = _robotsim.delete_ContactQueryResult

# Register ContactQueryResult in _robotsim:
_robotsim.ContactQueryResult_swigregister(ContactQueryResult)

class Geometry3D(object):
    r"""


    The three-D geometry container used throughout Klampt.  

    There are eight currently supported types of geometry:  

    *   primitives (:class:`GeometricPrimitive`)  
    *   convex hulls (:class:`ConvexHull`)  
    *   triangle meshes (:class:`TriangleMesh`)  
    *   point clouds (:class:`PointCloud`)  
    *   implicit surfaces (:class:`ImplicitSurface`)  
    *   occupancy grids (:class:`OccupancyGrid`)  
    *   heightmaps (:class:`Heightmap`)  
    *   groups ("Group" type)  

    For now we also support the "VolumeGrid" identifier which is treated as an
    alias for "ImplicitSurface". This will be deprecated in a future version  

    This class acts as a uniform container of all of these types.  

    There are two modes in which a Geometry3D can be used. It can be a standalone
    geometry, which means it is a container of geometry data, or it can be a
    reference to a world item's geometry. For references, modifiers change the world
    item's geometry.  

    **Current transform**  

    Each geometry stores a "current" transform, which is automatically updated for
    world items' geometries. Proximity queries are then performed *with respect to
    the transformed geometries*. Crucially, the underlying geometry is not changed,
    because that could be computationally expensive.  

    **Creating / modifying the geometry**  

    Use the constructor, the :meth:`set`, or the set[TYPE]() methods to completely
    change the geometry's data.  

    Note: if you want to set a world item's geometry to have the same contents as a
    standalone geometry, use the set(rhs) function rather than the assignment (=)
    operator. `object.geometry() = rhs` does not work.  

    Modifiers include:  

    *   :meth:`setCurrentTransform`: updates the current transform. (This call is
        very fast.)  
    *   :meth:`translate`, :meth:`scale`, :meth:`rotate`, and :meth:`transform`
        transform the underlying geometry. Any collision data structures will be
        recomputed after transformation.  
    *   :meth:`loadFile`: load from OFF, OBJ, STL, PCD, etc. Also supports native
        Klamp't types .geom and .vol.  

    .. note::  

        Avoid the use of translate, rotate, and transform to represent object
        movement.  Use setCurrentTransform instead.
     **Proximity queries**  

    *   :meth:`collides`: boolean collision query.  
    *   :meth:`withinDistance`: boolean proximity query.  
    *   :meth:`distance` and :meth:`distance_ext`: numeric-valued distance query.
        The distance may be negative to indicate signed distance, available for
        certain geometry types. Also returns closest points for certain geometry
        types.  
    *   :meth:`distance_point` and :meth:`distance_point_ext`: numeric valued
        distance-to-point queries.  
    *   :meth:`contacts`: estimates the contact region between two objects.  
    *   :meth:`rayCast` and :meth:`rayCast_ext`: ray-cast queries.  

    For most geometry types (TriangleMesh, PointCloud, ConvexHull), the first time
    you perform a query, some collision detection data structures will be
    initialized. This preprocessing step can take some time for complex geometries.
    If you want to do this at a specific time, you can call :meth:`refreshCollider`
    to initialize the data structures.  

    Note: Modifying the underlying geometry data (such as `getPointCloud().points =
    X`) will NOT update existing collision checking data structures associated with
    this geometry. If you had prior data and the collision checking data structures
    were initialized, you will need to call :meth:`refreshCollider` to update them
    after modification.  

    **Collision margins**  

    Each object also has a "collision margin" which may virtually fatten the
    object, as far as proximity queries are concerned. This is useful for setting
    collision avoidance margins in motion planning. Use the
    :meth:`setCollisionMargin` and :meth:`getCollisionMargin` methods to access the
    margin. By default the margin is zero.  

    .. note::  

        The geometry margin is NOT the same thing as simulation body collision
        padding!  All proximity queries are affected by the collision padding,
        inside or outside of simulation.
     **Conversions**  

    Many geometry types can be converted to and from one another using the
    :meth:`convert` method. This can also be used to remesh TriangleMesh,
    PointCloud, ImplicitSurface, OccupancyGrid, and Heightmap objects.  

    For more information, please consult the `geometry manual
    <https://github.com/krishauser/Klampt/blob/master/Cpp/docs/Manual-
    Geometry.md>`__ .  

    C++ includes: geometry.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Geometry3D self) -> Geometry3D
        __init__(Geometry3D self, Geometry3D arg2) -> Geometry3D
        __init__(Geometry3D self, GeometricPrimitive arg2) -> Geometry3D
        __init__(Geometry3D self, ConvexHull arg2) -> Geometry3D
        __init__(Geometry3D self, TriangleMesh arg2) -> Geometry3D
        __init__(Geometry3D self, PointCloud arg2) -> Geometry3D
        __init__(Geometry3D self, ImplicitSurface arg2) -> Geometry3D
        __init__(Geometry3D self, OccupancyGrid arg2) -> Geometry3D
        __init__(Geometry3D self, Heightmap arg2) -> Geometry3D
        __init__(Geometry3D self, char const * fn) -> Geometry3D


        """
        _robotsim.Geometry3D_swiginit(self, _robotsim.new_Geometry3D(*args))
    __swig_destroy__ = _robotsim.delete_Geometry3D

    def copy(self) -> "Geometry3D":
        r"""
        copy(Geometry3D self) -> Geometry3D


        Creates a standalone geometry from this geometry.  

        """
        return _robotsim.Geometry3D_copy(self)

    def set(self, arg2: "Geometry3D") -> "void":
        r"""
        set(Geometry3D self, Geometry3D arg2)


        Copies the geometry of the argument into this geometry.  

        """
        return _robotsim.Geometry3D_set(self, arg2)

    def isStandalone(self) -> "bool":
        r"""
        isStandalone(Geometry3D self) -> bool


        Returns True if this is a standalone geometry.  

        """
        return _robotsim.Geometry3D_isStandalone(self)

    def free(self) -> "void":
        r"""
        free(Geometry3D self)


        Frees the data associated with this geometry, if standalone.  

        """
        return _robotsim.Geometry3D_free(self)

    def type(self) -> "std::string":
        r"""
        type(Geometry3D self) -> std::string


        Returns the type of geometry: GeometricPrimitive, ConvexHull, TriangleMesh,
        PointCloud, ImplicitSurface, OccupancyGrid, Heightmap, or Group.  

        """
        return _robotsim.Geometry3D_type(self)

    def empty(self) -> "bool":
        r"""
        empty(Geometry3D self) -> bool


        Returns True if this has not been set to a type (not the same as
        numElements()==0)  

        """
        return _robotsim.Geometry3D_empty(self)

    def refreshCollider(self) -> "void":
        r"""
        refreshCollider(Geometry3D self)


        Initializes / refreshes the collision data structures for the current geometry
        content.  

        """
        return _robotsim.Geometry3D_refreshCollider(self)

    def getTriangleMesh(self) -> "TriangleMesh":
        r"""
        getTriangleMesh(Geometry3D self) -> TriangleMesh


        Returns a TriangleMesh if this geometry is of type TriangleMesh.  

        """
        return _robotsim.Geometry3D_getTriangleMesh(self)

    def getPointCloud(self) -> "PointCloud":
        r"""
        getPointCloud(Geometry3D self) -> PointCloud


        Returns a PointCloud if this geometry is of type PointCloud.  

        """
        return _robotsim.Geometry3D_getPointCloud(self)

    def getGeometricPrimitive(self) -> "GeometricPrimitive":
        r"""
        getGeometricPrimitive(Geometry3D self) -> GeometricPrimitive


        Returns a GeometricPrimitive if this geometry is of type GeometricPrimitive.  

        """
        return _robotsim.Geometry3D_getGeometricPrimitive(self)

    def getConvexHull(self) -> "ConvexHull":
        r"""
        getConvexHull(Geometry3D self) -> ConvexHull


        Returns a ConvexHull if this geometry is of type ConvexHull.  

        """
        return _robotsim.Geometry3D_getConvexHull(self)

    def getImplicitSurface(self) -> "ImplicitSurface":
        r"""
        getImplicitSurface(Geometry3D self) -> ImplicitSurface


        Returns the ImplicitSurface if this geometry is of type ImplicitSurface.  

        """
        return _robotsim.Geometry3D_getImplicitSurface(self)

    def getOccupancyGrid(self) -> "OccupancyGrid":
        r"""
        getOccupancyGrid(Geometry3D self) -> OccupancyGrid


        Returns the OccupancyGrid if this geometry is of type OccupancyGrid.  

        """
        return _robotsim.Geometry3D_getOccupancyGrid(self)

    def getHeightmap(self) -> "Heightmap":
        r"""
        getHeightmap(Geometry3D self) -> Heightmap


        Returns the Heightmap if this geometry is of type Heightmap.  

        """
        return _robotsim.Geometry3D_getHeightmap(self)

    def setTriangleMesh(self, arg2: "TriangleMesh") -> "void":
        r"""
        setTriangleMesh(Geometry3D self, TriangleMesh arg2)


        Sets this Geometry3D to a TriangleMesh.  

        """
        return _robotsim.Geometry3D_setTriangleMesh(self, arg2)

    def setPointCloud(self, arg2: "PointCloud") -> "void":
        r"""
        setPointCloud(Geometry3D self, PointCloud arg2)


        Sets this Geometry3D to a PointCloud.  

        """
        return _robotsim.Geometry3D_setPointCloud(self, arg2)

    def setGeometricPrimitive(self, arg2: "GeometricPrimitive") -> "void":
        r"""
        setGeometricPrimitive(Geometry3D self, GeometricPrimitive arg2)


        Sets this Geometry3D to a GeometricPrimitive.  

        """
        return _robotsim.Geometry3D_setGeometricPrimitive(self, arg2)

    def setConvexHull(self, arg2: "ConvexHull") -> "void":
        r"""
        setConvexHull(Geometry3D self, ConvexHull arg2)


        Sets this Geometry3D to a ConvexHull.  

        """
        return _robotsim.Geometry3D_setConvexHull(self, arg2)

    def setConvexHullGroup(self, g1: "Geometry3D", g2: "Geometry3D") -> "void":
        r"""
        setConvexHullGroup(Geometry3D self, Geometry3D g1, Geometry3D g2)


        Sets this Geometry3D to be a convex hull of two geometries. Note: the relative
        transform of these two objects is frozen in place; i.e., setting the current
        transform of g2 doesn't do anything to this object.  

        """
        return _robotsim.Geometry3D_setConvexHullGroup(self, g1, g2)

    def setImplicitSurface(self, grid: "ImplicitSurface") -> "void":
        r"""
        setImplicitSurface(Geometry3D self, ImplicitSurface grid)


        Sets this Geometry3D to an ImplicitSurface.  

        """
        return _robotsim.Geometry3D_setImplicitSurface(self, grid)

    def setOccupancyGrid(self, grid: "OccupancyGrid") -> "void":
        r"""
        setOccupancyGrid(Geometry3D self, OccupancyGrid grid)


        Sets this Geometry3D to an OccupancyGrid.  

        """
        return _robotsim.Geometry3D_setOccupancyGrid(self, grid)

    def setHeightmap(self, hm: "Heightmap") -> "void":
        r"""
        setHeightmap(Geometry3D self, Heightmap hm)


        Sets this Geometry3D to a Heightmap.  

        """
        return _robotsim.Geometry3D_setHeightmap(self, hm)

    def setGroup(self) -> "void":
        r"""
        setGroup(Geometry3D self)


        Sets this Geometry3D to a group geometry. To add sub-geometries, repeatedly call
        setElement() with increasing indices.  

        """
        return _robotsim.Geometry3D_setGroup(self)

    def getElement(self, element: "int") -> "Geometry3D":
        r"""
        getElement(Geometry3D self, int element) -> Geometry3D


        Returns an element of the Geometry3D if it is a Group, TriangleMesh, or
        PointCloud. Raises an error if this is of any other type.  

        The element will be in local coordinates.  

        """
        return _robotsim.Geometry3D_getElement(self, element)

    def setElement(self, element: "int", data: "Geometry3D") -> "void":
        r"""
        setElement(Geometry3D self, int element, Geometry3D data)


        Sets an element of the Geometry3D if it is a Group, TriangleMesh, or PointCloud.
        The element will be in local coordinates. Raises an error if this is of any
        other type.  

        """
        return _robotsim.Geometry3D_setElement(self, element, data)

    def numElements(self) -> "int":
        r"""
        numElements(Geometry3D self) -> int


        Returns the number of sub-elements in this geometry.  

        """
        return _robotsim.Geometry3D_numElements(self)

    def loadFile(self, fn: "char const *") -> "bool":
        r"""
        loadFile(Geometry3D self, char const * fn) -> bool


        Loads from file. Standard mesh types, PCD files, and .geom files are supported.  

        Returns:  

            True on success, False on failure


        """
        return _robotsim.Geometry3D_loadFile(self, fn)

    def saveFile(self, fn: "char const *") -> "bool":
        r"""
        saveFile(Geometry3D self, char const * fn) -> bool


        Saves to file. Standard mesh types, PCD files, and .geom files are supported.  

        """
        return _robotsim.Geometry3D_saveFile(self, fn)

    def _setCurrentTransform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _setCurrentTransform(Geometry3D self, double const [9] R, double const [3] t)


        Sets the current transformation (not modifying the underlying data)  

        """
        return _robotsim.Geometry3D__setCurrentTransform(self, R, t)

    def getCurrentTransform(self) -> "void":
        r"""
        getCurrentTransform(Geometry3D self)


        Gets the current transformation.  

        Return type: RigidTransform  

        """
        return _robotsim.Geometry3D_getCurrentTransform(self)

    def translate(self, t: "double const [3]") -> "void":
        r"""
        translate(Geometry3D self, double const [3] t)


        Translates the geometry data. Permanently modifies the data and resets any
        collision data structures.  

        """
        return _robotsim.Geometry3D_translate(self, t)

    def scale(self, *args) -> "void":
        r"""
        scale(Geometry3D self, double s)
        scale(Geometry3D self, double sx, double sy, double sz)


        Scales the geometry data with different factors on each axis. Permanently
        modifies the data and resets any collision data structures.  

        """
        return _robotsim.Geometry3D_scale(self, *args)

    def rotate(self, R: "double const [9]") -> "void":
        r"""
        rotate(Geometry3D self, double const [9] R)


        Rotates the geometry data. Permanently modifies the data and resets any
        collision data structures.  

        """
        return _robotsim.Geometry3D_rotate(self, R)

    def _transform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _transform(Geometry3D self, double const [9] R, double const [3] t)


        Translates/rotates/scales the geometry data. Modifies the underlying data and
        resets any collision data structures.  

        """
        return _robotsim.Geometry3D__transform(self, R, t)

    def setAppearance(self, appearance: "Appearance") -> "void":
        r"""
        setAppearance(Geometry3D self, Appearance appearance)


        Attaches appearance data to the geometry. This is only supported by triangle
        meshes.  

        """
        return _robotsim.Geometry3D_setAppearance(self, appearance)

    def getAppearance(self) -> "Appearance":
        r"""
        getAppearance(Geometry3D self) -> Appearance


        Retrieves any appearance data attached to the geometry. If no appearance data is
        attached, returns an empty Appearance. This is only supported by triangle
        meshes.  

        """
        return _robotsim.Geometry3D_getAppearance(self)

    def setCollisionMargin(self, margin: "double") -> "void":
        r"""
        setCollisionMargin(Geometry3D self, double margin)


        Sets a padding around the base geometry which affects the results of proximity
        queries.  

        """
        return _robotsim.Geometry3D_setCollisionMargin(self, margin)

    def getCollisionMargin(self) -> "double":
        r"""
        getCollisionMargin(Geometry3D self) -> double


        Returns the padding around the base geometry. Default 0.  

        """
        return _robotsim.Geometry3D_getCollisionMargin(self)

    def getBB(self) -> "void":
        r"""
        getBB(Geometry3D self)


        Returns an axis-aligned bounding box of the object as a tuple (bmin,bmax).  

        Note: O(1) time, but may not be tight  

        Return type: Tuple[Vector3,Vector3]  

        """
        return _robotsim.Geometry3D_getBB(self)

    def getBBTight(self) -> "void":
        r"""
        getBBTight(Geometry3D self)


        Computes a tighter axis-aligned bounding box of the object than
        :meth:`Geometry3D.getBB`. Worst case O(n) time.  

        Return type: Tuple[Vector3,Vector3]  

        """
        return _robotsim.Geometry3D_getBBTight(self)

    def convert(self, type: "char const *", param: "double"=0) -> "Geometry3D":
        r"""
        convert(Geometry3D self, char const * type, double param=0) -> Geometry3D


        Converts a geometry to another type, if a conversion is available. The
        interpretation of param depends on the type of conversion, with 0 being a
        reasonable default.  

        Interpretations of the parameter are given as follows:  

        *   GeometricPrimitive -> anything. param determines the desired resolution,
            with default constructing a 20x20x20 grid.  
        *   ConvexHull -> TriangleMesh. param ignored.  
        *   ConvexHull -> PointCloud. param is the desired dispersion of the points.
            Equivalent to ConvexHull -> TriangleMesh -> PointCloud  
        *   ConvexHull -> ImplicitSurface. param is the grid resolution, by default
            max(bmax-bmin)/20.  
        *   ConvexHull -> OccupancyGrid. param is the grid resolution, by default
            max(bmax-bmin)/20.  
        *   TriangleMesh -> PointCloud. param is the desired dispersion of the points,
            by default set to the average triangle diameter. At least all of the mesh's
            vertices will be returned.  
        *   TriangleMesh -> ImplicitSurface. Converted using the fast marching method,
            with good results only if the mesh is watertight. param is the grid
            resolution, by default set to the average triangle diameter.  
        *   TriangleMesh -> OccupancyGrid. Converted using rasterization. param is the
            grid resolution, by default set to the average triangle diameter.  
        *   TriangleMesh -> ConvexHull. If param==0, just calculates a convex hull.
            Otherwise, uses convex decomposition with the HACD library.  
        *   TriangleMesh -> Heightmap. Converted using rasterization. param is the grid
            resolution, by default set to max(bmax-bmin) / 256.  
        *   PointCloud -> TriangleMesh. Available if the point cloud is structured.
            param is the threshold for splitting triangles by depth discontinuity. param
            is by default infinity.  
        *   PointCloud -> OccupancyGrid. param is the grid resolution, by default some
            reasonable number.  
        *   PointCloud -> ConvexHull. Converted using SOLID / Qhull.  
        *   PointCloud -> Heightmap. param is the grid resolution, by default set to
            max(bmax-bmin) / 256.  
        *   ImplicitSurface -> ConvexHull. Equivalent to ImplicitSurface -> TriangleMesh
            -> ConvexHull.  
        *   ImplicitSurface -> TriangleMesh. param determines the level set for the
            marching cubes algorithm.  
        *   ImplicitSurface -> PointCloud. param determines the level set.  
        *   ImplicitSurface -> OccupancyGrid. param ignored, result matches this
            resolution.  
        *   ImplicitSurface -> Heightmap. param ignored, result matches this resolution.  
        *   OccupancyGrid -> ConvexHull. Equivalent to OccupancyGrid -> TriangleMesh ->
            ConvexHull.  
        *   OccupancyGrid -> TriangleMesh. Creates a mesh around each block.  
        *   OccupancyGrid -> PointCloud. Outputs a point at the center of each block.  
        *   OccupancyGrid -> Heightmap. param ignored, result matches this resolution.  
        *   Heightmap -> ConvexHull. Equivalent to Heightmap -> TriangleMesh ->
            ConvexHull.  
        *   Heightmap -> TriangleMesh. param ignored, result matches this resolution.  
        *   Heightmap -> PointCloud. param ignored, result matches this resolution.  
        *   Heightmap -> ImplicitSurface. param is the resolution in the z direction, by
            default set to heightmap range / 128.  
        *   Heightmap -> OccupancyGrid. param is the resolution in the z direction, by
            default set to heightmap range / 128.  

        Available conversions are listed in the `geometry manual
        <https://github.com/krishauser/Klampt/blob/master/Cpp/docs/Manual-
        Geometry.md>`__ .  

        """
        return _robotsim.Geometry3D_convert(self, type, param)

    def contains_point(self, pt: "double const [3]") -> "bool":
        r"""
        contains_point(Geometry3D self, double const [3] pt) -> bool


        Returns true if this geometry contains the given point.  

        An approximate method is used for TriangleMesh. For PointCloud, the point is
        considered to be contained if it is one of the points in the cloud, or if points
        have a radius attribute, within the given radius.  

        """
        return _robotsim.Geometry3D_contains_point(self, pt)

    def collides(self, other: "Geometry3D") -> "bool":
        r"""
        collides(Geometry3D self, Geometry3D other) -> bool


        Returns true if this geometry collides with the other.  

        Unsupported types:  

        *   ImplicitSurface - GeometricPrimitive [aabb, box, triangle, polygon]  
        *   ImplicitSurface - ConvexHull  

        """
        return _robotsim.Geometry3D_collides(self, other)

    def collides_ext(self, other: "Geometry3D", maxContacts: "int") -> "void":
        r"""
        collides_ext(Geometry3D self, Geometry3D other, int maxContacts)


        Same as collide, but will also return the elements of each geometry that
        collide.  

        Returns: (elem1, elem2) where elem1 and elem2 are the indices of the elements
        that collide. If len(elem1) == 0, then there is no detected collision.  

        Return type: Tuple[list,list]  

        """
        return _robotsim.Geometry3D_collides_ext(self, other, maxContacts)

    def withinDistance(self, other: "Geometry3D", tol: "double") -> "bool":
        r"""
        withinDistance(Geometry3D self, Geometry3D other, double tol) -> bool


        Returns true if this geometry is within distance `tol` to other.  

        """
        return _robotsim.Geometry3D_withinDistance(self, other, tol)

    def withinDistance_ext(self, other: "Geometry3D", tol: "double", maxContacts: "int") -> "void":
        r"""
        withinDistance_ext(Geometry3D self, Geometry3D other, double tol, int maxContacts)


        Same as withinDistance, but will also return the elements of each geometry that
        are within distance tol.  

        Returns: (elem1, elem2) where elem1 and elem2 are the indices of the elements
        that are within distance tol. If len(elem1) == 0, then there is no detected
        proximity.  

        Return type: Tuple[list,list]  

        """
        return _robotsim.Geometry3D_withinDistance_ext(self, other, tol, maxContacts)

    def distance_simple(self, other: "Geometry3D", relErr: "double"=0, absErr: "double"=0) -> "double":
        r"""
        distance_simple(Geometry3D self, Geometry3D other, double relErr=0, double absErr=0) -> double


        Returns the distance from this geometry to the other. If either geometry
        contains volume information, this value may be negative to indicate penetration.
        See :meth:`Geometry3D.distance` for more information.  

        """
        return _robotsim.Geometry3D_distance_simple(self, other, relErr, absErr)

    def distance_point(self, pt: "double const [3]") -> "DistanceQueryResult":
        r"""
        distance_point(Geometry3D self, double const [3] pt) -> DistanceQueryResult


        Returns the the distance and closest point to the input point, given in world
        coordinates. An exception is raised if this operation is not supported with the
        given geometry type.  

        The return value contains the distance, closest points, and gradients if
        available.  

        For some geometry types, the signed distance is returned. The signed distance
        returns the negative penetration depth if pt is within this. The following
        geometry types return signed distances:  

        *   GeometricPrimitive  
        *   PointCloud  
        *   ImplictSurface  
        *   Heightmap (approximate, only accurate in the viewing direction)  
        *   ConvexHull  

        For other types, a signed distance will be returned if the geometry has a
        positive collision margin, and the point penetrates less than this margin.  

        """
        return _robotsim.Geometry3D_distance_point(self, pt)

    def distance_point_ext(self, pt: "double const [3]", settings: "DistanceQuerySettings") -> "DistanceQueryResult":
        r"""
        distance_point_ext(Geometry3D self, double const [3] pt, DistanceQuerySettings settings) -> DistanceQueryResult


        A customizable version of :meth:`Geometry3D.distance_point`. The settings for
        the calculation can be customized with relErr, absErr, and upperBound, e.g., to
        break if the closest points are at least upperBound distance from one another.  

        """
        return _robotsim.Geometry3D_distance_point_ext(self, pt, settings)

    def distance(self, other: "Geometry3D") -> "DistanceQueryResult":
        r"""
        distance(Geometry3D self, Geometry3D other) -> DistanceQueryResult


        Returns the the distance and closest points between the given geometries. This
        may be either the normal distance or the signed distance, depending on the
        geometry type.  

        The normal distance returns 0 if the two objects are touching
        (this.collides(other)=True).  

        The signed distance returns the negative penetration depth if the objects are
        touching. Only the following combinations of geometry types return signed
        distances:  

        *   GeometricPrimitive-GeometricPrimitive (missing some for boxes, segments, and
            tris)  
        *   GeometricPrimitive-TriangleMesh (surface only)  
        *   GeometricPrimitive-PointCloud  
        *   GeometricPrimitive-ImplicitSurface  
        *   TriangleMesh (surface only)-GeometricPrimitive  
        *   PointCloud-ImplicitSurface  
        *   PointCloud-ConvexHull  
        *   ConvexHull-ConvexHull  
        *   ConvexHull-GeometricPrimitive  

        If penetration is supported, a negative distance is returned and cp1,cp2 are the
        deepest penetrating points.  

        Unsupported types:  

        *   PointCloud-PointCloud  
        *   ImplicitSurface-TriangleMesh  
        *   ImplicitSurface-ImplicitSurface  
        *   OccupancyGrid - anything  
        *   ConvexHull - anything else besides ConvexHull  

        See the comments of the distance_point function  

        """
        return _robotsim.Geometry3D_distance(self, other)

    def distance_ext(self, other: "Geometry3D", settings: "DistanceQuerySettings") -> "DistanceQueryResult":
        r"""
        distance_ext(Geometry3D self, Geometry3D other, DistanceQuerySettings settings) -> DistanceQueryResult


        A customizable version of :meth:`Geometry3D.distance`. The settings for the
        calculation can be customized with relErr, absErr, and upperBound, e.g., to
        break if the closest points are at least upperBound distance from one another.  

        """
        return _robotsim.Geometry3D_distance_ext(self, other, settings)

    def rayCast(self, s: "double const [3]", d: "double const [3]") -> "bool":
        r"""
        rayCast(Geometry3D self, double const [3] s, double const [3] d) -> bool


        Performs a ray cast.  

        All types supported, but PointCloud needs a positive collision margin, or points
        need to have a 'radius' property assigned)  

        Returns:  

            (hit,pt) where hit is true if the ray starting at s and pointing
            in direction d hits the geometry (given in world coordinates); pt is
            the hit point, in world coordinates.
         Return type: Tuple[bool,Vector3]  

        """
        return _robotsim.Geometry3D_rayCast(self, s, d)

    def rayCast_ext(self, s: "double const [3]", d: "double const [3]") -> "int":
        r"""
        rayCast_ext(Geometry3D self, double const [3] s, double const [3] d) -> int


        A more sophisticated ray cast.  

        All types supported, but PointCloud needs a positive collision  

        margin, or points need to have a 'radius' property assigned) Returns:  

            (hit_element,pt) where hit_element is >= 0 if ray starting at
            s and pointing in direction d hits the geometry (given in world
            coordinates).  

            - hit_element is -1 if the object is not hit, otherwise it gives the
              index of the element (triangle, point, sub-object) that was hit.  
              For geometric primitives, this will be 0.
            - pt is the hit point, in world coordinates.
         Return type: Tuple[int,Vector3]  

        """
        return _robotsim.Geometry3D_rayCast_ext(self, s, d)

    def contacts(self, other: "Geometry3D", padding1: "double", padding2: "double", maxContacts: "int"=0) -> "ContactQueryResult":
        r"""
        contacts(Geometry3D self, Geometry3D other, double padding1, double padding2, int maxContacts=0) -> ContactQueryResult


        Returns the set of contact points between this and other. This set is a discrete
        representation of the region of surface overlap, which is defined as all pairs
        of points within distance self.collisionMargin + other.collisionMargin +
        padding1 + padding2.  

        Relatively few geometry types are supported.  

        For some geometry types (TriangleMesh-TriangleMesh, TriangleMesh-PointCloud,
        PointCloud-PointCloud) padding must be positive to get meaningful contact poitns
        and normals.  

        If maxContacts != 0 a clustering postprocessing step is performed.  

        """
        return _robotsim.Geometry3D_contacts(self, other, padding1, padding2, maxContacts)

    def support(self, dir: "double const [3]") -> "void":
        r"""
        support(Geometry3D self, double const [3] dir)


        Calculates the furthest point on this geometry in the direction dir.  

        Supported types:  

        *   ConvexHull  
        *   GeometricPrimitive  
        *   PointCloud  
        *   TriangleMesh  
        *   OccupancyGrid  

        Return type: Vector3  

        """
        return _robotsim.Geometry3D_support(self, dir)

    def slice(self, R: "double const [9]", t: "double const [3]", tol: "double") -> "Geometry3D":
        r"""
        slice(Geometry3D self, double const [9] R, double const [3] t, double tol) -> Geometry3D


        Calculates a 2D slice through the data. The slice is given by the local X-Y
        plane of a transform (R,T) with orientation R and translation t. The return
        Geometry's data is in the local frame of (R,t), and (R,t) is set as its current
        transform.  

        The geometry's current transform is respected.  

        O(N) time.  

        Supported types:  

        *   PointCloud. Needs tol > 0. A PointCloud is returned.  
        *   TriangleMesh. tol is ignored. A Group of GeometricPrimitives (segments) is
            returned.  

        """
        return _robotsim.Geometry3D_slice(self, R, t, tol)

    def roi(self, query: "char const *", bmin: "double const [3]", bmax: "double const [3]") -> "Geometry3D":
        r"""
        roi(Geometry3D self, char const * query, double const [3] bmin, double const [3] bmax) -> Geometry3D


        Calculates a region of interest of the data for the bounding box [bmin,bmax].
        The geometry's current transform is respected.  

        `query` can be "intersect", "touching", or "within". If "intersect",
        this tries to get a representation of the geometry intersecting the box. If
        "touching", all elements touching the box are returned. If "within", only
        elements entirely inside the box are returned.  

        `query` can also be prefaced with a '~' which indicates that the ROI should be
        inverted, i.e. select everything that does NOT intersect with a box.  

        O(N) time.  

        Supported types:  

        *   PointCloud  
        *   TriangleMesh  

        """
        return _robotsim.Geometry3D_roi(self, query, bmin, bmax)

    def merge(self, other: "Geometry3D") -> "void":
        r"""
        merge(Geometry3D self, Geometry3D other)


        Merges another geometry into this geometry. The result is stored inplace and the
        type of the result is the same as this geometry. This can be used to calculate
        the union of PointClouds, TriangleMeshes, ConvexPolytopes, and ImplicitSurfaces,
        OccupancyGrids, and Heightmaps.  

        ImplicitSurface, OccupancyGrid, and Heightmap merges preserve the domain of the
        current grid. They can also be merged with many other geometries.  

        """
        return _robotsim.Geometry3D_merge(self, other)
    world = property(_robotsim.Geometry3D_world_get, _robotsim.Geometry3D_world_set, doc=r"""world : int""")
    id = property(_robotsim.Geometry3D_id_get, _robotsim.Geometry3D_id_set, doc=r"""id : int""")
    geomPtr = property(_robotsim.Geometry3D_geomPtr_get, _robotsim.Geometry3D_geomPtr_set, doc=r"""geomPtr : p.void""")

    def transform(self, R_or_T: Union[Matrix3, RigidTransform], t: Optional[Vector3] = None):
        """
        Translates/rotates/scales the geometry data.
        Modifies the underlying data and resets any collision data structures.
                """
        if t is not None:
            self._transform(R_or_T,t)
        else:
            self._transform(*R_or_T)

    def setCurrentTransform(self, R_or_T: Union[Matrix3, RigidTransform], t: Optional[Vector3] = None):
        """
        Sets the current transformation (not modifying the underlying data)
        """
        if t is not None:
            self._setCurrentTransform(R_or_T,t)
        else:
            self._setCurrentTransform(*R_or_T)

    def __reduce__(self):
        from klampt.io import loader
        jsonobj = loader.to_json(self,'Geometry3D')
        return (loader.from_json,(jsonobj,'Geometry3D'))

    currentTransform = property(getCurrentTransform, setCurrentTransform)
    """Convenience accessor for the current transform of the geometry."""


# Register Geometry3D in _robotsim:
_robotsim.Geometry3D_swigregister(Geometry3D)

class Appearance(object):
    r"""


    Geometry appearance information. Supports vertex/edge/face rendering, per-vertex
    color, and basic color texture mapping. Uses OpenGL display lists, so repeated
    calls are fast.  

    For more complex appearances, you will need to call your own OpenGL calls.  

    Appearances can be either references to appearances of objects in the world, or
    they can be standalone.  

    Performance note: Avoid rebuilding buffers (e.g., via :meth:`refresh`) as much
    as possible.  

    C++ includes: appearance.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ALL = _robotsim.Appearance_ALL
    
    VERTICES = _robotsim.Appearance_VERTICES
    
    EDGES = _robotsim.Appearance_EDGES
    
    FACES = _robotsim.Appearance_FACES
    
    EMISSIVE = _robotsim.Appearance_EMISSIVE
    
    SPECULAR = _robotsim.Appearance_SPECULAR
    

    def __init__(self, *args):
        r"""
        __init__(Appearance self) -> Appearance
        __init__(Appearance self, Appearance app) -> Appearance


        """
        _robotsim.Appearance_swiginit(self, _robotsim.new_Appearance(*args))
    __swig_destroy__ = _robotsim.delete_Appearance

    def refresh(self, deep: "bool"=True) -> "void":
        r"""
        refresh(Appearance self, bool deep=True)


        call this to rebuild internal buffers, e.g., when the OpenGL context changes. If
        deep=True, the entire data structure will be revised. Use this for streaming
        data, for example.  

        """
        return _robotsim.Appearance_refresh(self, deep)

    def clone(self) -> "Appearance":
        r"""
        clone(Appearance self) -> Appearance


        Creates a standalone appearance from this appearance.  

        """
        return _robotsim.Appearance_clone(self)

    def set(self, arg2: "Appearance") -> "void":
        r"""
        set(Appearance self, Appearance arg2)


        Copies the appearance of the argument into this appearance.  

        """
        return _robotsim.Appearance_set(self, arg2)

    def isStandalone(self) -> "bool":
        r"""
        isStandalone(Appearance self) -> bool


        Returns true if this is a standalone appearance.  

        """
        return _robotsim.Appearance_isStandalone(self)

    def free(self) -> "void":
        r"""
        free(Appearance self)


        Frees the data associated with this appearance, if standalone.  

        """
        return _robotsim.Appearance_free(self)

    def setDraw(self, *args) -> "void":
        r"""
        setDraw(Appearance self, bool draw)
        setDraw(Appearance self, int feature, bool draw)


        Turns on/off visibility of the object or a feature.  

        If one argument is given, turns the object visibility on or off  

        If two arguments are given, turns the feature (first int argument) visibility on
        or off. feature can be ALL, VERTICES, EDGES, or FACES.  

        """
        return _robotsim.Appearance_setDraw(self, *args)

    def getDraw(self, *args) -> "bool":
        r"""
        getDraw(Appearance self) -> bool
        getDraw(Appearance self, int feature) -> bool


        Returns whether this object or feature is visible.  

        If no arguments are given, returns whether the object is visible.  

        If one int argument is given, returns whether the given feature is visible.
        feature can be ALL, VERTICES, EDGES, or FACES.  

        """
        return _robotsim.Appearance_getDraw(self, *args)

    def setColor(self, *args) -> "void":
        r"""
        setColor(Appearance self, float r, float g, float b, float a=1)
        setColor(Appearance self, int feature, float r, float g, float b, float a)


        Sets color of the object or a feature.  

        If 3 or 4 arguments are given, changes the object color.  

        If 5 arguments are given, changes the color of the given feature. feature can be
        ALL, VERTICES, EDGES, FACES, EMISSIVE, or SPECULAR.  

        """
        return _robotsim.Appearance_setColor(self, *args)

    def getColor(self, *args) -> "void":
        r"""
        getColor(Appearance self)
        getColor(Appearance self, int feature)


        Gets color of the object or a feature.  

        If 0 arguments are given, retrieves the main object color.  

        If 1 arguments are given, returns the color of the given feature. feature.
        feature can be ALL, VERTICES, EDGES, FACES, EMISSIVE, or SPECULAR.  

        Return type: Tuple[float,float,float,float]  

        """
        return _robotsim.Appearance_getColor(self, *args)

    def setColors(self, feature: "int", np_array2: "float *") -> "void":
        r"""
        setColors(Appearance self, int feature, float * np_array2)


        Sets per-element color for elements of the given feature type. Must be an mxn
        array. m is the number of features of that type, and n is either 3 or 4.  

        If n == 4, they are assumed to be rgba values, and  

        If n == 3, each row is an rgb value.  

        Only supports feature=VERTICES and feature=FACES  

        """
        return _robotsim.Appearance_setColors(self, feature, np_array2)

    def getColors(self, feature: "int") -> "void":
        r"""
        getColors(Appearance self, int feature)


        Retrieves per-element color for elements of the given feature type. If per-
        element colors are not enabled, then a 1 x 4 array is returned. Otherwise,
        returns an m x 4 array, where m is the number of featuress of that type.  

        Return type: np.ndarray  

        """
        return _robotsim.Appearance_getColors(self, feature)

    def setTintColor(self, color: "float const [4]", strength: "float") -> "void":
        r"""
        setTintColor(Appearance self, float const [4] color, float strength)


        Sets a temporary tint color that modulates the appearance of the object. This
        works with both flat colors and per-vertex / per-face colors.  

        """
        return _robotsim.Appearance_setTintColor(self, color, strength)

    def getTintColor(self) -> "void":
        r"""
        getTintColor(Appearance self)


        Retrieves the tint color.  

        Return type: Tuple[float,float,float,float]  

        """
        return _robotsim.Appearance_getTintColor(self)

    def getTintStrength(self) -> "float":
        r"""
        getTintStrength(Appearance self) -> float


        Retrieves the tint strength.  

        """
        return _robotsim.Appearance_getTintStrength(self)

    def setShininess(self, shininess: "float", strength: "float"=-1) -> "void":
        r"""
        setShininess(Appearance self, float shininess, float strength=-1)


        Sets the specular highlight shininess and strength. To turn off, use
        `setShininess(0)`. The specular strength can be set via the second argument.
        `setShininess(20,0.1)`. Note that this changes the specular color.  

        """
        return _robotsim.Appearance_setShininess(self, shininess, strength)

    def getShininess(self) -> "float":
        r"""
        getShininess(Appearance self) -> float


        Retrieves the specular highlight shininess.  

        """
        return _robotsim.Appearance_getShininess(self)

    def setElementColor(self, feature: "int", element: "int", r: "float", g: "float", b: "float", a: "float"=1) -> "void":
        r"""
        setElementColor(Appearance self, int feature, int element, float r, float g, float b, float a=1)


        Sets the per-element color for the given feature.  

        """
        return _robotsim.Appearance_setElementColor(self, feature, element, r, g, b, a)

    def getElementColor(self, feature: "int", element: "int") -> "void":
        r"""
        getElementColor(Appearance self, int feature, int element)


        Gets the per-element color for the given feature.  

        Return type: Tuple[float,float,float,float]  

        """
        return _robotsim.Appearance_getElementColor(self, feature, element)

    def setTexture1D_b(self, format: "char const *", np_array: "unsigned char *") -> "void":
        r"""
        setTexture1D_b(Appearance self, char const * format, unsigned char * np_array)


        Sets a 1D texture of the given width. Valid format strings are.  

        *   "": turn off texture mapping  
        *   l8: unsigned byte grayscale colors  

        """
        return _robotsim.Appearance_setTexture1D_b(self, format, np_array)

    def setTexture1D_i(self, format: "char const *", np_array: "unsigned int *") -> "void":
        r"""
        setTexture1D_i(Appearance self, char const * format, unsigned int * np_array)


        Sets a 1D texture of the given width. Valid format strings are.  

        *   "": turn off texture mapping  
        *   rgba8: unsigned byte RGBA colors with red in the 1st byte and alpha in the
            4th  
        *   bgra8: unsigned byte RGBA colors with blue in the 1st byte and alpha in the
            4th  

        """
        return _robotsim.Appearance_setTexture1D_i(self, format, np_array)

    def setTexture1D_channels(self, format: "char const *", np_array2: "unsigned char *") -> "void":
        r"""
        setTexture1D_channels(Appearance self, char const * format, unsigned char * np_array2)


        Sets a 1D texture of the given width, given a 2D array of channels. Valid format
        strings are.  

        *   "": turn off texture mapping  
        *   rgb8: unsigned byte RGB colors with red in the 1st column, green in the 2nd,
            blue in the 3rd  
        *   bgr8: unsigned byte RGB colors with blue in the 1st column, green in the
            2nd, green in the 3rd  
        *   rgba8: unsigned byte RGBA colors with red in the 1st column and alpha in the
            4th  
        *   bgra8: unsigned byte RGBA colors with blue in the 1st column and alpha in
            the 4th  
        *   l8: unsigned byte grayscale colors, one channel  

        """
        return _robotsim.Appearance_setTexture1D_channels(self, format, np_array2)

    def getTexture1D_format(self) -> "char const *":
        r"""
        getTexture1D_format(Appearance self) -> char const *


        Retrieves a 1D texture format, returning '' if the texture is not set.  

        """
        return _robotsim.Appearance_getTexture1D_format(self)

    def getTexture1D_channels(self) -> "void":
        r"""
        getTexture1D_channels(Appearance self)


        Retrieves a view into the 1D texture data. If the texture is not set, throws an
        exception.  

        Return type: np.ndarray  

        """
        return _robotsim.Appearance_getTexture1D_channels(self)

    def setTexture2D_b(self, format: "char const *", np_array2: "unsigned char *", topdown: "bool"=True) -> "void":
        r"""
        setTexture2D_b(Appearance self, char const * format, unsigned char * np_array2, bool topdown=True)


        Sets a 2D texture of the given width/height. See :func:`setTexture1D_b` for
        valid format strings.  

        The array is given in top to bottom order if `topdown==True`. Otherwise, it is
        given in order bottom to top.  

        """
        return _robotsim.Appearance_setTexture2D_b(self, format, np_array2, topdown)

    def setTexture2D_i(self, format: "char const *", np_array2: "unsigned int *", topdown: "bool"=True) -> "void":
        r"""
        setTexture2D_i(Appearance self, char const * format, unsigned int * np_array2, bool topdown=True)


        Sets a 2D texture of the given width/height. See :func:`setTexture1D_i` for
        valid format strings.  

        The array is given in top to bottom order if `topdown==True`. Otherwise, it is
        given in order bottom to top.  

        """
        return _robotsim.Appearance_setTexture2D_i(self, format, np_array2, topdown)

    def setTexture2D_channels(self, format: "char const *", np_array3: "unsigned char *", topdown: "bool"=True) -> "void":
        r"""
        setTexture2D_channels(Appearance self, char const * format, unsigned char * np_array3, bool topdown=True)


        Sets a 2D texture of the given width/height from a 3D array of channels. See
        :func:`setTexture1D_channels` for valid format strings.  

        The array is given in top to bottom order if `topdown==True`. Otherwise, it is
        given in order bottom to top.  

        """
        return _robotsim.Appearance_setTexture2D_channels(self, format, np_array3, topdown)

    def getTexture2D_format(self) -> "char const *":
        r"""
        getTexture2D_format(Appearance self) -> char const *


        Retrieves a 2D texture format, returning '' if the texture is not set.  

        """
        return _robotsim.Appearance_getTexture2D_format(self)

    def getTexture2D_channels(self) -> "void":
        r"""
        getTexture2D_channels(Appearance self)


        Retrieves a view into the 2D texture data. If the texture is not set, throws an
        exception.  

        Return type: np.ndarray  

        """
        return _robotsim.Appearance_getTexture2D_channels(self)

    def setTexcoords1D(self, np_array: "double *") -> "void":
        r"""
        setTexcoords1D(Appearance self, double * np_array)


        Sets per-vertex texture coordinates for a 1D texture.  

        You may also set uvs to be empty, which turns off texture mapping altogether.  

        """
        return _robotsim.Appearance_setTexcoords1D(self, np_array)

    def getTexcoords1D(self) -> "void":
        r"""
        getTexcoords1D(Appearance self)


        Gets per-vertex texture coordinates for a 1D texture. If no 1D texture is set,
        throws an exception.  

        Return type: np.ndarray  

        """
        return _robotsim.Appearance_getTexcoords1D(self)

    def setTexcoords2D(self, np_array2: "double *") -> "void":
        r"""
        setTexcoords2D(Appearance self, double * np_array2)


        Sets per-vertex texture coordinates for a 2D texture. uvs is an array of shape
        (nx2) containing U-V coordinates [[u1, v1], [u2, v2], ..., [un, vn]].  

        You may also set uvs to be empty, which turns off texture mapping altogether.  

        """
        return _robotsim.Appearance_setTexcoords2D(self, np_array2)

    def getTexcoords2D(self) -> "void":
        r"""
        getTexcoords2D(Appearance self)


        Gets per-vertex texture coordinates for a 2D texture. If no 2D texture is set,
        throws an exception.  

        Return type: np.ndarray  

        """
        return _robotsim.Appearance_getTexcoords2D(self)

    def setTexgen(self, np_array2: "double *", worldcoordinates: "bool"=False) -> "void":
        r"""
        setTexgen(Appearance self, double * np_array2, bool worldcoordinates=False)


        Sets the texture generation. The array must be size m x 4, with m in the range
        0,...,4. If worldcoordinates=true, the texture generation is performed in world
        coordinates rather than object coordinates.  

        """
        return _robotsim.Appearance_setTexgen(self, np_array2, worldcoordinates)

    def getTexgenMatrix(self) -> "void":
        r"""
        getTexgenMatrix(Appearance self)


        Retrieves the texture generation. The array will be size m x 4, with m in the
        range 0,...,4. The texture generation is performed in  

        Return type: np.ndarray  

        """
        return _robotsim.Appearance_getTexgenMatrix(self)

    def isTexgenWorld(self) -> "bool":
        r"""
        isTexgenWorld(Appearance self) -> bool


        Returns whether texture generation is performed in world coordinates.  

        """
        return _robotsim.Appearance_isTexgenWorld(self)

    def setTexWrap(self, wrap: "bool") -> "void":
        r"""
        setTexWrap(Appearance self, bool wrap)


        Sets whether textures are to wrap (default true)  

        """
        return _robotsim.Appearance_setTexWrap(self, wrap)

    def setPointSize(self, size: "float") -> "void":
        r"""
        setPointSize(Appearance self, float size)


        For point clouds, sets the point size.  

        """
        return _robotsim.Appearance_setPointSize(self, size)

    def setCreaseAngle(self, creaseAngleRads: "float") -> "void":
        r"""
        setCreaseAngle(Appearance self, float creaseAngleRads)


        For meshes, sets the crease angle. Set to 0 to disable smoothing.  

        """
        return _robotsim.Appearance_setCreaseAngle(self, creaseAngleRads)

    def setSilhouette(self, radius: "float", r: "float"=0, g: "float"=0, b: "float"=0, a: "float"=1) -> "void":
        r"""
        setSilhouette(Appearance self, float radius, float r=0, float g=0, float b=0, float a=1)


        For meshes sets a silhouette radius and color. Set the radius to 0 to disable
        silhouette drawing.  

        """
        return _robotsim.Appearance_setSilhouette(self, radius, r, g, b, a)

    def drawGL(self, *args) -> "void":
        r"""
        drawGL(Appearance self)
        drawGL(Appearance self, Geometry3D geom)


        Draws the given geometry with this appearance. NOTE: for best performance, an
        appearance should only be drawn with a single geometry. Otherwise, the OpenGL
        display lists will be completely recreated.  

        Note that the geometry's current transform is NOT respected, and this only draws
        the geometry in its local transform.  

        """
        return _robotsim.Appearance_drawGL(self, *args)

    def drawWorldGL(self, geom: "Geometry3D") -> "void":
        r"""
        drawWorldGL(Appearance self, Geometry3D geom)


        Draws the given geometry with this appearance. NOTE: for best performance, an
        appearance should only be drawn with a single geometry. Otherwise, the OpenGL
        display lists will be completely recreated.  

        Differs from drawGL in that the geometry's current transform is applied before
        drawing.  

        """
        return _robotsim.Appearance_drawWorldGL(self, geom)
    world = property(_robotsim.Appearance_world_get, _robotsim.Appearance_world_set, doc=r"""world : int""")
    id = property(_robotsim.Appearance_id_get, _robotsim.Appearance_id_set, doc=r"""id : int""")
    appearancePtr = property(_robotsim.Appearance_appearancePtr_get, _robotsim.Appearance_appearancePtr_set, doc=r"""appearancePtr : p.void""")

    def setTexture1D(self,format,array):
        """
        Sets a 1D texture.

        Args:
            format (str): describes how the array is specified.
                Valid values include:

                - '': turn off texture mapping
                - 'rgb8': unsigned byte RGB colors with red in the 1st
                    column, green in the 2nd, blue in the 3rd.
                - 'bgr8': unsigned byte RGB colors with blue in the 1st
                    column, green in the 2nd, green in the 3rd
                - 'rgba8': unsigned byte RGBA colors with red in the 1st
                    column and alpha in the 4th
                - 'bgra8': unsigned byte RGBA colors with blue in the 1st
                    column and alpha in the 4th
                - 'l8': unsigned byte grayscale colors, one channel

            array (np.ndarray): a 1D or 2D array, of size w or w x c
                where w is the width and c is the number of channels.

                Datatype is of type uint8, or for rgba8 / bgra8, can
                also be packed into uint32 elements.  In this case, the pixel
                format is 0xaarrggbb or 0xaabbggrr, respectively.
        """
        array = np.asarray(array)
        if len(array.shape) == 1:
            if array.dtype == np.uint8:
                return self.setTexture1D_b(format,array)
            else:
                return self.setTexture1D_i(format,array)
        elif len(array.shape) == 2:
            return self.setTexture1D_channels(format,array)
        else:
            raise ValueError("Can only pass a 1D or 2D array to setTexture1D")

    def setTexture2D(self,format,array):
        """
        Sets a 2D texture.

        Args:
            format (str): describes how the array is specified.
                Valid values include:

                - '': turn off texture mapping
                - 'rgb8': unsigned byte RGB colors with red in the 1st
                    column, green in the 2nd, blue in the 3rd.
                - 'bgr8': unsigned byte RGB colors with blue in the 1st
                    column, green in the 2nd, green in the 3rd
                - 'rgba8': unsigned byte RGBA colors with red in the 1st
                    column and alpha in the 4th
                - 'bgra8': unsigned byte RGBA colors with blue in the 1st
                    column and alpha in the 4th
                - 'l8': unsigned byte grayscale colors, one channel

            array (np.ndarray): a 2D or 3D array, of size h x w or h x w x c
                where h is the height, w is the width, and c is the number of
                channels.

                Datatype is of type uint8, or for rgba8 / bgra8, can
                also be packed into uint32 elements.  In this case, the pixel
                format is 0xaarrggbb or 0xaabbggrr, respectively.
        """

        array = np.asarray(array)
        if len(array.shape) == 2:
            if array.dtype == np.uint8:
                return self.setTexture2D_b(format,array)
            else:
                return self.setTexture2D_i(format,array)
        elif len(array.shape) == 3:
            return self.setTexture2D_channels(format,array)
        else:
            raise ValueError("Can only pass a 2D or 3D array to setTexture2D")

    def setTexcoords(self,array):
        """
        Sets texture coordinates for the mesh.

        Args:
            array (np.ndarray): a 1D or 2D array, of size N or Nx2, where N is
                the number of vertices in the mesh.
        """
        array = np.asarray(array)
        if len(array.shape) == 1:
            return self.setTexcoords1D(array)
        elif len(array.shape) == 2:
            return self.setTexcoords2D(array)
        else:
            raise ValueError("Must provide either a 1D or 2D array")


# Register Appearance in _robotsim:
_robotsim.Appearance_swigregister(Appearance)

class Widget(object):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(Widget self) -> Widget


        """
        _robotsim.Widget_swiginit(self, _robotsim.new_Widget())
    __swig_destroy__ = _robotsim.delete_Widget

    def hover(self, x: "int", y: "int", viewport: "Viewport") -> "bool":
        r"""
        hover(Widget self, int x, int y, Viewport viewport) -> bool


        """
        return _robotsim.Widget_hover(self, x, y, viewport)

    def beginDrag(self, x: "int", y: "int", viewport: "Viewport") -> "bool":
        r"""
        beginDrag(Widget self, int x, int y, Viewport viewport) -> bool


        """
        return _robotsim.Widget_beginDrag(self, x, y, viewport)

    def drag(self, dx: "int", dy: "int", viewport: "Viewport") -> "void":
        r"""
        drag(Widget self, int dx, int dy, Viewport viewport)


        """
        return _robotsim.Widget_drag(self, dx, dy, viewport)

    def endDrag(self) -> "void":
        r"""
        endDrag(Widget self)


        """
        return _robotsim.Widget_endDrag(self)

    def keypress(self, c: "char") -> "void":
        r"""
        keypress(Widget self, char c)


        """
        return _robotsim.Widget_keypress(self, c)

    def drawGL(self, viewport: "Viewport") -> "void":
        r"""
        drawGL(Widget self, Viewport viewport)


        """
        return _robotsim.Widget_drawGL(self, viewport)

    def idle(self) -> "void":
        r"""
        idle(Widget self)


        """
        return _robotsim.Widget_idle(self)

    def wantsRedraw(self) -> "bool":
        r"""
        wantsRedraw(Widget self) -> bool


        """
        return _robotsim.Widget_wantsRedraw(self)

    def hasHighlight(self) -> "bool":
        r"""
        hasHighlight(Widget self) -> bool


        """
        return _robotsim.Widget_hasHighlight(self)

    def hasFocus(self) -> "bool":
        r"""
        hasFocus(Widget self) -> bool


        """
        return _robotsim.Widget_hasFocus(self)
    index = property(_robotsim.Widget_index_get, _robotsim.Widget_index_set, doc=r"""index : int""")

# Register Widget in _robotsim:
_robotsim.Widget_swigregister(Widget)

class WidgetSet(Widget):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(WidgetSet self) -> WidgetSet


        """
        _robotsim.WidgetSet_swiginit(self, _robotsim.new_WidgetSet())

    def add(self, subwidget: "Widget") -> "void":
        r"""
        add(WidgetSet self, Widget subwidget)


        """
        return _robotsim.WidgetSet_add(self, subwidget)

    def remove(self, subwidget: "Widget") -> "void":
        r"""
        remove(WidgetSet self, Widget subwidget)


        """
        return _robotsim.WidgetSet_remove(self, subwidget)

    def enable(self, subwidget: "Widget", enabled: "bool") -> "void":
        r"""
        enable(WidgetSet self, Widget subwidget, bool enabled)


        """
        return _robotsim.WidgetSet_enable(self, subwidget, enabled)
    __swig_destroy__ = _robotsim.delete_WidgetSet

# Register WidgetSet in _robotsim:
_robotsim.WidgetSet_swigregister(WidgetSet)

class PointPoser(Widget):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(PointPoser self) -> PointPoser


        """
        _robotsim.PointPoser_swiginit(self, _robotsim.new_PointPoser())

    def set(self, t: "double const [3]") -> "void":
        r"""
        set(PointPoser self, double const [3] t)


        """
        return _robotsim.PointPoser_set(self, t)

    def get(self) -> "void":
        r"""
        get(PointPoser self)


        """
        return _robotsim.PointPoser_get(self)

    def setAxes(self, R: "double const [9]") -> "void":
        r"""
        setAxes(PointPoser self, double const [9] R)


        Sets the reference axes (by default aligned to x,y,z)  

        """
        return _robotsim.PointPoser_setAxes(self, R)

    def enableAxes(self, x: "bool", y: "bool", z: "bool") -> "void":
        r"""
        enableAxes(PointPoser self, bool x, bool y, bool z)


        """
        return _robotsim.PointPoser_enableAxes(self, x, y, z)
    __swig_destroy__ = _robotsim.delete_PointPoser

# Register PointPoser in _robotsim:
_robotsim.PointPoser_swigregister(PointPoser)

class TransformPoser(Widget):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(TransformPoser self) -> TransformPoser


        """
        _robotsim.TransformPoser_swiginit(self, _robotsim.new_TransformPoser())

    def set(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        set(TransformPoser self, double const [9] R, double const [3] t)


        """
        return _robotsim.TransformPoser_set(self, R, t)

    def get(self) -> "void":
        r"""
        get(TransformPoser self)


        """
        return _robotsim.TransformPoser_get(self)

    def enableTranslation(self, arg2: "bool") -> "void":
        r"""
        enableTranslation(TransformPoser self, bool arg2)


        """
        return _robotsim.TransformPoser_enableTranslation(self, arg2)

    def enableRotation(self, arg2: "bool") -> "void":
        r"""
        enableRotation(TransformPoser self, bool arg2)


        """
        return _robotsim.TransformPoser_enableRotation(self, arg2)

    def enableTranslationAxes(self, x: "bool", y: "bool", z: "bool") -> "void":
        r"""
        enableTranslationAxes(TransformPoser self, bool x, bool y, bool z)


        """
        return _robotsim.TransformPoser_enableTranslationAxes(self, x, y, z)

    def enableRotationAxes(self, x: "bool", y: "bool", z: "bool") -> "void":
        r"""
        enableRotationAxes(TransformPoser self, bool x, bool y, bool z)


        """
        return _robotsim.TransformPoser_enableRotationAxes(self, x, y, z)
    __swig_destroy__ = _robotsim.delete_TransformPoser

# Register TransformPoser in _robotsim:
_robotsim.TransformPoser_swigregister(TransformPoser)

class ObjectPoser(Widget):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, object: "RigidObjectModel"):
        r"""
        __init__(ObjectPoser self, RigidObjectModel object) -> ObjectPoser


        """
        _robotsim.ObjectPoser_swiginit(self, _robotsim.new_ObjectPoser(object))

    def set(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        set(ObjectPoser self, double const [9] R, double const [3] t)


        """
        return _robotsim.ObjectPoser_set(self, R, t)

    def get(self) -> "void":
        r"""
        get(ObjectPoser self)


        """
        return _robotsim.ObjectPoser_get(self)
    __swig_destroy__ = _robotsim.delete_ObjectPoser

# Register ObjectPoser in _robotsim:
_robotsim.ObjectPoser_swigregister(ObjectPoser)

class RobotPoser(Widget):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, robot: "RobotModel"):
        r"""
        __init__(RobotPoser self, RobotModel robot) -> RobotPoser


        """
        _robotsim.RobotPoser_swiginit(self, _robotsim.new_RobotPoser(robot))

    def setActiveDofs(self, dofs: "intVector") -> "void":
        r"""
        setActiveDofs(RobotPoser self, intVector dofs)


        """
        return _robotsim.RobotPoser_setActiveDofs(self, dofs)

    def set(self, q: "doubleVector") -> "void":
        r"""
        set(RobotPoser self, doubleVector q)


        """
        return _robotsim.RobotPoser_set(self, q)

    def get(self) -> "void":
        r"""
        get(RobotPoser self)


        """
        return _robotsim.RobotPoser_get(self)

    def getConditioned(self, qref: "doubleVector") -> "void":
        r"""
        getConditioned(RobotPoser self, doubleVector qref)


        """
        return _robotsim.RobotPoser_getConditioned(self, qref)

    def addIKConstraint(self, obj: "IKObjective") -> "void":
        r"""
        addIKConstraint(RobotPoser self, IKObjective obj)


        """
        return _robotsim.RobotPoser_addIKConstraint(self, obj)

    def clearIKConstraints(self) -> "void":
        r"""
        clearIKConstraints(RobotPoser self)


        """
        return _robotsim.RobotPoser_clearIKConstraints(self)
    __swig_destroy__ = _robotsim.delete_RobotPoser

# Register RobotPoser in _robotsim:
_robotsim.RobotPoser_swigregister(RobotPoser)

class AABBPoser(Widget):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(AABBPoser self) -> AABBPoser


        """
        _robotsim.AABBPoser_swiginit(self, _robotsim.new_AABBPoser())

    def set(self, bmin: "double const [3]", bmax: "double const [3]") -> "void":
        r"""
        set(AABBPoser self, double const [3] bmin, double const [3] bmax)


        """
        return _robotsim.AABBPoser_set(self, bmin, bmax)

    def setFrame(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        setFrame(AABBPoser self, double const [9] R, double const [3] t)


        """
        return _robotsim.AABBPoser_setFrame(self, R, t)

    def get(self) -> "void":
        r"""
        get(AABBPoser self)


        """
        return _robotsim.AABBPoser_get(self)
    __swig_destroy__ = _robotsim.delete_AABBPoser

# Register AABBPoser in _robotsim:
_robotsim.AABBPoser_swigregister(AABBPoser)

class BoxPoser(Widget):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(BoxPoser self) -> BoxPoser


        """
        _robotsim.BoxPoser_swiginit(self, _robotsim.new_BoxPoser())

    def set(self, R: "double const [9]", t: "double const [3]", dims: "double const [3]") -> "void":
        r"""
        set(BoxPoser self, double const [9] R, double const [3] t, double const [3] dims)


        """
        return _robotsim.BoxPoser_set(self, R, t, dims)

    def setTransform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        setTransform(BoxPoser self, double const [9] R, double const [3] t)


        """
        return _robotsim.BoxPoser_setTransform(self, R, t)

    def setDims(self, dims: "double const [3]") -> "void":
        r"""
        setDims(BoxPoser self, double const [3] dims)


        """
        return _robotsim.BoxPoser_setDims(self, dims)

    def getTransform(self) -> "void":
        r"""
        getTransform(BoxPoser self)


        """
        return _robotsim.BoxPoser_getTransform(self)

    def getDims(self) -> "void":
        r"""
        getDims(BoxPoser self)


        """
        return _robotsim.BoxPoser_getDims(self)
    __swig_destroy__ = _robotsim.delete_BoxPoser

# Register BoxPoser in _robotsim:
_robotsim.BoxPoser_swigregister(BoxPoser)

class SpherePoser(Widget):
    r"""


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(SpherePoser self) -> SpherePoser


        """
        _robotsim.SpherePoser_swiginit(self, _robotsim.new_SpherePoser())

    def set(self, cr: "double const [4]") -> "void":
        r"""
        set(SpherePoser self, double const [4] cr)


        """
        return _robotsim.SpherePoser_set(self, cr)

    def get(self) -> "void":
        r"""
        get(SpherePoser self)


        """
        return _robotsim.SpherePoser_get(self)
    __swig_destroy__ = _robotsim.delete_SpherePoser

# Register SpherePoser in _robotsim:
_robotsim.SpherePoser_swigregister(SpherePoser)

class Viewport(object):
    r"""


    A class that represents an idealized pinhole camera.  

    Duplicates the functioning of KrisLibrary/Camera/Viewport.  

    C++ includes: viewport.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(Viewport self) -> Viewport


        """
        _robotsim.Viewport_swiginit(self, _robotsim.new_Viewport())

    def fromJson(self, str: "std::string const &") -> "bool":
        r"""
        fromJson(Viewport self, std::string const & str) -> bool


        """
        return _robotsim.Viewport_fromJson(self, str)

    def toJson(self) -> "std::string":
        r"""
        toJson(Viewport self) -> std::string


        """
        return _robotsim.Viewport_toJson(self)

    def fromText(self, str: "std::string const &") -> "bool":
        r"""
        fromText(Viewport self, std::string const & str) -> bool


        """
        return _robotsim.Viewport_fromText(self, str)

    def toText(self) -> "std::string":
        r"""
        toText(Viewport self) -> std::string


        """
        return _robotsim.Viewport_toText(self)

    def resize(self, w: "int", h: "int") -> "void":
        r"""
        resize(Viewport self, int w, int h)


        Resizes the viewport, keeping the same field of view and relative position of
        the focal point.  

        """
        return _robotsim.Viewport_resize(self, w, h)

    def setFOV(self, xfov: "double", yfov: "double"=-1) -> "void":
        r"""
        setFOV(Viewport self, double xfov, double yfov=-1)


        Sets the horizontal and optionally the vertical FOV. If yfov < 0, square pixels
        will be assumed.  

        """
        return _robotsim.Viewport_setFOV(self, xfov, yfov)

    def getFOV(self) -> "double":
        r"""
        getFOV(Viewport self) -> double


        Returns the horizontal FOV.  

        """
        return _robotsim.Viewport_getFOV(self)

    def getVFOV(self) -> "double":
        r"""
        getVFOV(Viewport self) -> double


        Returns the vertical FOV.  

        """
        return _robotsim.Viewport_getVFOV(self)

    def _setPose(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _setPose(Viewport self, double const [9] R, double const [3] t)


        Sets the pose of the camera.  

        """
        return _robotsim.Viewport__setPose(self, R, t)

    def getPose(self) -> "void":
        r"""
        getPose(Viewport self)


        Gets the pose of the camera.  

        Return type: RigidTransform  

        """
        return _robotsim.Viewport_getPose(self)

    def viewRectangle(self, depth: "double") -> "void":
        r"""
        viewRectangle(Viewport self, double depth)


        Gets the viewing rectangle (xmin,ymin,xmax,ymax) at a given depth.  

        Return type: Tuple[float,float,float,float]  

        """
        return _robotsim.Viewport_viewRectangle(self, depth)

    def project(self, pt: "double const [3]") -> "void":
        r"""
        project(Viewport self, double const [3] pt)


        Projects into image coordinates.  

        Return type: Vector3  

        """
        return _robotsim.Viewport_project(self, pt)

    def clickSource(self, x: "double", y: "double") -> "void":
        r"""
        clickSource(Viewport self, double x, double y)


        Provides the source of a ray for an image coordinate (x,y)  

        Return type: Vector3  

        """
        return _robotsim.Viewport_clickSource(self, x, y)

    def clickDirection(self, x: "double", y: "double") -> "void":
        r"""
        clickDirection(Viewport self, double x, double y)


        Provides the direction of a ray for an image coordinate (x,y)  

        Return type: Vector  

        """
        return _robotsim.Viewport_clickDirection(self, x, y)
    perspective = property(_robotsim.Viewport_perspective_get, _robotsim.Viewport_perspective_set, doc=r"""perspective : bool""")
    x = property(_robotsim.Viewport_x_get, _robotsim.Viewport_x_set, doc=r"""x : int""")
    y = property(_robotsim.Viewport_y_get, _robotsim.Viewport_y_set, doc=r"""y : int""")
    w = property(_robotsim.Viewport_w_get, _robotsim.Viewport_w_set, doc=r"""w : int""")
    h = property(_robotsim.Viewport_h_get, _robotsim.Viewport_h_set, doc=r"""h : int""")
    n = property(_robotsim.Viewport_n_get, _robotsim.Viewport_n_set, doc=r"""n : double""")
    f = property(_robotsim.Viewport_f_get, _robotsim.Viewport_f_set, doc=r"""f : double""")
    fx = property(_robotsim.Viewport_fx_get, _robotsim.Viewport_fx_set, doc=r"""fx : double""")
    fy = property(_robotsim.Viewport_fy_get, _robotsim.Viewport_fy_set, doc=r"""fy : double""")
    cx = property(_robotsim.Viewport_cx_get, _robotsim.Viewport_cx_set, doc=r"""cx : double""")
    cy = property(_robotsim.Viewport_cy_get, _robotsim.Viewport_cy_set, doc=r"""cy : double""")
    xform = property(_robotsim.Viewport_xform_get, _robotsim.Viewport_xform_set, doc=r"""xform : std::vector<(double,std::allocator<(double)>)>""")
    ori = property(_robotsim.Viewport_ori_get, _robotsim.Viewport_ori_set, doc=r"""ori : std::string""")

    def setClippingPlanes(self, cp):
        """
        @deprecated

        Provided for backwards compatibility.
        """
        import warnings
        warnings.warn("Viewport. clippingPlanes will be deprecated in favor of n,f attributes in a future version of Klampt",DeprecationWarning)
        self.n, self.f = cp

    def getClippingPlanes(self):
        """
        @deprecated

        Provided for backwards compatibility.
        """
        import warnings
        warnings.warn("Viewport. clippingPlanes will be deprecated in favor of n,f attributes in a future version of Klampt",DeprecationWarning)
        return (self.n, self.f)

    def setPose(self, R_or_T: Union[Matrix3, RigidTransform], t: Optional[Vector3] = None):
        """Sets the pose of the camera."""
        if t is not None:
            self._setPose(R_or_T,t)
        else:
            self._setPose(*R_or_T)

    fov = property(getFOV, setFOV)
    """Convenience accessor for the field of view, in radians."""

    pose = property(getPose, setPose)
    """The camera pose, as a rigid transform (R,t) in world coordinates."""

    clippingPlanes = property(getClippingPlanes, setClippingPlanes)
    """Klampt 0.9 backwards compatibility accessor for the (n, f) pair."""

    __swig_destroy__ = _robotsim.delete_Viewport

# Register Viewport in _robotsim:
_robotsim.Viewport_swigregister(Viewport)

class Mass(object):
    r"""


    Stores mass information for a rigid body or robot link.  

    .. note::  

        Recommended to use the set/get functions rather than changing the members
        directly due to strangeness in SWIG's handling of vectors.  

    .. note:  

        The inertia matrix is specified in the local frame of the object
        and centered at the center of mass.  

    Attributes:  

        mass (float): the actual mass (typically in kg)
        com (list of 3 floats): the center of mass position, in
            local coordinates.
        inertia (list of 3 floats or 9 floats): the inertia matrix
            in local coordinates.  If 3 floats, this is a diagonal matrix.
            If 9 floats, this gives all entries of the 3x3 inertia matrix
            (in column major or row major order, it doesn't matter since
            inertia matrices are symmetric)


    C++ includes: robotmodel.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(Mass self) -> Mass


        """
        _robotsim.Mass_swiginit(self, _robotsim.new_Mass())

    def setMass(self, _mass: "double") -> "void":
        r"""
        setMass(Mass self, double _mass)


        """
        return _robotsim.Mass_setMass(self, _mass)

    def getMass(self) -> "double":
        r"""
        getMass(Mass self) -> double


        """
        return _robotsim.Mass_getMass(self)

    def setCom(self, _com: "doubleVector") -> "void":
        r"""
        setCom(Mass self, doubleVector _com)


        """
        return _robotsim.Mass_setCom(self, _com)

    def getCom(self) -> "void":
        r"""
        getCom(Mass self)


        Returns the COM.  

        Return type: Vector3  

        """
        return _robotsim.Mass_getCom(self)

    def setInertia(self, _inertia: "doubleVector") -> "void":
        r"""
        setInertia(Mass self, doubleVector _inertia)


        Sets an inertia matrix.  

        """
        return _robotsim.Mass_setInertia(self, _inertia)

    def getInertia(self) -> "void":
        r"""
        getInertia(Mass self)


        Returns the inertia matrix as a list of 3 floats or 9 floats.  

        Return type: Vector  

        """
        return _robotsim.Mass_getInertia(self)

    def estimate(self, g: "Geometry3D", mass: "double", surfaceFraction: "double"=0) -> "void":
        r"""
        estimate(Mass self, Geometry3D g, double mass, double surfaceFraction=0)


        Estimates the com and inertia of a geometry, with a given total mass.  

        For TriangleMesh types, surfaceFraction dictates how much of the object's mass
        is concentrated at the surface rather than the interior.  

        """
        return _robotsim.Mass_estimate(self, g, mass, surfaceFraction)
    mass = property(_robotsim.Mass_mass_get, _robotsim.Mass_mass_set, doc=r"""mass : double""")
    com = property(_robotsim.Mass_com_get, _robotsim.Mass_com_set, doc=r"""com : std::vector<(double,std::allocator<(double)>)>""")
    inertia = property(_robotsim.Mass_inertia_get, _robotsim.Mass_inertia_set, doc=r"""inertia : std::vector<(double,std::allocator<(double)>)>""")

    com = property(getCom, setCom)
    """The object's center of mass in local coordinates (3-list)"""
    inertia = property(getInertia, setInertia)
    """The object's inertia in local coordinates (9-list)"""

    __swig_destroy__ = _robotsim.delete_Mass

# Register Mass in _robotsim:
_robotsim.Mass_swigregister(Mass)

class ContactParameters(object):
    r"""


    Stores contact parameters for an entity. Currently only used for simulation, but
    could be used for contact mechanics in the future.  

    Attributes:  

        kFriction (float): The coefficient of (Coulomb) friction, in range
            [0,inf).
        kRestitution (float): The coefficient of restitution, in range [0,1].
        kStiffness (float): The stiffness of the material, in range (0,inf)
            (default inf, perfectly rigid).
        kDamping (float): The damping of the material, in range (0,inf)
            (default inf, perfectly rigid).


    C++ includes: robotmodel.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(ContactParameters self) -> ContactParameters


        """
        _robotsim.ContactParameters_swiginit(self, _robotsim.new_ContactParameters())
    kFriction = property(_robotsim.ContactParameters_kFriction_get, _robotsim.ContactParameters_kFriction_set, doc=r"""kFriction : double""")
    kRestitution = property(_robotsim.ContactParameters_kRestitution_get, _robotsim.ContactParameters_kRestitution_set, doc=r"""kRestitution : double""")
    kStiffness = property(_robotsim.ContactParameters_kStiffness_get, _robotsim.ContactParameters_kStiffness_set, doc=r"""kStiffness : double""")
    kDamping = property(_robotsim.ContactParameters_kDamping_get, _robotsim.ContactParameters_kDamping_set, doc=r"""kDamping : double""")
    __swig_destroy__ = _robotsim.delete_ContactParameters

# Register ContactParameters in _robotsim:
_robotsim.ContactParameters_swigregister(ContactParameters)

class RobotModelLink(object):
    r"""


    A reference to a link of a RobotModel.  

    The link stores many mostly-constant items (id, name, parent, geometry,
    appearance, mass, joint axes). There are two exceptions:  

    *   the link's current transform, which is affected by the RobotModel's current
        configuration, i.e., the last :meth:`RobotModel.setConfig` call.  
    *   The various Jacobians of points on the link, accessed by
        :meth:`RobotModelLink.getJacobian` ,
        :meth:`RobotModelLink.getPositionJacobian` , and
        :meth:`RobotModelLink.getOrientationJacobian` , which are configuration
        dependent.  

    A RobotModelLink is not created by hand, but instead accessed using
    :meth:`RobotModel.link` (index or name).  

    C++ includes: robotmodel.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(RobotModelLink self) -> RobotModelLink


        """
        _robotsim.RobotModelLink_swiginit(self, _robotsim.new_RobotModelLink())

    def getID(self) -> "int":
        r"""
        getID(RobotModelLink self) -> int


        Returns the ID of the robot link in its world.  

        .. note::  

            The world ID is not the same as the link's index, retrieved by
            getIndex.


        """
        return _robotsim.RobotModelLink_getID(self)

    def getName(self) -> "char const *":
        r"""
        getName(RobotModelLink self) -> char const *


        Returns the name of the robot link.  

        """
        return _robotsim.RobotModelLink_getName(self)

    def setName(self, name: "char const *") -> "void":
        r"""
        setName(RobotModelLink self, char const * name)


        Sets the name of the robot link.  

        """
        return _robotsim.RobotModelLink_setName(self, name)

    def robot(self) -> "RobotModel":
        r"""
        robot(RobotModelLink self) -> RobotModel


        Returns a reference to the link's robot.  

        """
        return _robotsim.RobotModelLink_robot(self)

    def getIndex(self) -> "int":
        r"""
        getIndex(RobotModelLink self) -> int


        Returns the index of the link (on its robot).  

        """
        return _robotsim.RobotModelLink_getIndex(self)

    def getParentIndex(self) -> "int":
        r"""
        getParentIndex(RobotModelLink self) -> int


        Returns the index of the link's parent (on its robot). -1 indicates no parent.  

        """
        return _robotsim.RobotModelLink_getParentIndex(self)

    def setParentIndex(self, p: "int") -> "void":
        r"""
        setParentIndex(RobotModelLink self, int p)


        Sets the index of the link's parent (on its robot).  

        """
        return _robotsim.RobotModelLink_setParentIndex(self, p)

    def getParentLink(self) -> "RobotModelLink":
        r"""
        getParentLink(RobotModelLink self) -> RobotModelLink


        Returns a reference to the link's parent, or a NULL link if it has no parent.  

        """
        return _robotsim.RobotModelLink_getParentLink(self)

    def setParentLink(self, l: "RobotModelLink") -> "void":
        r"""
        setParentLink(RobotModelLink self, RobotModelLink l)


        Sets the link's parent (must be on the same robot).  

        """
        return _robotsim.RobotModelLink_setParentLink(self, l)

    def geometry(self) -> "Geometry3D":
        r"""
        geometry(RobotModelLink self) -> Geometry3D


        Returns a reference to the link's geometry.  

        """
        return _robotsim.RobotModelLink_geometry(self)

    def appearance(self) -> "Appearance":
        r"""
        appearance(RobotModelLink self) -> Appearance


        Returns a reference to the link's appearance.  

        """
        return _robotsim.RobotModelLink_appearance(self)

    def getMass(self) -> "Mass":
        r"""
        getMass(RobotModelLink self) -> Mass


        Returns the inertial properties of the link.  

        .. note::  

            To change the mass properties, you should call ``m=link.getMass()``,
            change the desired properties in m, and then ``link.setMass(m)``
         .. note::  

             The Mass object considers the inertia matrix origin as the link
             frame, not about the COM.


        """
        return _robotsim.RobotModelLink_getMass(self)

    def setMass(self, mass: "Mass") -> "void":
        r"""
        setMass(RobotModelLink self, Mass mass)


        Sets the inertial proerties of the link. (Note that the Mass is given with
        origin at the link frame, not about the COM.)  

        """
        return _robotsim.RobotModelLink_setMass(self, mass)

    def getParentTransform(self) -> "void":
        r"""
        getParentTransform(RobotModelLink self)


        Gets the transformation (R,t) to the parent link.  

        Returns:  

            se3 object: a pair (R,t), with R a 9-list and t a 3-list of floats,
            giving the local transform from this link to its parent, in the
            reference (zero) configuration.
         Return type: RigidTransform  

        """
        return _robotsim.RobotModelLink_getParentTransform(self)

    def _setParentTransform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _setParentTransform(RobotModelLink self, double const [9] R, double const [3] t)


        Sets transformation (R,t) to the parent link.  

        """
        return _robotsim.RobotModelLink__setParentTransform(self, R, t)

    def getAxis(self) -> "void":
        r"""
        getAxis(RobotModelLink self)


        Gets the local rotational / translational axis.  

        Return type: Vector3  

        """
        return _robotsim.RobotModelLink_getAxis(self)

    def setAxis(self, axis: "double const [3]") -> "void":
        r"""
        setAxis(RobotModelLink self, double const [3] axis)


        Sets the local rotational / translational axis.  

        """
        return _robotsim.RobotModelLink_setAxis(self, axis)

    def isPrismatic(self) -> "bool":
        r"""
        isPrismatic(RobotModelLink self) -> bool


        Returns whether the joint is prismatic.  

        """
        return _robotsim.RobotModelLink_isPrismatic(self)

    def isRevolute(self) -> "bool":
        r"""
        isRevolute(RobotModelLink self) -> bool


        Returns whether the joint is revolute.  

        """
        return _robotsim.RobotModelLink_isRevolute(self)

    def setPrismatic(self, prismatic: "bool") -> "void":
        r"""
        setPrismatic(RobotModelLink self, bool prismatic)


        Changes a link from revolute to prismatic or vice versa.  

        """
        return _robotsim.RobotModelLink_setPrismatic(self, prismatic)

    def getWorldPosition(self, plocal: "double const [3]") -> "void":
        r"""
        getWorldPosition(RobotModelLink self, double const [3] plocal)


        Converts point from local to world coordinates.  

        Returns:  

            list of 3 floats: the world coordinates of the local point plocal
         Return type: Vector3  

        """
        return _robotsim.RobotModelLink_getWorldPosition(self, plocal)

    def getWorldDirection(self, vlocal: "double const [3]") -> "void":
        r"""
        getWorldDirection(RobotModelLink self, double const [3] vlocal)


        Converts direction from local to world coordinates.  

        Returns:  

            list of 3 floats: the world coordinates of the local direction
            vlocal
         Return type: Vector3  

        """
        return _robotsim.RobotModelLink_getWorldDirection(self, vlocal)

    def getLocalPosition(self, pworld: "double const [3]") -> "void":
        r"""
        getLocalPosition(RobotModelLink self, double const [3] pworld)


        Converts point from world to local coordinates.  

        Returns:  

            list of 3 floats: the local coordinates of the world point pworld
         Return type: Vector3  

        """
        return _robotsim.RobotModelLink_getLocalPosition(self, pworld)

    def getLocalDirection(self, vworld: "double const [3]") -> "void":
        r"""
        getLocalDirection(RobotModelLink self, double const [3] vworld)


        Converts direction from world to local coordinates.  

        Returns:  

            list of 3 floats: the local coordinates of the world direction
            vworld
         Return type: Vector3  

        """
        return _robotsim.RobotModelLink_getLocalDirection(self, vworld)

    def getTransform(self) -> "void":
        r"""
        getTransform(RobotModelLink self)


        Gets the link's current transformation (R,t) to the world frame.  

        Returns:  

            se3 object: a pair (R,t), with R a 9-list and t a 3-list of floats.
         Return type: RigidTransform  

        """
        return _robotsim.RobotModelLink_getTransform(self)

    def _setTransform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _setTransform(RobotModelLink self, double const [9] R, double const [3] t)


        Sets the link's current transformation (R,t) to the world frame.  

        .. note::  

            This does NOT perform inverse kinematics.  The transform is
            overwritten when the robot's setConfig() method is called.


        """
        return _robotsim.RobotModelLink__setTransform(self, R, t)

    def getVelocity(self) -> "void":
        r"""
        getVelocity(RobotModelLink self)


        Computes the velocity of the link's origin given the robot's current joint
        configuration and velocities. Equivalent to getPointVelocity([0,0,0]).  

        Returns:  

            list of 3 floats: the current velocity of the link's origin, in
            world coordinates
         Return type: Vector3  

        """
        return _robotsim.RobotModelLink_getVelocity(self)

    def getAngularVelocity(self) -> "void":
        r"""
        getAngularVelocity(RobotModelLink self)


        Computes the angular velocity of the link given the robot's current joint
        configuration and velocities.  

        Returns:  

            list of 3 floats: the current angular velocity of the link, in world
            coordinates
         Return type: Vector3  

        """
        return _robotsim.RobotModelLink_getAngularVelocity(self)

    def getPointVelocity(self, plocal: "double const [3]") -> "void":
        r"""
        getPointVelocity(RobotModelLink self, double const [3] plocal)


        Computes the world velocity of a point attached to the link, given the robot's
        current joint configuration and velocities.  

        Returns:  

            list of 3 floats: the current velocity of the point, in
            world coordinates.
         Return type: Vector3  

        """
        return _robotsim.RobotModelLink_getPointVelocity(self, plocal)

    def getJacobian(self, plocal: "double const [3]") -> "void":
        r"""
        getJacobian(RobotModelLink self, double const [3] plocal)


        Computes the total jacobian of a point on this link w.r.t. the robot's
        configuration q.  

        The orientation jacobian is given in the first 3 rows, and is stacked on the
        position jacobian, which is given in the last 3 rows.  

        Returns:  

            ndarray: the 6xn total Jacobian matrix of the
            point given by local coordinates plocal.  
         Return type: np.ndarray  

        """
        return _robotsim.RobotModelLink_getJacobian(self, plocal)

    def getPositionJacobian(self, plocal: "double const [3]") -> "void":
        r"""
        getPositionJacobian(RobotModelLink self, double const [3] plocal)


        Computes the position jacobian of a point on this link w.r.t. the robot's
        configuration q.  

        This matrix J gives the point's velocity (in world coordinates) via
        np.dot(J,dq), where dq is the robot's joint velocities.  

        Returns:  

            ndarray: the 3xn Jacobian matrix of the
            point given by local coordinates plocal.  
         Return type: np.ndarray  

        """
        return _robotsim.RobotModelLink_getPositionJacobian(self, plocal)

    def getOrientationJacobian(self) -> "void":
        r"""
        getOrientationJacobian(RobotModelLink self)


        Computes the orientation jacobian of this link w.r.t. the robot's configuration
        q.  

        This matrix J gives the link's angular velocity (in world coordinates) via
        np.dot(J,dq), where dq is the robot's joint velocities.  

        Returns:  

            ndarray:: the 3xn orientation Jacobian matrix of the link.  
         Return type: np.ndarray  

        """
        return _robotsim.RobotModelLink_getOrientationJacobian(self)

    def getJacobianCols(self, plocal: "double const [3]", links: "intVector") -> "void":
        r"""
        getJacobianCols(RobotModelLink self, double const [3] plocal, intVector links)


        Returns the jacobian of a point on this link w.r.t. specified entries of the
        robot's configuration q given by `links`.  

        The orientation jacobian is given in the first 3 rows, and is stacked on the
        position jacobian, which is given in the last 3 rows.  

        Returns:  

            ndarray: the 6xlen(links) Jacobian matrix of the
            point given by local coordinates plocal.
         Return type: np.ndarray  

        """
        return _robotsim.RobotModelLink_getJacobianCols(self, plocal, links)

    def getPositionJacobianCols(self, plocal: "double const [3]", links: "intVector") -> "void":
        r"""
        getPositionJacobianCols(RobotModelLink self, double const [3] plocal, intVector links)


        Returns the position jacobian of a point on this link w.r.t. specified entries
        of the robot's configuration q given by `links`.  

        This matrix J gives the point's velocity (in world coordinates) via
        np.dot(J,dqlinks), where dqlinks are the joint velocities of the links in
        `links`  

        Returns:  

            ndarray: the 3xlen(links) position Jacobian matrix of the
            point given by local coordinates plocal.
         Return type: np.ndarray  

        """
        return _robotsim.RobotModelLink_getPositionJacobianCols(self, plocal, links)

    def getOrientationJacobianCols(self, links: "intVector") -> "void":
        r"""
        getOrientationJacobianCols(RobotModelLink self, intVector links)


        Returns the orientation jacobian this link w.r.t. specified entries of the
        robot's configuration q given by `links`.  

        This matrix J gives the point's angular velocity (in world coordinates) via
        np.dot(J,dqlinks), where dqlinks are the joint velocities of the links in
        `links`  

        Returns:  

            ndarray: the 3xlen(links) orientation Jacobian matrix of the
            link.
         Return type: np.ndarray  

        """
        return _robotsim.RobotModelLink_getOrientationJacobianCols(self, links)

    def getAcceleration(self, ddq: "doubleVector") -> "void":
        r"""
        getAcceleration(RobotModelLink self, doubleVector ddq)


        Computes the acceleration of the link origin given the robot's current joint
        configuration and velocities, and the joint accelerations ddq.  

        ddq can be empty, which calculates the acceleration with acceleration 0, and is
        a little faster than setting ddq to [0]*n  

        Returns:  

            list of 3 floats: the acceleration of the link's origin, in
            world coordinates.
         Return type: Vector3  

        """
        return _robotsim.RobotModelLink_getAcceleration(self, ddq)

    def getPointAcceleration(self, plocal: "double const [3]", ddq: "doubleVector") -> "void":
        r"""
        getPointAcceleration(RobotModelLink self, double const [3] plocal, doubleVector ddq)


        Computes the acceleration of the point given the robot's current joint
        configuration and velocities, and the joint accelerations ddq.  

        Returns:  

            list of 3 floats: the acceleration of the point, in
            world coordinates.
         Return type: Vector3  

        """
        return _robotsim.RobotModelLink_getPointAcceleration(self, plocal, ddq)

    def getAngularAcceleration(self, ddq: "doubleVector") -> "void":
        r"""
        getAngularAcceleration(RobotModelLink self, doubleVector ddq)


        Computes the angular acceleration of the link given the robot's current joint
        configuration and velocities, and the joint accelerations ddq.  

        Returns:  

            list of 3 floats: the angular acceleration of the link, in
            world coordinates.
         Return type: Vector3  

        """
        return _robotsim.RobotModelLink_getAngularAcceleration(self, ddq)

    def getPositionHessian(self, plocal: "double const [3]") -> "void":
        r"""
        getPositionHessian(RobotModelLink self, double const [3] plocal)


        Computes the Hessians of each component of the position p w.r.t the robot's
        configuration q.  

        Returns:  

            ndarray: a 3xnxn array with each of the elements in the first axis
            corresponding respectively, to the (x,y,z) components of the Hessian.
         Return type: np.ndarray  

        """
        return _robotsim.RobotModelLink_getPositionHessian(self, plocal)

    def getOrientationHessian(self) -> "void":
        r"""
        getOrientationHessian(RobotModelLink self)


        Computes the pseudo-Hessians of each orientation component of the link w.r.t the
        robot's configuration q. The pseudo-Hessian is the derivative of the angular
        velocity of this link w.r.t. the joint velocities.  

        Returns:  

            ndarray: a 3xnxn array with each of the elements in the first axis
            corresponding, respectively, to the (wx,wy,wz) components of the
            pseudo-Hessian.
         Return type: np.ndarray  

        """
        return _robotsim.RobotModelLink_getOrientationHessian(self)

    def drawLocalGL(self, keepAppearance: "bool"=True) -> "void":
        r"""
        drawLocalGL(RobotModelLink self, bool keepAppearance=True)


        Draws the link's geometry in its local frame. If keepAppearance=true, the
        current Appearance is honored. Otherwise, just the geometry is drawn.  

        """
        return _robotsim.RobotModelLink_drawLocalGL(self, keepAppearance)

    def drawWorldGL(self, keepAppearance: "bool"=True) -> "void":
        r"""
        drawWorldGL(RobotModelLink self, bool keepAppearance=True)


        Draws the link's geometry in the world frame. If keepAppearance=true, the
        current Appearance is honored. Otherwise, just the geometry is drawn.  

        """
        return _robotsim.RobotModelLink_drawWorldGL(self, keepAppearance)
    world = property(_robotsim.RobotModelLink_world_get, _robotsim.RobotModelLink_world_set, doc=r"""world : int""")
    robotIndex = property(_robotsim.RobotModelLink_robotIndex_get, _robotsim.RobotModelLink_robotIndex_set, doc=r"""robotIndex : int""")
    robotPtr = property(_robotsim.RobotModelLink_robotPtr_get, _robotsim.RobotModelLink_robotPtr_set, doc=r"""robotPtr : p.Klampt::RobotModel""")
    index = property(_robotsim.RobotModelLink_index_get, _robotsim.RobotModelLink_index_set, doc=r"""index : int""")

    def setTransform(self, R_or_T : Union[Matrix3,RigidTransform], t :Optional[Vector3] = None):
        """
        Sets the link's current transformation (R,t) to the world frame. 

        .. note::

            This does NOT perform inverse kinematics.  The transform is
            overwritten when the robot's setConfig() method is called.

        """
        if t is not None:
            self._setTransform(R_or_T,t)
        else:
            self._setTransform(*R_or_T)

    def setParentTransform(self, R_or_T : Union[Matrix3,RigidTransform], t :Optional[Vector3] = None):
        """Sets transformation (R,t) to the parent link"""
        if t is not None:
            self._setParentTransform(R_or_T,t)
        else:
            self._setParentTransform(*R_or_T)

    def setParent(self, index_or_link : Union[int,'RobotModelLink']):
        """
        Sets the link's parent to an index or link (must be on same robot).
        """
        if isinstance(index_or_link, int):
            self.setParentIndex(index_or_link)
        else:
            self.setParentLink(index_or_link)

    def getParent(self) -> int:
        """
        Returns the index of the link's parent (on its robot). -1 indicates no parent.
        """
        return self.getParentIndex()

    name = property(getName, setName)
    parent = property(getParentIndex, setParent)
    mass = property(getMass, setMass)
    parentTransform = property(getParentTransform,setParentTransform)
    axis = property(getAxis,setAxis)
    prismatic = property(isPrismatic,setPrismatic)
    transform = property(getTransform,setTransform)

    __swig_destroy__ = _robotsim.delete_RobotModelLink

# Register RobotModelLink in _robotsim:
_robotsim.RobotModelLink_swigregister(RobotModelLink)

class RobotModelDriver(object):
    r"""


    A reference to a driver of a RobotModel.  

    A driver corresponds to one of the robot's actuators and encodes how its forces
    are transmitted to joints.  

    A RobotModelDriver is not created by hand, but instead accessed using
    :meth:`RobotModel.driver` (index or name)  

    C++ includes: robotmodel.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(RobotModelDriver self) -> RobotModelDriver


        """
        _robotsim.RobotModelDriver_swiginit(self, _robotsim.new_RobotModelDriver())

    def getName(self) -> "char const *":
        r"""
        getName(RobotModelDriver self) -> char const *


        """
        return _robotsim.RobotModelDriver_getName(self)

    def setName(self, name: "char const *") -> "void":
        r"""
        setName(RobotModelDriver self, char const * name)


        Sets the name of the driver.  

        """
        return _robotsim.RobotModelDriver_setName(self, name)

    def robot(self) -> "RobotModel":
        r"""
        robot(RobotModelDriver self) -> RobotModel


        Returns a reference to the driver's robot.  

        """
        return _robotsim.RobotModelDriver_robot(self)

    def getType(self) -> "char const *":
        r"""
        getType(RobotModelDriver self) -> char const *


        Gets the type of the driver.  

        Returns:  

            One of  "normal", "affine", "rotation", "translation", or "custom"


        """
        return _robotsim.RobotModelDriver_getType(self)

    def getAffectedLink(self) -> "int":
        r"""
        getAffectedLink(RobotModelDriver self) -> int


        Returns the single affected link for "normal" links.  

        """
        return _robotsim.RobotModelDriver_getAffectedLink(self)

    def getAffectedLinks(self) -> "void":
        r"""
        getAffectedLinks(RobotModelDriver self)


        Returns the indices of the driver's affected links.  

        Return type: List[int]  

        """
        return _robotsim.RobotModelDriver_getAffectedLinks(self)

    def getAffineCoeffs(self) -> "void":
        r"""
        getAffineCoeffs(RobotModelDriver self)


        For "affine" links, returns the scale and offset of the driver value mapped to
        the world.  

        Returns a pair (scale,offset), each of length len(getAffectedLinks()).  

        Return type: Tuple[Vector,Vector]  

        """
        return _robotsim.RobotModelDriver_getAffineCoeffs(self)

    def setValue(self, val: "double") -> "void":
        r"""
        setValue(RobotModelDriver self, double val)


        Sets the robot's config to correspond to the given driver value.  

        .. note::  

            Does not update the links' forward kinematics.  Use
            robot.setConfig(robot.getConfig()) to update the forward kinematics.


        """
        return _robotsim.RobotModelDriver_setValue(self, val)

    def getValue(self) -> "double":
        r"""
        getValue(RobotModelDriver self) -> double


        Returns the current driver value from the robot's config.  

        """
        return _robotsim.RobotModelDriver_getValue(self)

    def setVelocity(self, val: "double") -> "void":
        r"""
        setVelocity(RobotModelDriver self, double val)


        Sets the robot's velocity to correspond to the given driver velocity value.  

        """
        return _robotsim.RobotModelDriver_setVelocity(self, val)

    def getVelocity(self) -> "double":
        r"""
        getVelocity(RobotModelDriver self) -> double


        Returns the current driver velocity value from the robot's velocity.  

        """
        return _robotsim.RobotModelDriver_getVelocity(self)

    def getLimits(self) -> "void":
        r"""
        getLimits(RobotModelDriver self)


        Returns value limits [xmin,xmax].  

        """
        return _robotsim.RobotModelDriver_getLimits(self)

    def getVelocityLimits(self) -> "void":
        r"""
        getVelocityLimits(RobotModelDriver self)


        Returns velocity limits [vmin,vmax].  

        Return type: Tuple[float,float]  

        """
        return _robotsim.RobotModelDriver_getVelocityLimits(self)

    def getAccelerationLimits(self) -> "void":
        r"""
        getAccelerationLimits(RobotModelDriver self)


        Returns acceleration limits [amin,amax].  

        Return type: Tuple[float,float]  

        """
        return _robotsim.RobotModelDriver_getAccelerationLimits(self)

    def getTorqueLimits(self) -> "void":
        r"""
        getTorqueLimits(RobotModelDriver self)


        Returns generalized torque limits [tmin,tmax].  

        Return type: Tuple[float,float]  

        """
        return _robotsim.RobotModelDriver_getTorqueLimits(self)
    world = property(_robotsim.RobotModelDriver_world_get, _robotsim.RobotModelDriver_world_set, doc=r"""world : int""")
    robotIndex = property(_robotsim.RobotModelDriver_robotIndex_get, _robotsim.RobotModelDriver_robotIndex_set, doc=r"""robotIndex : int""")
    robotPtr = property(_robotsim.RobotModelDriver_robotPtr_get, _robotsim.RobotModelDriver_robotPtr_set, doc=r"""robotPtr : p.Klampt::RobotModel""")
    index = property(_robotsim.RobotModelDriver_index_get, _robotsim.RobotModelDriver_index_set, doc=r"""index : int""")

    name = property(getName, setName)
    type = property(getType)
    affectedLink = property(getAffectedLink)
    affectedLinks = property(getAffectedLinks)
    value = property(getValue, setValue)
    velocity = property(getVelocity, setVelocity)

    __swig_destroy__ = _robotsim.delete_RobotModelDriver

# Register RobotModelDriver in _robotsim:
_robotsim.RobotModelDriver_swigregister(RobotModelDriver)

class RobotModel(object):
    r"""


    A model of a dynamic and kinematic robot.  

    Stores both constant information, like the reference placement of the links,
    joint limits, velocity limits, etc, as well as a *current configuration* and
    *current velocity* which are state-dependent. Several functions depend on the
    robot's current configuration and/or velocity. To update that, use the
    setConfig() and setVelocity() functions. setConfig() also update's the robot's
    link transforms via forward kinematics. You may also use setDOFPosition and
    setDOFVelocity for individual changes, but these are more expensive because each
    call updates all of the affected the link transforms.  

    It is important to understand that changing the configuration of the model
    doesn't actually send a command to the physical / simulated robot. Moreover, the
    model does not automatically get updated when the physical / simulated robot
    moves. In essence, the model maintains temporary storage for performing
    kinematics, dynamics, and planning computations, as well as for visualization.  

    The state of the robot is retrieved using getConfig/getVelocity calls, and is
    set using setConfig/setVelocity. Because many routines change the robot's
    configuration, like IK and motion planning, a common design pattern is to
    save/restore the configuration as follows::  

        q = robot.getConfig()
        do some stuff that may touch the robot's configuration...
        robot.setConfig(q)  

    The model maintains configuration/velocity/acceleration/torque limits. However,
    these are not enforced by the model, so you can happily set configurations
    outside the limits. Valid commands must rather be enforced by the planner /
    controller / simulator.  

    As elsewhere in Klampt, the mapping between links and drivers is not one-to one.
    A driver is essentially an actuator and transmission, and for most links a link
    is driven by a unique driver (e.g., a motor and gearbox). However, there do
    exist certain cases in which a link is not driven at all (e.g., the 6 virtual
    links of a floating-base robot), or multiple links are driven by a single
    actuator (e.g., a parallel-bar mechanism or a compliant hand). There are also
    unusual drivers that introduce underactuated dynamics into the system, such as a
    differential drive or Dubin's car mobile base. Care must be taken when sending
    commands to motor controllers (e.g., Klampt Robot Interface Layer), which often
    work in the actuator space rather than joint space. (See
    :func:`configToDrivers`, :func:`configFromDrivers`, :func:`velocityToDrivers`,
    :func:`velocityFromDrivers`).  

    C++ includes: robotmodel.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(RobotModel self) -> RobotModel


        """
        _robotsim.RobotModel_swiginit(self, _robotsim.new_RobotModel())

    def loadFile(self, fn: "char const *") -> "bool":
        r"""
        loadFile(RobotModel self, char const * fn) -> bool


        Loads the robot from the file fn.  

        Returns:  

            True if successful, False if failed.


        """
        return _robotsim.RobotModel_loadFile(self, fn)

    def saveFile(self, fn: "char const *", geometryPrefix: "char const *"=None) -> "bool":
        r"""
        saveFile(RobotModel self, char const * fn, char const * geometryPrefix=None) -> bool


        Saves the robot to the file fn. Geometries may be saved as well.  

        If `geometryPrefix == None` (default), the geometry is not saved. Otherwise, the
        geometry of each link will be saved to files named `geometryPrefix+name`, where
        `name` is either the name of the geometry file that was loaded, or
        `[link_name].off`  

        """
        return _robotsim.RobotModel_saveFile(self, fn, geometryPrefix)

    def getID(self) -> "int":
        r"""
        getID(RobotModel self) -> int


        Returns the ID of the robot in its world.  

        .. note::  

            The world ID is not the same as the robot index.


        """
        return _robotsim.RobotModel_getID(self)

    def getName(self) -> "char const *":
        r"""
        getName(RobotModel self) -> char const *


        Gets the name of the robot.  

        """
        return _robotsim.RobotModel_getName(self)

    def setName(self, name: "char const *") -> "void":
        r"""
        setName(RobotModel self, char const * name)


        Sets the name of the robot.  

        """
        return _robotsim.RobotModel_setName(self, name)

    def numLinks(self) -> "int":
        r"""
        numLinks(RobotModel self) -> int


        Returns the number of links = number of DOF's.  

        """
        return _robotsim.RobotModel_numLinks(self)

    def link(self, *args) -> "RobotModelLink":
        r"""
        link(RobotModel self, int index) -> RobotModelLink
        link(RobotModel self, char const * name) -> RobotModelLink


        Returns a reference to the link by index or name.  

        """
        return _robotsim.RobotModel_link(self, *args)

    def numDrivers(self) -> "int":
        r"""
        numDrivers(RobotModel self) -> int


        Returns the number of drivers.  

        """
        return _robotsim.RobotModel_numDrivers(self)

    def driver(self, *args) -> "RobotModelDriver":
        r"""
        driver(RobotModel self, int index) -> RobotModelDriver
        driver(RobotModel self, char const * name) -> RobotModelDriver


        Returns a reference to the driver by index or name.  

        """
        return _robotsim.RobotModel_driver(self, *args)

    def getJointType(self, *args) -> "char const *":
        r"""
        getJointType(RobotModel self, int index) -> char const
        getJointType(RobotModel self, char const * name) -> char const *


        Returns the joint type of the joint connecting the link to its parent, where the
        link is identified by index or by name.  

        """
        return _robotsim.RobotModel_getJointType(self, *args)

    def getConfig(self) -> "void":
        r"""
        getConfig(RobotModel self)


        Retrieves the current configuration of the robot model.  

        Return type: Vector  

        """
        return _robotsim.RobotModel_getConfig(self)

    def getVelocity(self) -> "void":
        r"""
        getVelocity(RobotModel self)


        Retreives the current velocity of the robot model.  

        Return type: Vector  

        """
        return _robotsim.RobotModel_getVelocity(self)

    def setConfig(self, q: "doubleVector") -> "void":
        r"""
        setConfig(RobotModel self, doubleVector q)


        Sets the current configuration of the robot. Input q is a vector of length
        numLinks(). This also updates forward kinematics of all links.  

        Again, it is important to realize that the RobotModel is not the same as a
        simulated robot, and this will not change the simulation world. Many functions
        such as IK and motion planning use the RobotModel configuration as a temporary
        variable, so if you need to keep the configuration through a robot-modifying
        function call, you should call `q = robot.getConfig()` before the call, and then
        `robot.setConfig(q)` after it.  

        """
        return _robotsim.RobotModel_setConfig(self, q)

    def setVelocity(self, dq: "doubleVector") -> "void":
        r"""
        setVelocity(RobotModel self, doubleVector dq)


        Sets the current velocity of the robot model. Like the configuration, this is
        also essentially a temporary variable.  

        """
        return _robotsim.RobotModel_setVelocity(self, dq)

    def getJointLimits(self) -> "void":
        r"""
        getJointLimits(RobotModel self)


        Returns a pair (qmin,qmax) of min/max joint limit vectors.  

        Return type: Tuple[Vector,Vector]  

        """
        return _robotsim.RobotModel_getJointLimits(self)

    def setJointLimits(self, qmin: "doubleVector", qmax: "doubleVector") -> "void":
        r"""
        setJointLimits(RobotModel self, doubleVector qmin, doubleVector qmax)


        Sets the min/max joint limit vectors (must have length numLinks())  

        """
        return _robotsim.RobotModel_setJointLimits(self, qmin, qmax)

    def getVelocityLimits(self) -> "void":
        r"""
        getVelocityLimits(RobotModel self)


        Returns the velocity limit vector vmax, the constraint is :math:`|dq[i]| \leq
        vmax[i]`  

        Return type: Vector  

        """
        return _robotsim.RobotModel_getVelocityLimits(self)

    def setVelocityLimits(self, vmax: "doubleVector") -> "void":
        r"""
        setVelocityLimits(RobotModel self, doubleVector vmax)


        Sets the velocity limit vector vmax, the constraint is :math:`|dq[i]| \leq
        vmax[i]`  

        """
        return _robotsim.RobotModel_setVelocityLimits(self, vmax)

    def getAccelerationLimits(self) -> "void":
        r"""
        getAccelerationLimits(RobotModel self)


        Returns the acceleration limit vector amax, the constraint is :math:`|ddq[i]|
        \leq amax[i]`  

        Return type: Vector  

        """
        return _robotsim.RobotModel_getAccelerationLimits(self)

    def setAccelerationLimits(self, amax: "doubleVector") -> "void":
        r"""
        setAccelerationLimits(RobotModel self, doubleVector amax)


        Sets the acceleration limit vector amax, the constraint is :math:`|ddq[i]| \leq
        amax[i]`  

        """
        return _robotsim.RobotModel_setAccelerationLimits(self, amax)

    def getTorqueLimits(self) -> "void":
        r"""
        getTorqueLimits(RobotModel self)


        Returns the torque limit vector tmax, the constraint is :math:`|torque[i]| \leq
        tmax[i]`  

        Return type: Vector  

        """
        return _robotsim.RobotModel_getTorqueLimits(self)

    def setTorqueLimits(self, tmax: "doubleVector") -> "void":
        r"""
        setTorqueLimits(RobotModel self, doubleVector tmax)


        Sets the torque limit vector tmax, the constraint is :math:`|torque[i]| \leq
        tmax[i]`  

        """
        return _robotsim.RobotModel_setTorqueLimits(self, tmax)

    def setDOFPosition(self, *args) -> "void":
        r"""
        setDOFPosition(RobotModel self, int i, double qi)
        setDOFPosition(RobotModel self, char const * name, double qi)


        Sets a single DOF's position (by index or by name).  

        .. note::  

            If you are setting several joints at once, use setConfig because this
            function computes forward kinematics for all descendant links each time
            it is called.


        """
        return _robotsim.RobotModel_setDOFPosition(self, *args)

    def getDOFPosition(self, *args) -> "double":
        r"""
        getDOFPosition(RobotModel self, int i) -> double
        getDOFPosition(RobotModel self, char const * name) -> double


        Returns a single DOF's position (by name)  

        """
        return _robotsim.RobotModel_getDOFPosition(self, *args)

    def getCom(self) -> "void":
        r"""
        getCom(RobotModel self)


        Returns the 3D center of mass at the current config.  

        Return type: Vector3  

        """
        return _robotsim.RobotModel_getCom(self)

    def getComVelocity(self) -> "void":
        r"""
        getComVelocity(RobotModel self)


        Returns the 3D velocity of the center of mass at the current config / velocity.  

        Return type: Vector3  

        """
        return _robotsim.RobotModel_getComVelocity(self)

    def getComJacobian(self) -> "void":
        r"""
        getComJacobian(RobotModel self)


        Computes the Jacobian matrix of the current center of mass.  

        Returns:  

            ndarray: a 3xn matrix J such that np.dot(J,dq) gives the
            COM velocity at the currene configuration
         Return type: np.ndarray  

        """
        return _robotsim.RobotModel_getComJacobian(self)

    def getComJacobianCols(self, links: "intVector") -> "void":
        r"""
        getComJacobianCols(RobotModel self, intVector links)


        Returns the Jacobian matrix of the current center of mass w.r.t. some links of
        the robot.  

        Returns:  

            ndarray: a 3xlen(links) matrix J such that np.dot(J,dqlinks)
            gives the COM velocity at the current configuration, and dqlinks
            is the array of velocities of the links given by `links`
         Return type: np.ndarray  

        """
        return _robotsim.RobotModel_getComJacobianCols(self, links)

    def getLinearMomentum(self) -> "void":
        r"""
        getLinearMomentum(RobotModel self)


        Computes the 3D linear momentum vector.  

        Return type: Vector3  

        """
        return _robotsim.RobotModel_getLinearMomentum(self)

    def getAngularMomentum(self) -> "void":
        r"""
        getAngularMomentum(RobotModel self)


        Computes the 3D angular momentum vector.  

        Return type: Vector3  

        """
        return _robotsim.RobotModel_getAngularMomentum(self)

    def getKineticEnergy(self) -> "double":
        r"""
        getKineticEnergy(RobotModel self) -> double


        Computes the kinetic energy at the current config / velocity.  

        """
        return _robotsim.RobotModel_getKineticEnergy(self)

    def getTotalInertia(self) -> "void":
        r"""
        getTotalInertia(RobotModel self)


        Computes the 3x3 total inertia matrix of the robot.  

        Return type: np.ndarray  

        """
        return _robotsim.RobotModel_getTotalInertia(self)

    def getMassMatrix(self) -> "void":
        r"""
        getMassMatrix(RobotModel self)


        Computes the nxn mass matrix B(q).  

        Takes O(n^2) time  

        Return type: np.ndarray  

        """
        return _robotsim.RobotModel_getMassMatrix(self)

    def getMassMatrixInv(self) -> "void":
        r"""
        getMassMatrixInv(RobotModel self)


        Computes the inverse of the nxn mass matrix B(q)^-1.  

        Takes O(n^2) time, which is much faster than inverting the result of
        getMassMatrix  

        Return type: np.ndarray  

        """
        return _robotsim.RobotModel_getMassMatrixInv(self)

    def getMassMatrixDeriv(self, i: "int") -> "void":
        r"""
        getMassMatrixDeriv(RobotModel self, int i)


        Computes the derivative of the nxn mass matrix with respect to q_i.  

        Takes O(n^3) time.  

        Return type: np.ndarray  

        """
        return _robotsim.RobotModel_getMassMatrixDeriv(self, i)

    def getMassMatrixTimeDeriv(self) -> "void":
        r"""
        getMassMatrixTimeDeriv(RobotModel self)


        Computes the derivative of the nxn mass matrix with respect to t, given the
        robot's current velocity.  

        Takes O(n^4) time.  

        Return type: np.ndarray  

        """
        return _robotsim.RobotModel_getMassMatrixTimeDeriv(self)

    def getCoriolisForceMatrix(self) -> "void":
        r"""
        getCoriolisForceMatrix(RobotModel self)


        Computes the Coriolis force matrix C(q,dq) for current config and velocity.  

        Takes O(n^2) time.  

        Return type: np.ndarray  

        """
        return _robotsim.RobotModel_getCoriolisForceMatrix(self)

    def getCoriolisForces(self) -> "void":
        r"""
        getCoriolisForces(RobotModel self)


        Computes the Coriolis forces C(q,dq)*dq for current config and velocity.  

        Takes O(n) time, which is faster than computing matrix and doing the product.  

        ("Forces" is somewhat of a misnomer; the result is a joint torque vector)  

        Return type: Vector  

        """
        return _robotsim.RobotModel_getCoriolisForces(self)

    def getGravityForces(self, g: "double const [3]") -> "void":
        r"""
        getGravityForces(RobotModel self, double const [3] g)


        Computes the generalized gravity vector G(q) for the given workspace gravity
        vector g (usually (0,0,-9.8)).  

        .. note::  

            "Forces" is somewhat of a misnomer; the result is a vector of joint
            torques.  

        Returns:  

            list of floats: the n-element generalized gravity vector at the
            robot's current configuration.
         Return type: Vector  

        """
        return _robotsim.RobotModel_getGravityForces(self, g)

    def torquesFromAccel(self, ddq: "doubleVector") -> "void":
        r"""
        torquesFromAccel(RobotModel self, doubleVector ddq)


        Computes the inverse dynamics. Uses Recursive Newton Euler solver and takes O(n)
        time.  

        Specifically, solves for :math:`\tau` in the (partial) dynamics equation:  

        .. math::  

            `B(q) \ddot{q} + C(q,\dot{q}) = \tau`  

        .. note::  

            Does not include gravity term G(q).  getGravityForces(g) will
            need to be added to the result.  

        Returns:  

            list of floats: the n-element torque vector that would produce
            the joint accelerations ddq in the absence of external forces.
         Return type: Vector  

        """
        return _robotsim.RobotModel_torquesFromAccel(self, ddq)

    def accelFromTorques(self, t: "doubleVector") -> "void":
        r"""
        accelFromTorques(RobotModel self, doubleVector t)


        Computes the foward dynamics. Uses Recursive Newton Euler solver and takes O(n)
        time.  

        Specifically, solves for :math:`\ddot{q}` in the (partial) dynamics equation:  

        .. math::  

            `B(q) \ddot{q} + C(q,\dot{q}) = \tau`  

        .. note::  

            Does not include gravity term G(q).  getGravityForces(g) will
            need to be subtracted from the argument t.  

        Returns:  

            list of floats: the n-element joint acceleration vector that would
            result from joint torques t in the absence of external forces.
         Return type: Vector  

        """
        return _robotsim.RobotModel_accelFromTorques(self, t)

    def interpolate(self, a: "doubleVector", b: "doubleVector", u: "double") -> "void":
        r"""
        interpolate(RobotModel self, doubleVector a, doubleVector b, double u)


        Interpolates smoothly between two configurations, properly taking into account
        nonstandard joints.  

        Returns:  

            The n-element configuration that is u fraction of the way from a to b.
         Return type: Vector  

        """
        return _robotsim.RobotModel_interpolate(self, a, b, u)

    def distance(self, a: "doubleVector", b: "doubleVector") -> "double":
        r"""
        distance(RobotModel self, doubleVector a, doubleVector b) -> double


        Computes a distance between two configurations, properly taking into account
        nonstandard joints.  

        """
        return _robotsim.RobotModel_distance(self, a, b)

    def interpolateDeriv(self, a: "doubleVector", b: "doubleVector") -> "void":
        r"""
        interpolateDeriv(RobotModel self, doubleVector a, doubleVector b)


        Returns the configuration derivative at a as you interpolate toward b at unit
        speed.  

        Return type: Vector  

        """
        return _robotsim.RobotModel_interpolateDeriv(self, a, b)

    def randomizeConfig(self, unboundedScale: "double"=1.0) -> "void":
        r"""
        randomizeConfig(RobotModel self, double unboundedScale=1.0)


        Samples a random configuration and updates the robot's pose. Properly handles
        non-normal joints and handles DOFs with infinite bounds using a centered
        Laplacian distribution with the given scaling term.  

        .. note::  

            Python random module seeding does not affect the result.


        """
        return _robotsim.RobotModel_randomizeConfig(self, unboundedScale)

    def configToDrivers(self, config: "doubleVector") -> "void":
        r"""
        configToDrivers(RobotModel self, doubleVector config)


        Converts a full configuration (length numLinks()) to a list of driver values
        (length numDrivers()).  

        Return type: Vector  

        """
        return _robotsim.RobotModel_configToDrivers(self, config)

    def velocityToDrivers(self, velocities: "doubleVector") -> "void":
        r"""
        velocityToDrivers(RobotModel self, doubleVector velocities)


        Converts a full velocity vector (length numLinks()) to a list of driver
        velocities (length numDrivers()).  

        Return type: Vector  

        """
        return _robotsim.RobotModel_velocityToDrivers(self, velocities)

    def configFromDrivers(self, driverValues: "doubleVector") -> "void":
        r"""
        configFromDrivers(RobotModel self, doubleVector driverValues)


        Converts a list of driver values (length numDrivers()) to a full configuration
        (length numLinks()).  

        Return type: Vector  

        """
        return _robotsim.RobotModel_configFromDrivers(self, driverValues)

    def velocityFromDrivers(self, driverVelocities: "doubleVector") -> "void":
        r"""
        velocityFromDrivers(RobotModel self, doubleVector driverVelocities)


        Converts a list of driver velocities (length numDrivers()) to a full velocity
        vector (length numLinks()).  

        Return type: Vector  

        """
        return _robotsim.RobotModel_velocityFromDrivers(self, driverVelocities)

    def selfCollisionEnabled(self, link1: "int", link2: "int") -> "bool":
        r"""
        selfCollisionEnabled(RobotModel self, int link1, int link2) -> bool


        Queries whether self collisions between two links is enabled.  

        """
        return _robotsim.RobotModel_selfCollisionEnabled(self, link1, link2)

    def enableSelfCollision(self, link1: "int", link2: "int", value: "bool") -> "void":
        r"""
        enableSelfCollision(RobotModel self, int link1, int link2, bool value)


        Enables/disables self collisions between two links (depending on value)  

        """
        return _robotsim.RobotModel_enableSelfCollision(self, link1, link2, value)

    def selfCollides(self) -> "bool":
        r"""
        selfCollides(RobotModel self) -> bool


        Returns true if the robot is in self collision (faster than manual testing)  

        """
        return _robotsim.RobotModel_selfCollides(self)

    def drawGL(self, keepAppearance: "bool"=True) -> "void":
        r"""
        drawGL(RobotModel self, bool keepAppearance=True)


        Draws the robot geometry. If keepAppearance=true, the current appearance is
        honored. Otherwise, only the raw geometry is drawn.  

        PERFORMANCE WARNING: if keepAppearance is false, then this does not properly
        reuse OpenGL display lists. A better approach to changing the robot's
        appearances is to set the link Appearance's directly.  

        """
        return _robotsim.RobotModel_drawGL(self, keepAppearance)

    def reduce(self, robot: "RobotModel") -> "void":
        r"""
        reduce(RobotModel self, RobotModel robot)


        Sets self to a reduced version of robot, where all fixed DOFs are eliminated.
        The return value is a map from the original robot DOF indices to the reduced
        DOFs.  

        Note that any geometries fixed to the world will disappear.  

        Return type: List[int]  

        """
        return _robotsim.RobotModel_reduce(self, robot)

    def _mount(self, link: "int", subRobot: "RobotModel", R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _mount(RobotModel self, int link, RobotModel subRobot, double const [9] R, double const [3] t)


        Mounts a sub-robot onto a link, with its origin at a given local transform
        (R,t). The sub-robot's links will be renamed to subRobot.getName() + ':' +
        link.getName() unless subRobot.getName() is '', in which case the link names are
        preserved.  

        """
        return _robotsim.RobotModel__mount(self, link, subRobot, R, t)

    def numSensors(self) -> "int":
        r"""
        numSensors(RobotModel self) -> int


        Returns the number of sensors.  

        """
        return _robotsim.RobotModel_numSensors(self)

    def _sensor(self, *args) -> "SensorModel":
        r"""
        _sensor(RobotModel self, int index) -> SensorModel
        _sensor(RobotModel self, char const * name) -> SensorModel


        """
        return _robotsim.RobotModel__sensor(self, *args)

    def addSensor(self, name: "char const *", type: "char const *") -> "SensorModel":
        r"""
        addSensor(RobotModel self, char const * name, char const * type) -> SensorModel


        Adds a new sensor with a given name and type.  

        Returns:  

            The new sensor.


        """
        return _robotsim.RobotModel_addSensor(self, name, type)
    world = property(_robotsim.RobotModel_world_get, _robotsim.RobotModel_world_set, doc=r"""world : int""")
    index = property(_robotsim.RobotModel_index_get, _robotsim.RobotModel_index_set, doc=r"""index : int""")
    robot = property(_robotsim.RobotModel_robot_get, _robotsim.RobotModel_robot_set, doc=r"""robot : p.Klampt::RobotModel""")
    dirty_dynamics = property(_robotsim.RobotModel_dirty_dynamics_get, _robotsim.RobotModel_dirty_dynamics_set, doc=r"""dirty_dynamics : bool""")

    @property
    def links(self) -> Sequence[RobotModelLink]:
        """
        A tuple of all links on the robot.
        """
        return tuple(self.link(i) for i in range(self.numLinks()))

    @property
    def linksDict(self) -> Dict[str,RobotModelLink]:
        """
        A frozen dictionary mapping link names to RobotModelLink instances.
        """
        return types.MappingProxyType({l.name:l for l in self.links})

    @property
    def drivers(self) -> Sequence[RobotModelDriver]:
        """
        A tuple of all drivers on the robot.
        """
        return tuple(self.driver(i) for i in range(self.numDrivers()))

    @property
    def driversDict(self) -> Dict[str,RobotModelDriver]:
        """
        A frozen dictionary mapping driver names to RobotModelDriver instances.
        """
        return types.MappingProxyType({d.name:d for d in self.drivers})

    def sensor(self, index_or_name : Union[int,str]) -> 'SensorModel':
        """
        Retrieves the sensor with the given index or name.  A KeyError is
        raised if it does not exist.
        """
        res = self._sensor(index_or_name)
        if len(res.type) == 0:
            raise KeyError("Invalid sensor name: {}".format(index_or_name))
        return res

    @property
    def sensors(self) -> Sequence['SensorModel']:
        """
        A tuple of all sensors on the robot.
        """
        return tuple(self.sensor(i) for i in range(self.numSensors()))

    @property
    def sensorsDict(self) -> Dict[str,'SensorModel']:
        """
        A frozen dictionary mapping sensor names to SensorModel instances.
        """
        return types.MappingProxyType({s.name:s for s in self.sensors})

    def mount(self, link: Union[int,str,'RobotModelLink'], subRobot: 'RobotModel', R_or_T: Union[Matrix3,RigidTransform], t : Optional[Vector3]):
        """
        Mounts a sub-robot onto a link, with its origin at a given local transform (R,t).

        The sub-robot's links will be renamed to subRobot.getName() + ':' + link.getName()
        unless subRobot.getName() is '', in which case the link names are preserved.
        """
        if isinstance(link,str):
           link = self.link(link).index
        elif isinstance(link,RobotModelLink):
           link = link.index
        if t is not None:
            self._mount(link, subRobot, R_or_T, t)
        else:
            self._mount(link, subRobot, *R_or_T)

    name = property(getName, setName)
    id = property(getID)
    config = property(getConfig,setConfig)
    """The robot's configuration.  Retrieved by value, so you will need to use
    setConfig (or config=...) for changes take effect."""
    velocity = property(getVelocity,setVelocity)
    """The robot's velocity.  Retrieved by value, so you will need to use
    setVelocity (or velocity=...) for changes to take effect."""

    __swig_destroy__ = _robotsim.delete_RobotModel

# Register RobotModel in _robotsim:
_robotsim.RobotModel_swigregister(RobotModel)

class SensorModel(object):
    r"""


    A sensor on a simulated robot.  

    Kinematic models of sensors are retrieved using :meth:`RobotModel.sensor` and
    can be created using :meth:`RobotModel.addSensor`.  

    Physically-simulated sensors are retrieved from a controller using
    :meth:`SimRobotController.sensor`, and can be created using
    :meth:`SimRobotController.addSensor`.  

    Some types of sensors can be kinematically-simulated such that they make
    sensible measurements. To use kinematic simulation, you may arbitrarily set the
    robot's position, call :meth:`kinematicReset`, and then call
    :meth:`kinematicSimulate`. Subsequent calls assume the robot is being driven
    along a coherent trajectory until the next :meth:`kinematicReset` is called.
    This is necessary for sensors that estimate accelerations, e.g.,
    ForceTorqueSensor, Accelerometer  

    Physically-simulated sensors are automatically updated through the
    :meth:`Simulator.simulate` call.  

    Use :meth:`getMeasurements` to get the currently simulated measurement vector.
    You may get garbage measurements before kinematicSimulate / Simulator.simulate
    are called.  

    LaserSensor, CameraSensor, TiltSensor, AccelerometerSensor, GyroSensor,
    JointPositionSensor, JointVelocitySensor support kinematic simulation mode.
    FilteredSensor and TimeDelayedSensor also work. The force-related sensors
    (ContactSensor and ForceTorqueSensor) return 0's in kinematic simulation.  

    To use get/setSetting, you will need to know the sensor attribute names and
    types as described in `the Klampt sensor documentation
    <https://github.com/krishauser/Klampt/blob/master/Cpp/docs/Manual-
    Control.md#sensors>`_ (same as in the world or sensor XML file). Common settings
    include:  

    *   rate (float): how frequently the sensor is simulated  
    *   enabled (bool): whether the simulator simulates this sensor  
    *   link (int): the link on which this sensor lies (-1 for world)  
    *   Tsensor (se3 transform, serialized with loader.write_se3(T)): the transform
        of the sensor on the robot / world.  

    C++ includes: robotmodel.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, robot: "RobotModel", sensor: "Klampt::SensorBase *"):
        r"""
        __init__(SensorModel self, RobotModel robot, Klampt::SensorBase * sensor) -> SensorModel


        """
        _robotsim.SensorModel_swiginit(self, _robotsim.new_SensorModel(robot, sensor))

    def getName(self) -> "std::string":
        r"""
        getName(SensorModel self) -> std::string


        Returns the name of the sensor.  

        """
        return _robotsim.SensorModel_getName(self)

    def setName(self, name: "std::string const &") -> "void":
        r"""
        setName(SensorModel self, std::string const & name)


        Sets the name of the sensor.  

        """
        return _robotsim.SensorModel_setName(self, name)

    def getType(self) -> "std::string":
        r"""
        getType(SensorModel self) -> std::string


        Returns the type of the sensor.  

        """
        return _robotsim.SensorModel_getType(self)

    def robot(self) -> "RobotModel":
        r"""
        robot(SensorModel self) -> RobotModel


        Returns the model of the robot to which this belongs.  

        """
        return _robotsim.SensorModel_robot(self)

    def measurementNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        measurementNames(SensorModel self) -> stringVector


        Returns a list of names for the measurements (one per measurement).  

        """
        return _robotsim.SensorModel_measurementNames(self)

    def getMeasurements(self) -> "void":
        r"""
        getMeasurements(SensorModel self)


        Returns an array of measurements from the previous simulation (or
        kinematicSimulate) timestep.  

        Return type: np.ndarray  

        """
        return _robotsim.SensorModel_getMeasurements(self)

    def settings(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        settings(SensorModel self) -> stringVector


        Returns all setting names.  

        """
        return _robotsim.SensorModel_settings(self)

    def getSetting(self, name: "std::string const &") -> "std::string":
        r"""
        getSetting(SensorModel self, std::string const & name) -> std::string


        Returns the value of the named setting (you will need to manually parse this)  

        """
        return _robotsim.SensorModel_getSetting(self, name)

    def setSetting(self, name: "std::string const &", val: "std::string const &") -> "void":
        r"""
        setSetting(SensorModel self, std::string const & name, std::string const & val)


        Sets the value of the named setting (you will need to manually cast an
        int/float/etc to a str)  

        """
        return _robotsim.SensorModel_setSetting(self, name, val)

    def getEnabled(self) -> "bool":
        r"""
        getEnabled(SensorModel self) -> bool


        Return whether the sensor is enabled during simulation (helper for getSetting)  

        """
        return _robotsim.SensorModel_getEnabled(self)

    def setEnabled(self, enabled: "bool") -> "void":
        r"""
        setEnabled(SensorModel self, bool enabled)


        Sets whether the sensor is enabled in physics simulation.  

        """
        return _robotsim.SensorModel_setEnabled(self, enabled)

    def _getLink(self) -> "RobotModelLink":
        r"""
        _getLink(SensorModel self) -> RobotModelLink


        Returns the link on which the sensor is mounted.  

        """
        return _robotsim.SensorModel__getLink(self)

    def _setLink(self, *args) -> "void":
        r"""
        _setLink(SensorModel self, RobotModelLink link)
        _setLink(SensorModel self, int link)


        Sets the link on which the sensor is mounted (helper for setSetting)  

        """
        return _robotsim.SensorModel__setLink(self, *args)

    def getTransform(self) -> "void":
        r"""
        getTransform(SensorModel self)


        Returns the local transform of the sensor on the robot's link. (helper for
        getSetting)  

        If the sensor doesn't have a transform (such as a joint position or torque
        sensor) an exception will be raised.  

        Return type: RigidTransform  

        """
        return _robotsim.SensorModel_getTransform(self)

    def getTransformWorld(self) -> "void":
        r"""
        getTransformWorld(SensorModel self)


        Returns the world transform of the sensor given the robot's current
        configuration. (helper for getSetting)  

        If the sensor doesn't have a transform (such as a joint position or torque
        sensor) an exception will be raised.  

        Return type: RigidTransform  

        """
        return _robotsim.SensorModel_getTransformWorld(self)

    def _setTransform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _setTransform(SensorModel self, double const [9] R, double const [3] t)


        Sets the local transform of the sensor on the robot's link. (helper for
        setSetting)  

        If the sensor doesn't have a transform (such as a joint position or torque
        sensor) an exception will be raised.  

        """
        return _robotsim.SensorModel__setTransform(self, R, t)

    def drawGL(self, *args) -> "void":
        r"""
        drawGL(SensorModel self)
        drawGL(SensorModel self, double * np_array)


        Draws a sensor indicator using OpenGL. If measurements are given, the indicator
        is drawn as though these are the latest measurements, otherwise only an
        indicator is drawn.  

        """
        return _robotsim.SensorModel_drawGL(self, *args)

    def kinematicSimulate(self, *args) -> "void":
        r"""
        kinematicSimulate(SensorModel self, WorldModel world, double dt)
        kinematicSimulate(SensorModel self, double dt)


        """
        return _robotsim.SensorModel_kinematicSimulate(self, *args)

    def kinematicReset(self) -> "void":
        r"""
        kinematicReset(SensorModel self)


        resets a kinematic simulation so that a new initial condition can be set  

        """
        return _robotsim.SensorModel_kinematicReset(self)
    robotModel = property(_robotsim.SensorModel_robotModel_get, _robotsim.SensorModel_robotModel_set, doc=r"""robotModel : RobotModel""")
    sensor = property(_robotsim.SensorModel_sensor_get, _robotsim.SensorModel_sensor_set, doc=r"""sensor : p.Klampt::SensorBase""")

    def setTransform(self, R_or_T : Union[Matrix3,RigidTransform], t :Optional[Vector3] = None):
        """Sets the local transform of the sensor on the robot's link.
        (helper for setSetting)

        If the sensor doesn't have a transform (such as a joint position or
        torque sensor) an exception will be raised.
        """
        if t is not None:
            self._setTransform(R_or_T,t)
        else:
            self._setTransform(*R_or_T)

    def getLink(self) -> Optional[RobotModelLink]:
        """
        Retrieves the link that this sensor is mounted on, or None for
        world-mounted sensors.
        """
        l = self._getLink()
        if l.index < 0:
            return None
        return l

    def setLink(self, link : Union[int,None,RobotModelLink]):
        """
        Sets the link that this sensor is mounted on, or None / -1 for
        world-mounted sensors.
        """
        if link is None:
            self._setLink(-1)
        elif isinstance(link,RobotModelLink):
            self._setLink(link.index)
        else:
            self._setLink(link)

    name = property(getName, setName)

    type = property(getType)
    """A string giving the sensor's type.  Read-only."""

    enabled = property(getEnabled,setEnabled)
    """Whether the sensor is enabled in physical simulation."""

    link = property(getLink,setLink)
    """The link that this sensor lies on.  May be None."""

    __swig_destroy__ = _robotsim.delete_SensorModel

# Register SensorModel in _robotsim:
_robotsim.SensorModel_swigregister(SensorModel)

class RigidObjectModel(object):
    r"""


    A rigid movable object.  

    A rigid object has a name, geometry, appearance, mass, surface properties, and
    current transform / velocity.  

    State is retrieved/set using get/setTransform, and get/setVelocity  

    C++ includes: robotmodel.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(RigidObjectModel self) -> RigidObjectModel


        """
        _robotsim.RigidObjectModel_swiginit(self, _robotsim.new_RigidObjectModel())

    def loadFile(self, fn: "char const *") -> "bool":
        r"""
        loadFile(RigidObjectModel self, char const * fn) -> bool


        Loads the object from the file fn.  

        """
        return _robotsim.RigidObjectModel_loadFile(self, fn)

    def saveFile(self, fn: "char const *", geometryName: "char const *"=None) -> "bool":
        r"""
        saveFile(RigidObjectModel self, char const * fn, char const * geometryName=None) -> bool


        Saves the object to the file fn. If geometryName is given, the geometry is saved
        to that file.  

        """
        return _robotsim.RigidObjectModel_saveFile(self, fn, geometryName)

    def getID(self) -> "int":
        r"""
        getID(RigidObjectModel self) -> int


        Returns the ID of the rigid object in its world.  

        .. note::  

            The world ID is not the same as the rigid object index.


        """
        return _robotsim.RigidObjectModel_getID(self)

    def getName(self) -> "char const *":
        r"""
        getName(RigidObjectModel self) -> char const *


        """
        return _robotsim.RigidObjectModel_getName(self)

    def setName(self, name: "char const *") -> "void":
        r"""
        setName(RigidObjectModel self, char const * name)


        """
        return _robotsim.RigidObjectModel_setName(self, name)

    def geometry(self) -> "Geometry3D":
        r"""
        geometry(RigidObjectModel self) -> Geometry3D


        Returns a reference to the geometry associated with this object.  

        """
        return _robotsim.RigidObjectModel_geometry(self)

    def appearance(self) -> "Appearance":
        r"""
        appearance(RigidObjectModel self) -> Appearance


        Returns a reference to the appearance associated with this object.  

        """
        return _robotsim.RigidObjectModel_appearance(self)

    def getMass(self) -> "Mass":
        r"""
        getMass(RigidObjectModel self) -> Mass


        Returns a copy of the Mass of this rigid object.  

        .. note::  

            To change the mass properties, you should call ``m=object.getMass()``,
            change the desired properties in m, and then ``object.setMass(m)``


        """
        return _robotsim.RigidObjectModel_getMass(self)

    def setMass(self, mass: "Mass") -> "void":
        r"""
        setMass(RigidObjectModel self, Mass mass)


        """
        return _robotsim.RigidObjectModel_setMass(self, mass)

    def getContactParameters(self) -> "ContactParameters":
        r"""
        getContactParameters(RigidObjectModel self) -> ContactParameters


        Returns a copy of the ContactParameters of this rigid object.  

        .. note::  

            To change the contact parameters, you should call
            ``p=object.getContactParameters()``, change the desired properties in
            p, and then call ``object.setContactParameters(p)``


        """
        return _robotsim.RigidObjectModel_getContactParameters(self)

    def setContactParameters(self, params: "ContactParameters") -> "void":
        r"""
        setContactParameters(RigidObjectModel self, ContactParameters params)


        """
        return _robotsim.RigidObjectModel_setContactParameters(self, params)

    def getTransform(self) -> "void":
        r"""
        getTransform(RigidObjectModel self)


        Retrieves the rotation / translation of the rigid object (R,t)  

        Returns:  

            se3 object: a pair (R,t), with R a 9-list and t a 3-list of floats,
            giving the transform to world coordinates.
         Return type: RigidTransform  

        """
        return _robotsim.RigidObjectModel_getTransform(self)

    def _setTransform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _setTransform(RigidObjectModel self, double const [9] R, double const [3] t)


        Sets the rotation / translation (R,t) of the rigid object.  

        """
        return _robotsim.RigidObjectModel__setTransform(self, R, t)

    def getVelocity(self) -> "void":
        r"""
        getVelocity(RigidObjectModel self)


        Retrieves the (angular velocity, velocity) of the rigid object.  

        Returns:  

            A pair of 3-lists (w,v) where w is the angular velocity
            vector and v is the translational velocity vector (both in world
            coordinates)
         Return type: Tuple[Vector3,Vector3]  

        """
        return _robotsim.RigidObjectModel_getVelocity(self)

    def setVelocity(self, angularVelocity: "double const [3]", velocity: "double const [3]") -> "void":
        r"""
        setVelocity(RigidObjectModel self, double const [3] angularVelocity, double const [3] velocity)


        Sets the (angular velocity, velocity) of the rigid object.  

        """
        return _robotsim.RigidObjectModel_setVelocity(self, angularVelocity, velocity)

    def drawGL(self, keepAppearance: "bool"=True) -> "void":
        r"""
        drawGL(RigidObjectModel self, bool keepAppearance=True)


        Draws the object's geometry. If keepAppearance=true, the current appearance is
        honored. Otherwise, only the raw geometry is drawn.  

        PERFORMANCE WARNING: if keepAppearance is false, then this does not properly
        reuse OpenGL display lists. A better approach is to change the object's
        Appearance directly.  

        """
        return _robotsim.RigidObjectModel_drawGL(self, keepAppearance)
    world = property(_robotsim.RigidObjectModel_world_get, _robotsim.RigidObjectModel_world_set, doc=r"""world : int""")
    index = property(_robotsim.RigidObjectModel_index_get, _robotsim.RigidObjectModel_index_set, doc=r"""index : int""")
    object = property(_robotsim.RigidObjectModel_object_get, _robotsim.RigidObjectModel_object_set, doc=r"""object : p.Klampt::RigidObjectModel""")

    def setTransform(self, R_or_T : Union[Matrix3,RigidTransform], t :Optional[Vector3] = None):
        if t is not None:
            self._setTransform(R_or_T,t)
        else:
            self._setTransform(*R_or_T)

    name = property(getName, setName)
    id = property(getID)
    mass = property(getMass, setMass)
    transform = property(getTransform)

    __swig_destroy__ = _robotsim.delete_RigidObjectModel

# Register RigidObjectModel in _robotsim:
_robotsim.RigidObjectModel_swigregister(RigidObjectModel)

class TerrainModel(object):
    r"""


    Static environment geometry.  

    C++ includes: robotmodel.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(TerrainModel self) -> TerrainModel


        """
        _robotsim.TerrainModel_swiginit(self, _robotsim.new_TerrainModel())

    def loadFile(self, fn: "char const *") -> "bool":
        r"""
        loadFile(TerrainModel self, char const * fn) -> bool


        Loads the terrain from the file fn.  

        """
        return _robotsim.TerrainModel_loadFile(self, fn)

    def saveFile(self, fn: "char const *", geometryName: "char const *"=None) -> "bool":
        r"""
        saveFile(TerrainModel self, char const * fn, char const * geometryName=None) -> bool


        Saves the terrain to the file fn. If geometryName is given, the geometry is
        saved to that file.  

        """
        return _robotsim.TerrainModel_saveFile(self, fn, geometryName)

    def getID(self) -> "int":
        r"""
        getID(TerrainModel self) -> int


        Returns the ID of the terrain in its world.  

        .. note::  

            The world ID is not the same as the terrain index.


        """
        return _robotsim.TerrainModel_getID(self)

    def getName(self) -> "char const *":
        r"""
        getName(TerrainModel self) -> char const *


        """
        return _robotsim.TerrainModel_getName(self)

    def setName(self, name: "char const *") -> "void":
        r"""
        setName(TerrainModel self, char const * name)


        """
        return _robotsim.TerrainModel_setName(self, name)

    def geometry(self) -> "Geometry3D":
        r"""
        geometry(TerrainModel self) -> Geometry3D


        Returns a reference to the geometry associated with this object.  

        """
        return _robotsim.TerrainModel_geometry(self)

    def appearance(self) -> "Appearance":
        r"""
        appearance(TerrainModel self) -> Appearance


        Returns a reference to the appearance associated with this object.  

        """
        return _robotsim.TerrainModel_appearance(self)

    def setFriction(self, friction: "double") -> "void":
        r"""
        setFriction(TerrainModel self, double friction)


        Changes the friction coefficient for this terrain.  

        """
        return _robotsim.TerrainModel_setFriction(self, friction)

    def drawGL(self, keepAppearance: "bool"=True) -> "void":
        r"""
        drawGL(TerrainModel self, bool keepAppearance=True)


        Draws the object's geometry. If keepAppearance=true, the current appearance is
        honored. Otherwise, only the raw geometry is drawn.  

        PERFORMANCE WARNING: if keepAppearance is false, then this does not properly
        reuse OpenGL display lists. A better approach is to change the object's
        Appearance directly.  

        """
        return _robotsim.TerrainModel_drawGL(self, keepAppearance)
    world = property(_robotsim.TerrainModel_world_get, _robotsim.TerrainModel_world_set, doc=r"""world : int""")
    index = property(_robotsim.TerrainModel_index_get, _robotsim.TerrainModel_index_set, doc=r"""index : int""")
    terrain = property(_robotsim.TerrainModel_terrain_get, _robotsim.TerrainModel_terrain_set, doc=r"""terrain : p.Klampt::TerrainModel""")

    name = property(getName, setName)
    id = property(getID)

    __swig_destroy__ = _robotsim.delete_TerrainModel

# Register TerrainModel in _robotsim:
_robotsim.TerrainModel_swigregister(TerrainModel)

class WorldModel(object):
    r"""


    The main world class, containing robots, rigid objects, and static environment
    geometry.  

    Attributes:  

        - robots: a list of RobotModel instances
        - rigidObjects: a list of RigidObjectModel instances
        - terrains: a list of TerrainModel instances  

    .. note:  

        Although a WorldModel instance is typically called a "world" it is
        just a model and does not have to reflect the state of a physical world.
        The state of robots and objects in the world can be changed at will --
        in fact planners and simulators will query and modify the state of a
        WorldModel during their operation.

        To keep around some "authoritative" world, you can keep around a copy
        (use ``WorldModel.copy()``) or ``config.get_config(world)`` using the
        :mod:`klampt.model.config` module.  

    Every robot/robot link/terrain/rigid object is given a unique ID in the world.
    This is potentially a source of confusion because some functions take IDs and
    some take indices. Only the WorldModel and Simulator classes use IDs when the
    argument has 'id' as a suffix, e.g., geometry(), appearance(),
    Simulator.inContact(). All other functions use indices, e.g. robot(0),
    terrain(0), etc.  

    To get an object's ID, you can see the value returned by loadElement and/or
    object.getID().  

    To save/restore the state of the model, you must manually maintain copies of the
    states of whichever objects you wish to save/restore.  

    C++ includes: robotmodel.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(WorldModel self) -> WorldModel
        __init__(WorldModel self, void * ptrRobotWorld) -> WorldModel
        __init__(WorldModel self, WorldModel w) -> WorldModel
        __init__(WorldModel self, char const * fn) -> WorldModel


        Creates a WorldModel.  

        *   Given no arguments, creates a new world.  
        *   Given another WorldModel instance, creates a reference to an existing world.
            (To create a copy, use the copy() method.)  
        *   Given a string, loads from a file. A PyException is raised on failure.  
        *   Given a pointer to a C++ RobotWorld structure, a reference to that structure
            is returned. (This is advanced usage, seen only when interfacing C++ and
            Python code)  

        """
        _robotsim.WorldModel_swiginit(self, _robotsim.new_WorldModel(*args))
    __swig_destroy__ = _robotsim.delete_WorldModel

    def copy(self) -> "WorldModel":
        r"""
        copy(WorldModel self) -> WorldModel


        Creates a copy of the world model. Note that geometries and appearances are
        shared, so this is very quick.  

        """
        return _robotsim.WorldModel_copy(self)

    def readFile(self, fn: "char const *") -> "bool":
        r"""
        readFile(WorldModel self, char const * fn) -> bool


        Reads from a world XML file.  

        Returns:  

            True if successful, False if failed.


        """
        return _robotsim.WorldModel_readFile(self, fn)

    def loadFile(self, fn: "char const *") -> "bool":
        r"""
        loadFile(WorldModel self, char const * fn) -> bool


        Alias of readFile.  

        """
        return _robotsim.WorldModel_loadFile(self, fn)

    def saveFile(self, fn: "char const *", elementDir: "char const *"=None) -> "bool":
        r"""
        saveFile(WorldModel self, char const * fn, char const * elementDir=None) -> bool


        Saves to a world XML file. Elements in the world will be saved to a folder.  

        If elementDir is provided, then robots, terrains, etc. will be saved there.
        Otherwise they will be saved to a folder with the same base name as fn (without
        the trailing .xml)  

        """
        return _robotsim.WorldModel_saveFile(self, fn, elementDir)

    def numRobots(self) -> "int":
        r"""
        numRobots(WorldModel self) -> int


        Returns the number of robots.  

        """
        return _robotsim.WorldModel_numRobots(self)

    def numRobotLinks(self, robot: "int") -> "int":
        r"""
        numRobotLinks(WorldModel self, int robot) -> int


        Returns the number of links on the given robot.  

        """
        return _robotsim.WorldModel_numRobotLinks(self, robot)

    def numRigidObjects(self) -> "int":
        r"""
        numRigidObjects(WorldModel self) -> int


        Returns the number of rigid objects.  

        """
        return _robotsim.WorldModel_numRigidObjects(self)

    def numTerrains(self) -> "int":
        r"""
        numTerrains(WorldModel self) -> int


        Returns the number of terrains.  

        """
        return _robotsim.WorldModel_numTerrains(self)

    def numIDs(self) -> "int":
        r"""
        numIDs(WorldModel self) -> int


        Returns the total number of world ids.  

        """
        return _robotsim.WorldModel_numIDs(self)

    def robot(self, *args) -> "RobotModel":
        r"""
        robot(WorldModel self, int index) -> RobotModel
        robot(WorldModel self, char const * name) -> RobotModel


        Returns a RobotModel in the world by index or name.  

        """
        return _robotsim.WorldModel_robot(self, *args)

    def robotLink(self, *args) -> "RobotModelLink":
        r"""
        robotLink(WorldModel self, int robot, int index) -> RobotModelLink
        robotLink(WorldModel self, char const * robot, char const * name) -> RobotModelLink


        Returns a RobotModelLink of some RobotModel in the world by index or name.  

        """
        return _robotsim.WorldModel_robotLink(self, *args)

    def rigidObject(self, *args) -> "RigidObjectModel":
        r"""
        rigidObject(WorldModel self, int index) -> RigidObjectModel
        rigidObject(WorldModel self, char const * name) -> RigidObjectModel


        Returns a RigidObjectModel in the world by index or name.  

        """
        return _robotsim.WorldModel_rigidObject(self, *args)

    def terrain(self, *args) -> "TerrainModel":
        r"""
        terrain(WorldModel self, int index) -> TerrainModel
        terrain(WorldModel self, char const * name) -> TerrainModel


        Returns a TerrainModel in the world by index or name.  

        """
        return _robotsim.WorldModel_terrain(self, *args)

    def makeRobot(self, name: "char const *") -> "RobotModel":
        r"""
        makeRobot(WorldModel self, char const * name) -> RobotModel


        Creates a new empty robot. (Not terribly useful now since you can't resize the
        number of links yet)  

        """
        return _robotsim.WorldModel_makeRobot(self, name)

    def makeRigidObject(self, name: "char const *") -> "RigidObjectModel":
        r"""
        makeRigidObject(WorldModel self, char const * name) -> RigidObjectModel


        Creates a new empty rigid object.  

        """
        return _robotsim.WorldModel_makeRigidObject(self, name)

    def makeTerrain(self, name: "char const *") -> "TerrainModel":
        r"""
        makeTerrain(WorldModel self, char const * name) -> TerrainModel


        Creates a new empty terrain.  

        """
        return _robotsim.WorldModel_makeTerrain(self, name)

    def loadRobot(self, fn: "char const *") -> "RobotModel":
        r"""
        loadRobot(WorldModel self, char const * fn) -> RobotModel


        Loads a robot from a .rob or .urdf file. An empty robot is returned if loading
        fails.  

        """
        return _robotsim.WorldModel_loadRobot(self, fn)

    def loadRigidObject(self, fn: "char const *") -> "RigidObjectModel":
        r"""
        loadRigidObject(WorldModel self, char const * fn) -> RigidObjectModel


        Loads a rigid object from a .obj or a mesh file. An empty rigid object is
        returned if loading fails.  

        """
        return _robotsim.WorldModel_loadRigidObject(self, fn)

    def loadTerrain(self, fn: "char const *") -> "TerrainModel":
        r"""
        loadTerrain(WorldModel self, char const * fn) -> TerrainModel


        Loads a rigid object from a mesh file. An empty terrain is returned if loading
        fails.  

        """
        return _robotsim.WorldModel_loadTerrain(self, fn)

    def loadElement(self, fn: "char const *") -> "int":
        r"""
        loadElement(WorldModel self, char const * fn) -> int


        Loads some element from a file, automatically detecting its type. Meshes are
        interpreted as terrains.  

        Returns:  

            The element's ID, or -1 if loading failed.


        """
        return _robotsim.WorldModel_loadElement(self, fn)

    def add(self, *args) -> "TerrainModel":
        r"""
        add(WorldModel self, char const * name, RobotModel robot) -> RobotModel
        add(WorldModel self, char const * name, RigidObjectModel obj) -> RigidObjectModel
        add(WorldModel self, char const * name, TerrainModel terrain) -> TerrainModel


        Adds a copy of the given robot, rigid object, or terrain to this world, either
        from this WorldModel or another.  

        """
        return _robotsim.WorldModel_add(self, *args)

    def remove(self, *args) -> "void":
        r"""
        remove(WorldModel self, RobotModel robot)
        remove(WorldModel self, RigidObjectModel object)
        remove(WorldModel self, TerrainModel terrain)


        Removes a robot, rigid object, or terrain from the world. It must be in this
        world or an exception is raised.  

        IMPORTANT:  

            All other RobotModel, RigidObjectModel, or TerrainModel references
            will be invalidated.


        """
        return _robotsim.WorldModel_remove(self, *args)

    def entityType(self, id: "int") -> "std::string":
        r"""
        entityType(WorldModel self, int id) -> std::string


        Returns either 'robot', 'robotLink', 'rigidObject', or 'terrain'.  

        """
        return _robotsim.WorldModel_entityType(self, id)

    def getName(self, id: "int") -> "std::string":
        r"""
        getName(WorldModel self, int id) -> std::string


        Retrieves the name for a given element ID.  

        """
        return _robotsim.WorldModel_getName(self, id)

    def setName(self, id: "int", name: "char const *") -> "void":
        r"""
        setName(WorldModel self, int id, char const * name)


        Sets the name for a given element ID.  

        """
        return _robotsim.WorldModel_setName(self, id, name)

    def geometry(self, id: "int") -> "Geometry3D":
        r"""
        geometry(WorldModel self, int id) -> Geometry3D


        Retrieves a geometry for a given element ID.  

        """
        return _robotsim.WorldModel_geometry(self, id)

    def appearance(self, id: "int") -> "Appearance":
        r"""
        appearance(WorldModel self, int id) -> Appearance


        Retrieves an appearance for a given element ID.  

        """
        return _robotsim.WorldModel_appearance(self, id)

    def drawGL(self) -> "void":
        r"""
        drawGL(WorldModel self)


        Draws the entire world using OpenGL.  

        """
        return _robotsim.WorldModel_drawGL(self)

    def enableGeometryLoading(self, enabled: "bool") -> "void":
        r"""
        enableGeometryLoading(WorldModel self, bool enabled)


        If geometry loading is set to false, then only the kinematics are loaded from
        disk, and no geometry / visualization / collision detection structures will be
        loaded. Useful for quick scripts that just use kinematics / dynamics of a robot.  

        """
        return _robotsim.WorldModel_enableGeometryLoading(self, enabled)

    def enableInitCollisions(self, enabled: "bool") -> "void":
        r"""
        enableInitCollisions(WorldModel self, bool enabled)


        If collision detection is set to true, then collision acceleration data
        structures will be automatically initialized, with debugging information. Useful
        for scripts that do planning and for which collision initialization may take a
        long time.  

        Note that even when this flag is off, the collision acceleration data structures
        will indeed be initialized the first time that geometry collision, distance, or
        ray-casting routines are called.  

        """
        return _robotsim.WorldModel_enableInitCollisions(self, enabled)
    index = property(_robotsim.WorldModel_index_get, _robotsim.WorldModel_index_set, doc=r"""index : int""")

    @property
    def robots(self) -> Sequence[RobotModel]:
        """
        A tuple of all robots in the world.
        """
        return tuple(self.robot(i) for i in range(self.numRobots()))

    @property
    def robotsDict(self) -> Dict[str,RobotModel]:
        """
        A frozen dictionary mapping robot names to RobotModel instances.
        """
        return types.MappingProxyType({r.name:r for r in self.robots})

    @property
    def rigidObjects(self) -> Sequence[RigidObjectModel]:
        """
        A tuple of all rigid objects in the world.
        """
        return tuple(self.rigidObject(i) for i in range(self.numRigidObjects()))

    @property
    def rigidObjectsDict(self) -> Dict[str,RigidObjectModel]:
        """
        A frozen dictionary mapping rigid object names to RigidObjectModel instances.
        """
        return types.MappingProxyType({r.name:r for r in self.rigidObjects})

    @property
    def terrains(self) -> Sequence[TerrainModel]:
        """
        A tuple of all rigid objects in the world.
        """
        return tuple(self.terrain(i) for i in range(self.numTerrains()))

    @property
    def terrainsDict(self) -> Dict[str,TerrainModel]:
        """
        A frozen dictionary mapping terrain names to TerrainModel instances.
        """
        return types.MappingProxyType({r.name:r for r in self.terrains})

    def entity(self, id_or_name: Union[int,str]) -> Union[RobotModel,RobotModelLink,RigidObjectModel,TerrainModel]:
        """
        Retrieves the entity with the given ID or name.  Raises KeyError if it
        does not exist.
        """
        if isinstance(id_or_name, int):
            id = id_or_name
            try:
                t = self.entityType(id)
            except Exception:
                raise KeyError("No entity with ID {}".format(id))
            n = self.getName(id_or_name)
            if t == 'robot':
                return self.robot(n)
            elif t == 'robotLink':
                for r in self.robots:
                    l = r.link(n)
                    if l.index >= 0:
                        return l
                raise RuntimeError("No link with name {} any robot?".format(n))
            elif t == 'rigidObject':
                return self.rigidObject(n)
            elif t == 'terrain':
                return self.terrain(n)
            else:
                raise KeyError("Entity with ID {} is of unknown type {}".format(id,t))
        else:
            assert isinstance(id_or_name, str),"entity must be provide an integer ID or string name"
            for r in self.robots:
                if r.name == id_or_name:
                    return r
                for l in r.links:
                    if l.name == id_or_name:
                        return l
            for o in self.rigidObjects:
                if o.name == id_or_name:
                    return o
            for t in self.terrains:
                if t.name == id_or_name:
                    return t
            raise KeyError("No entity with name {}".format(id_or_name))


# Register WorldModel in _robotsim:
_robotsim.WorldModel_swigregister(WorldModel)

class IKObjective(object):
    r"""


    A class defining an inverse kinematic target. Either a link on a robot can take
    on a fixed position/orientation in the world frame, or a relative
    position/orientation to another frame.  

    The positionScale and orientationScale attributes scale the solver's residual
    vector. This affects whether the convergence tolerance is met, and also controls
    the emphasis on each objective / component when the objective cannot be reached.
    By default these are both 1.  

    C++ includes: robotik.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(IKObjective self) -> IKObjective
        __init__(IKObjective self, IKObjective arg2) -> IKObjective


        With no arguments, constructs a blank IKObjective. Given an IKObjective, acts as
        a copy constructor.  

        """
        _robotsim.IKObjective_swiginit(self, _robotsim.new_IKObjective(*args))

    def copy(self) -> "IKObjective":
        r"""
        copy(IKObjective self) -> IKObjective


        Copy constructor.  

        """
        return _robotsim.IKObjective_copy(self)

    def link(self) -> "int":
        r"""
        link(IKObjective self) -> int


        The index of the robot link that is constrained.  

        """
        return _robotsim.IKObjective_link(self)

    def destLink(self) -> "int":
        r"""
        destLink(IKObjective self) -> int


        The index of the destination link, or -1 if fixed to the world.  

        """
        return _robotsim.IKObjective_destLink(self)

    def numPosDims(self) -> "int":
        r"""
        numPosDims(IKObjective self) -> int


        Returns: The number of position dimensions constrained (0-3)  

        """
        return _robotsim.IKObjective_numPosDims(self)

    def numRotDims(self) -> "int":
        r"""
        numRotDims(IKObjective self) -> int


        Returns: The number of rotation dimensions constrained (0-3)  

        """
        return _robotsim.IKObjective_numRotDims(self)

    def setFixedPoint(self, link: "int", plocal: "double const [3]", pworld: "double const [3]") -> "void":
        r"""
        setFixedPoint(IKObjective self, int link, double const [3] plocal, double const [3] pworld)


        Sets a fixed-point constraint.  

        """
        return _robotsim.IKObjective_setFixedPoint(self, link, plocal, pworld)

    def setFixedPoints(self, link: "int", plocals: "PyObject *", pworlds: "PyObject *") -> "void":
        r"""
        setFixedPoints(IKObjective self, int link, PyObject * plocals, PyObject * pworlds)


        Sets a multiple fixed-point constraint.  

        """
        return _robotsim.IKObjective_setFixedPoints(self, link, plocals, pworlds)

    def _setFixedTransform(self, link: "int", R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _setFixedTransform(IKObjective self, int link, double const [9] R, double const [3] t)


        Sets a fixed-transform constraint (R,t)  

        """
        return _robotsim.IKObjective__setFixedTransform(self, link, R, t)

    def setRelativePoint(self, link1: "int", link2: "int", p1: "double const [3]", p2: "double const [3]") -> "void":
        r"""
        setRelativePoint(IKObjective self, int link1, int link2, double const [3] p1, double const [3] p2)


        Sets a fixed-point constraint relative to link2.  

        """
        return _robotsim.IKObjective_setRelativePoint(self, link1, link2, p1, p2)

    def setRelativePoints(self, link1: "int", link2: "int", p1s: "PyObject *", p2s: "PyObject *") -> "void":
        r"""
        setRelativePoints(IKObjective self, int link1, int link2, PyObject * p1s, PyObject * p2s)


        Sets a multiple fixed-point constraint relative to link2.  

        """
        return _robotsim.IKObjective_setRelativePoints(self, link1, link2, p1s, p2s)

    def _setRelativeTransform(self, link: "int", linkTgt: "int", R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _setRelativeTransform(IKObjective self, int link, int linkTgt, double const [9] R, double const [3] t)


        Sets a fixed-transform constraint (R,t) relative to linkTgt.  

        """
        return _robotsim.IKObjective__setRelativeTransform(self, link, linkTgt, R, t)

    def setLinks(self, link: "int", link2: "int"=-1) -> "void":
        r"""
        setLinks(IKObjective self, int link, int link2=-1)


        Manual construction.  

        """
        return _robotsim.IKObjective_setLinks(self, link, link2)

    def setFreePosition(self) -> "void":
        r"""
        setFreePosition(IKObjective self)


        Deprecated: use setFreePosConstraint.  

        """
        return _robotsim.IKObjective_setFreePosition(self)

    def setFreePosConstraint(self) -> "void":
        r"""
        setFreePosConstraint(IKObjective self)


        Manual: Sets a free position constraint.  

        """
        return _robotsim.IKObjective_setFreePosConstraint(self)

    def setFixedPosConstraint(self, tlocal: "double const [3]", tworld: "double const [3]") -> "void":
        r"""
        setFixedPosConstraint(IKObjective self, double const [3] tlocal, double const [3] tworld)


        Manual: Sets a fixed position constraint.  

        """
        return _robotsim.IKObjective_setFixedPosConstraint(self, tlocal, tworld)

    def setPlanarPosConstraint(self, tlocal: "double const [3]", nworld: "double const [3]", oworld: "double") -> "void":
        r"""
        setPlanarPosConstraint(IKObjective self, double const [3] tlocal, double const [3] nworld, double oworld)


        Manual: Sets a planar position constraint nworld^T T(link)*tlocal + oworld = 0.  

        """
        return _robotsim.IKObjective_setPlanarPosConstraint(self, tlocal, nworld, oworld)

    def setLinearPosConstraint(self, tlocal: "double const [3]", sworld: "double const [3]", dworld: "double const [3]") -> "void":
        r"""
        setLinearPosConstraint(IKObjective self, double const [3] tlocal, double const [3] sworld, double const [3] dworld)


        Manual: Sets a linear position constraint T(link)*tlocal = sworld + u*dworld for
        some real value u.  

        """
        return _robotsim.IKObjective_setLinearPosConstraint(self, tlocal, sworld, dworld)

    def setFreeRotConstraint(self) -> "void":
        r"""
        setFreeRotConstraint(IKObjective self)


        Manual: Sets a free rotation constraint.  

        """
        return _robotsim.IKObjective_setFreeRotConstraint(self)

    def setFixedRotConstraint(self, R: "double const [9]") -> "void":
        r"""
        setFixedRotConstraint(IKObjective self, double const [9] R)


        Manual: Sets a fixed rotation constraint.  

        """
        return _robotsim.IKObjective_setFixedRotConstraint(self, R)

    def setAxialRotConstraint(self, alocal: "double const [3]", aworld: "double const [3]") -> "void":
        r"""
        setAxialRotConstraint(IKObjective self, double const [3] alocal, double const [3] aworld)


        Manual: Sets an axial rotation constraint.  

        """
        return _robotsim.IKObjective_setAxialRotConstraint(self, alocal, aworld)

    def getPosition(self) -> "void":
        r"""
        getPosition(IKObjective self)


        Returns the local and global position of the position constraint.  

        Return type: Tuple[Vector3,Vector3]  

        """
        return _robotsim.IKObjective_getPosition(self)

    def getPositionDirection(self) -> "void":
        r"""
        getPositionDirection(IKObjective self)


        For linear and planar constraints, returns the direction.  

        Return type: Vector3  

        """
        return _robotsim.IKObjective_getPositionDirection(self)

    def getRotation(self) -> "void":
        r"""
        getRotation(IKObjective self)


        For fixed rotation constraints, returns the orientation.  

        Return type: Matrix3  

        """
        return _robotsim.IKObjective_getRotation(self)

    def getRotationAxis(self) -> "void":
        r"""
        getRotationAxis(IKObjective self)


        For axis rotation constraints, returns the local and global axes.  

        Return type: Tuple[Vector3,Vector3]  

        """
        return _robotsim.IKObjective_getRotationAxis(self)

    def getTransform(self) -> "void":
        r"""
        getTransform(IKObjective self)


        For fixed-transform constraints, returns the transform (R,t)  

        Return type: RigidTransform  

        """
        return _robotsim.IKObjective_getTransform(self)

    def _transform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _transform(IKObjective self, double const [9] R, double const [3] t)


        Transforms the target position/rotation of this IK constraint by transform (R,t)  

        """
        return _robotsim.IKObjective__transform(self, R, t)

    def _transformLocal(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _transformLocal(IKObjective self, double const [9] R, double const [3] t)


        Transforms the local position/rotation of this IK constraint by transform (R,t)  

        """
        return _robotsim.IKObjective__transformLocal(self, R, t)

    def _matchDestination(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _matchDestination(IKObjective self, double const [9] R, double const [3] t)


        Sets the destination coordinates of this constraint to fit the given target
        transform. In other words, if (R,t) is the current link transform, this sets the
        destination position / orientation so that this objective has zero error. The
        current position/rotation constraint types are kept.  

        """
        return _robotsim.IKObjective__matchDestination(self, R, t)

    def _closestMatch(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _closestMatch(IKObjective self, double const [9] R, double const [3] t)


        Gets the transform T that's closest to the transform (R,t) and that satisfies
        the IK goal's constraints.  

        Return type: RigidTransform  

        """
        return _robotsim.IKObjective__closestMatch(self, R, t)

    def sampleTransform(self) -> "void":
        r"""
        sampleTransform(IKObjective self)


        Returns a transformation (R,t) from link relative to link2, sampled at random
        from the space of transforms that satisfies the objective obj.  

        Return type: RigidTransform  

        """
        return _robotsim.IKObjective_sampleTransform(self)

    def loadString(self, str: "char const *") -> "bool":
        r"""
        loadString(IKObjective self, char const * str) -> bool


        Loads the objective from a Klamp't-native formatted string. For a more readable
        but verbose format, try the JSON IO routines :meth:`klampt.io.loader.to_json` /
        :meth:`klampt.io.loader.from_json`  

        """
        return _robotsim.IKObjective_loadString(self, str)

    def saveString(self) -> "std::string":
        r"""
        saveString(IKObjective self) -> std::string


        Saves the objective to a Klamp't-native formatted string. For a more readable
        but verbose format, try the JSON IO routines :meth:`klampt.io.loader.to_json` /
        :meth:`klampt.io.loader.from_json`  

        """
        return _robotsim.IKObjective_saveString(self)
    goal = property(_robotsim.IKObjective_goal_get, _robotsim.IKObjective_goal_set, doc=r"""goal : IKGoal""")
    positionScale = property(_robotsim.IKObjective_positionScale_get, _robotsim.IKObjective_positionScale_set, doc=r"""positionScale : float""")
    rotationScale = property(_robotsim.IKObjective_rotationScale_get, _robotsim.IKObjective_rotationScale_set, doc=r"""rotationScale : float""")

    def setFixedTransform(self, link : int, R_or_T : Union[Matrix3,RigidTransform], t :Optional[Vector3] = None):
        """
        Sets the objective to constrain a link's frame to a fixed transform.

        Args:
            link (int): the index of the link to constrain.
            R_or_T (Matrix3 or RigidTransform): the rotation matrix or rigid transform
                to set.
            t (Vector3, optional): if R_or_T is a Matrix3, this is the translation
                vector to set.
        """
        if t is not None:
            self._setFixedTransform(link,R_or_T,t)
        else:
            self._setFixedTransform(link,*R_or_T);

    def setRelativeTransform(self, link : int, linkTgt, R_or_T : Union[Matrix3,RigidTransform], t :Optional[Vector3] = None):
        """
        Sets a fixed-transform constraint (R,t) relative to linkTgt

        Args:
            link (int): the index of the link to constrain.
            linkTgt (int): the index of the target link that the transform is relative to.
            R_or_T (Matrix3 or RigidTransform): the rotation matrix or rigid transform
                to set.
            t (Vector3, optional): if R_or_T is a Matrix3, this is the translation
                vector to set.
        """
        if t is not None:
            self._setRelativeTransform(link,R_or_T,t)
        else:
            self._setRelativeTransform(link,*R_or_T);

    def transform(self, R_or_T : Union[Matrix3,RigidTransform], t :Optional[Vector3] = None):
        """Transforms the target position/rotation of this IK constraint by transform (R,t)."""
        if t is not None:
            self._transform(R_or_T,t)
        else:
            self._transform(*R_or_T);

    def transformLocal(self, R_or_T : Union[Matrix3,RigidTransform], t :Optional[Vector3] = None):
        """Transforms the local position/rotation of this IK constraint by transform (R,t)"""
        if t is not None:
            self._transformLocal(R_or_T,t)
        else:
            self._transformLocal(*R_or_T);

    def matchDestination(self, R_or_T : Union[Matrix3,RigidTransform], t :Optional[Vector3] = None):
        """Sets the destination coordinates of this constraint to fit the given target transform.

        In other words, if (R,t) is the current link transform, this sets the 
        destination position / orientation so that this objective has zero error.  The
        current position/rotation constraint types are kept.
        """
        if t is not None:
            self._matchDestination(R_or_T,t)
        else:
            self._matchDestination(*R_or_T);

    def closestMatch(self, R_or_T : Union[Matrix3,RigidTransform], t :Optional[Vector3] = None) -> RigidTransform:
        """
        Gets the transform T that is closest to the transform (R,t) and 
        that satisfies the constraints of the IK goal.
        """
        if t is not None:
            return self._closestMatch(R_or_T,t)
        else:
            return self._closestMatch(*R_or_T);

    def __reduce__(self):
        from klampt.io import loader
        jsonobj = loader.to_json(self,'IKObjective')
        return (loader.from_json,(jsonobj,'IKObjective'))

    __swig_destroy__ = _robotsim.delete_IKObjective

# Register IKObjective in _robotsim:
_robotsim.IKObjective_swigregister(IKObjective)

class IKSolver(object):
    r"""


    An inverse kinematics solver based on the Newton-Raphson technique.  

    Typical calling pattern is::  

        s = IKSolver(robot)
        s.add(objective1)
        s.add(objective2)
        s.setMaxIters(100)
        s.setTolerance(1e-4)
        res = s.solve()
        if res:
            print("IK solution:",robot.getConfig(),"found in",
                s.lastSolveIters(),"iterations, residual",s.getResidual())
        else:
            print("IK failed:",robot.getConfig(),"found in",
                s.lastSolveIters(),"iterations, residual",s.getResidual())


    C++ includes: robotik.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(IKSolver self, RobotModel robot) -> IKSolver
        __init__(IKSolver self, IKSolver solver) -> IKSolver


        Initializes an IK solver. Given a RobotModel, an empty solver is created. Given
        an IK solver, acts as a copy constructor.  

        """
        _robotsim.IKSolver_swiginit(self, _robotsim.new_IKSolver(*args))

    def copy(self) -> "IKSolver":
        r"""
        copy(IKSolver self) -> IKSolver


        Copy constructor.  

        """
        return _robotsim.IKSolver_copy(self)

    def add(self, objective: "IKObjective") -> "void":
        r"""
        add(IKSolver self, IKObjective objective)


        Adds a new simultaneous objective.  

        """
        return _robotsim.IKSolver_add(self, objective)

    def set(self, i: "int", objective: "IKObjective") -> "void":
        r"""
        set(IKSolver self, int i, IKObjective objective)


        Assigns an existing objective added by add.  

        """
        return _robotsim.IKSolver_set(self, i, objective)

    def addSecondary(self, objective: "IKObjective") -> "void":
        r"""
        addSecondary(IKSolver self, IKObjective objective)


        Adds a new objective to the secondary objectives list.  

        """
        return _robotsim.IKSolver_addSecondary(self, objective)

    def setSecondary(self, i: "int", objective: "IKObjective") -> "void":
        r"""
        setSecondary(IKSolver self, int i, IKObjective objective)


        Assigns an existing objective added by addsecondary.  

        """
        return _robotsim.IKSolver_setSecondary(self, i, objective)

    def clear(self) -> "void":
        r"""
        clear(IKSolver self)


        Clears objectives.  

        """
        return _robotsim.IKSolver_clear(self)

    def setMaxIters(self, iters: "int") -> "void":
        r"""
        setMaxIters(IKSolver self, int iters)


        Sets the max # of iterations (default 100)  

        """
        return _robotsim.IKSolver_setMaxIters(self, iters)

    def getMaxIters(self) -> "int":
        r"""
        getMaxIters(IKSolver self) -> int


        Returns the max # of iterations.  

        """
        return _robotsim.IKSolver_getMaxIters(self)

    def setTolerance(self, res: "double") -> "void":
        r"""
        setTolerance(IKSolver self, double res)


        Sets the constraint solve tolerance (default 1e-3)  

        """
        return _robotsim.IKSolver_setTolerance(self, res)

    def getTolerance(self) -> "double":
        r"""
        getTolerance(IKSolver self) -> double


        Returns the constraint solve tolerance.  

        """
        return _robotsim.IKSolver_getTolerance(self)

    def setActiveDofs(self, active: "intVector") -> "void":
        r"""
        setActiveDofs(IKSolver self, intVector active)


        Sets the active degrees of freedom.  

        """
        return _robotsim.IKSolver_setActiveDofs(self, active)

    def getActiveDofs(self) -> "void":
        r"""
        getActiveDofs(IKSolver self)


        Returns the active degrees of freedom.  

        Return type: List[int]  

        """
        return _robotsim.IKSolver_getActiveDofs(self)

    def setJointLimits(self, qmin: "doubleVector", qmax: "doubleVector") -> "void":
        r"""
        setJointLimits(IKSolver self, doubleVector qmin, doubleVector qmax)


        Sets limits on the robot's configuration. If empty, this turns off joint limits.  

        """
        return _robotsim.IKSolver_setJointLimits(self, qmin, qmax)

    def getJointLimits(self) -> "void":
        r"""
        getJointLimits(IKSolver self)


        Returns the limits on the robot's configuration (by default this is the robot's
        joint limits.  

        Return type: Tuple[Vector,Vector]  

        """
        return _robotsim.IKSolver_getJointLimits(self)

    def setBiasConfig(self, biasConfig: "doubleVector") -> "void":
        r"""
        setBiasConfig(IKSolver self, doubleVector biasConfig)


        Biases the solver to approach a given configuration. Setting an empty vector
        clears the bias term.  

        """
        return _robotsim.IKSolver_setBiasConfig(self, biasConfig)

    def getBiasConfig(self) -> "void":
        r"""
        getBiasConfig(IKSolver self)


        Returns the solvers' bias configuration.  

        Return type: Vector  

        """
        return _robotsim.IKSolver_getBiasConfig(self)

    def isSolved(self) -> "bool":
        r"""
        isSolved(IKSolver self) -> bool


        Returns True if the current configuration residual is less than tol.  

        """
        return _robotsim.IKSolver_isSolved(self)

    def getResidual(self) -> "void":
        r"""
        getResidual(IKSolver self)


        Returns the vector describing the error of the objective at the current
        configuration.  

        Return type: Vector  

        """
        return _robotsim.IKSolver_getResidual(self)

    def getJacobian(self) -> "void":
        r"""
        getJacobian(IKSolver self)


        Computes the matrix describing the instantaneous derivative of the objective
        with respect to the active Dofs.  

        Return type: np.ndarray  

        """
        return _robotsim.IKSolver_getJacobian(self)

    def getSecondaryResidual(self) -> "void":
        r"""
        getSecondaryResidual(IKSolver self)


        Returns the vector describing the error of the secondary objective at the
        current configuration.  

        Return type: Vector  

        """
        return _robotsim.IKSolver_getSecondaryResidual(self)

    def solve(self) -> "bool":
        r"""
        solve(IKSolver self) -> bool


        Tries to find a configuration that satifies all simultaneous objectives up to
        the desired tolerance.  

        All of the primary and the secondary objectives are solved simultaneously.  

        Returns:  

            True if x converged.


        """
        return _robotsim.IKSolver_solve(self)

    def minimize(self, *args) -> "bool":
        r"""
        minimize(IKSolver self) -> bool
        minimize(IKSolver self, PyObject * secondary_objective, PyObject * secondary_objective_grad) -> bool


        Tries to find a configuration that satifies all simultaneous objectives up to
        the desired tolerance or minimizes the residual.  

        The relation to `:func:solve` is that `solve` uses a root-finding method that
        tries indirectly to minimize the residual, but it may stall out when the
        objectives are infeasible.  

        If secondary objectives are specified, this tries to minimize them once the
        primary objectives are satisfied, i.e., it will minimize on the solution
        manifold of the primary constraints.  

        There are two flavors of secondary objectives. If no arguments are given, then
        any constraints added via `addSecondary` will have their residuals minimized.  

        If the user provides a pair of functions `(f,grad)`, then a custom objective is
        specified. Here, `f(q)` is the secondary objective to minimize and `grad(q)` its
        gradient. This will override the secondary objectives added via `addSecondary`.
        Specifically, q is a function of all robot DOFs, and `grad(q)` should return a
        list or tuple of length `len(q)``.  

        .. note::  

            The minimization will occur only over the current active DOFs, which will
            include default active DOFs for secondary objectives.  

        Args: secondary_objective (callable): a function `f(q)->float` that should be
        minimized. secondary_objective_grad (callable): a function `grad(q)->`sequence
        of length `len(q)` giving the gradient of `f` at `q`.  

        Returns:  

            True if x converged on the primary objectives.


        """
        return _robotsim.IKSolver_minimize(self, *args)

    def lastSolveIters(self) -> "int":
        r"""
        lastSolveIters(IKSolver self) -> int


        Returns the number of Newton-Raphson iterations used in the last solve() call or
        the number of Quasi-Newton iterations used in the last minimize() call.  

        """
        return _robotsim.IKSolver_lastSolveIters(self)

    def sampleInitial(self) -> "void":
        r"""
        sampleInitial(IKSolver self)


        Samples an initial random configuration. More initial configurations can be
        sampled in case the prior configs lead to local minima.  

        """
        return _robotsim.IKSolver_sampleInitial(self)
    robot = property(_robotsim.IKSolver_robot_get, _robotsim.IKSolver_robot_set, doc=r"""robot : RobotModel""")
    objectives = property(_robotsim.IKSolver_objectives_get, _robotsim.IKSolver_objectives_set, doc=r"""objectives : std::vector<(IKObjective,std::allocator<(IKObjective)>)>""")
    secondary_objectives = property(_robotsim.IKSolver_secondary_objectives_get, _robotsim.IKSolver_secondary_objectives_set, doc=r"""secondary_objectives : std::vector<(IKObjective,std::allocator<(IKObjective)>)>""")
    tol = property(_robotsim.IKSolver_tol_get, _robotsim.IKSolver_tol_set, doc=r"""tol : double""")
    maxIters = property(_robotsim.IKSolver_maxIters_get, _robotsim.IKSolver_maxIters_set, doc=r"""maxIters : int""")
    activeDofs = property(_robotsim.IKSolver_activeDofs_get, _robotsim.IKSolver_activeDofs_set, doc=r"""activeDofs : std::vector<(int,std::allocator<(int)>)>""")
    useJointLimits = property(_robotsim.IKSolver_useJointLimits_get, _robotsim.IKSolver_useJointLimits_set, doc=r"""useJointLimits : bool""")
    qmin = property(_robotsim.IKSolver_qmin_get, _robotsim.IKSolver_qmin_set, doc=r"""qmin : std::vector<(double,std::allocator<(double)>)>""")
    qmax = property(_robotsim.IKSolver_qmax_get, _robotsim.IKSolver_qmax_set, doc=r"""qmax : std::vector<(double,std::allocator<(double)>)>""")
    biasConfig = property(_robotsim.IKSolver_biasConfig_get, _robotsim.IKSolver_biasConfig_set, doc=r"""biasConfig : std::vector<(double,std::allocator<(double)>)>""")
    lastIters = property(_robotsim.IKSolver_lastIters_get, _robotsim.IKSolver_lastIters_set, doc=r"""lastIters : int""")
    __swig_destroy__ = _robotsim.delete_IKSolver

# Register IKSolver in _robotsim:
_robotsim.IKSolver_swigregister(IKSolver)

class GeneralizedIKObjective(object):
    r"""


    An inverse kinematics target for matching points between two robots and/or
    objects.  

    The objects are chosen upon construction, so the following are valid:  

    *   GeneralizedIKObjective(a) is an objective for object a to be constrained
        relative to the environment.  
    *   GeneralizedIKObjective(a,b) is an objective for object a to be constrained
        relative to b. Here a and b can be links on any robot or rigid objects.  

    Once constructed, call setPoint, setPoints, or setTransform to specify the
    nature of the constraint.  

    C++ includes: robotik.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(GeneralizedIKObjective self, GeneralizedIKObjective obj) -> GeneralizedIKObjective
        __init__(GeneralizedIKObjective self, RobotModelLink link) -> GeneralizedIKObjective
        __init__(GeneralizedIKObjective self, RigidObjectModel obj) -> GeneralizedIKObjective
        __init__(GeneralizedIKObjective self, RobotModelLink link, RobotModelLink link2) -> GeneralizedIKObjective
        __init__(GeneralizedIKObjective self, RobotModelLink link, RigidObjectModel obj2) -> GeneralizedIKObjective
        __init__(GeneralizedIKObjective self, RigidObjectModel obj, RobotModelLink link2) -> GeneralizedIKObjective
        __init__(GeneralizedIKObjective self, RigidObjectModel obj, RigidObjectModel obj2) -> GeneralizedIKObjective


        """
        _robotsim.GeneralizedIKObjective_swiginit(self, _robotsim.new_GeneralizedIKObjective(*args))

    def setPoint(self, p1: "double const [3]", p2: "double const [3]") -> "void":
        r"""
        setPoint(GeneralizedIKObjective self, double const [3] p1, double const [3] p2)


        """
        return _robotsim.GeneralizedIKObjective_setPoint(self, p1, p2)

    def setPoints(self, p1s: "PyObject *", p2s: "PyObject *") -> "void":
        r"""
        setPoints(GeneralizedIKObjective self, PyObject * p1s, PyObject * p2s)


        """
        return _robotsim.GeneralizedIKObjective_setPoints(self, p1s, p2s)

    def setTransform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        setTransform(GeneralizedIKObjective self, double const [9] R, double const [3] t)


        """
        return _robotsim.GeneralizedIKObjective_setTransform(self, R, t)

    def sampleTransform(self) -> "void":
        r"""
        sampleTransform(GeneralizedIKObjective self)


        Returns a transformation (R,t) from link relative to link2, sampled at random
        from the space of transforms that satisfies the objective obj.  

        """
        return _robotsim.GeneralizedIKObjective_sampleTransform(self)
    link1 = property(_robotsim.GeneralizedIKObjective_link1_get, _robotsim.GeneralizedIKObjective_link1_set, doc=r"""link1 : RobotModelLink""")
    link2 = property(_robotsim.GeneralizedIKObjective_link2_get, _robotsim.GeneralizedIKObjective_link2_set, doc=r"""link2 : RobotModelLink""")
    obj1 = property(_robotsim.GeneralizedIKObjective_obj1_get, _robotsim.GeneralizedIKObjective_obj1_set, doc=r"""obj1 : RigidObjectModel""")
    obj2 = property(_robotsim.GeneralizedIKObjective_obj2_get, _robotsim.GeneralizedIKObjective_obj2_set, doc=r"""obj2 : RigidObjectModel""")
    isObj1 = property(_robotsim.GeneralizedIKObjective_isObj1_get, _robotsim.GeneralizedIKObjective_isObj1_set, doc=r"""isObj1 : bool""")
    isObj2 = property(_robotsim.GeneralizedIKObjective_isObj2_get, _robotsim.GeneralizedIKObjective_isObj2_set, doc=r"""isObj2 : bool""")
    goal = property(_robotsim.GeneralizedIKObjective_goal_get, _robotsim.GeneralizedIKObjective_goal_set, doc=r"""goal : IKGoal""")
    __swig_destroy__ = _robotsim.delete_GeneralizedIKObjective

# Register GeneralizedIKObjective in _robotsim:
_robotsim.GeneralizedIKObjective_swigregister(GeneralizedIKObjective)

class GeneralizedIKSolver(object):
    r"""


    An inverse kinematics solver between multiple robots and/or objects. NOT
    IMPLEMENTED YET.  

    C++ includes: robotik.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, world: "WorldModel"):
        r"""
        __init__(GeneralizedIKSolver self, WorldModel world) -> GeneralizedIKSolver


        """
        _robotsim.GeneralizedIKSolver_swiginit(self, _robotsim.new_GeneralizedIKSolver(world))

    def add(self, objective: "GeneralizedIKObjective") -> "void":
        r"""
        add(GeneralizedIKSolver self, GeneralizedIKObjective objective)


        Adds a new simultaneous objective.  

        """
        return _robotsim.GeneralizedIKSolver_add(self, objective)

    def setMaxIters(self, iters: "int") -> "void":
        r"""
        setMaxIters(GeneralizedIKSolver self, int iters)


        Sets the max # of iterations (default 100)  

        """
        return _robotsim.GeneralizedIKSolver_setMaxIters(self, iters)

    def setTolerance(self, res: "double") -> "void":
        r"""
        setTolerance(GeneralizedIKSolver self, double res)


        Sets the constraint solve tolerance (default 1e-3)  

        """
        return _robotsim.GeneralizedIKSolver_setTolerance(self, res)

    def getResidual(self) -> "void":
        r"""
        getResidual(GeneralizedIKSolver self)


        Returns a vector describing the error of the objective.  

        """
        return _robotsim.GeneralizedIKSolver_getResidual(self)

    def getJacobian(self) -> "void":
        r"""
        getJacobian(GeneralizedIKSolver self)


        Returns a matrix describing the instantaneous derivative of the objective with
        respect to the active parameters.  

        """
        return _robotsim.GeneralizedIKSolver_getJacobian(self)

    def solve(self) -> "PyObject *":
        r"""
        solve(GeneralizedIKSolver self) -> PyObject *


        Tries to find a configuration that satifies all simultaneous objectives up to
        the desired tolerance.  

        Returns: res,iters (pair of bool, int): res indicates whether x converged, and
        iters is the number of iterations used.  

        """
        return _robotsim.GeneralizedIKSolver_solve(self)

    def sampleInitial(self) -> "void":
        r"""
        sampleInitial(GeneralizedIKSolver self)


        Samples an initial random configuration.  

        """
        return _robotsim.GeneralizedIKSolver_sampleInitial(self)
    world = property(_robotsim.GeneralizedIKSolver_world_get, _robotsim.GeneralizedIKSolver_world_set, doc=r"""world : WorldModel""")
    objectives = property(_robotsim.GeneralizedIKSolver_objectives_get, _robotsim.GeneralizedIKSolver_objectives_set, doc=r"""objectives : std::vector<(GeneralizedIKObjective,std::allocator<(GeneralizedIKObjective)>)>""")
    tol = property(_robotsim.GeneralizedIKSolver_tol_get, _robotsim.GeneralizedIKSolver_tol_set, doc=r"""tol : double""")
    maxIters = property(_robotsim.GeneralizedIKSolver_maxIters_get, _robotsim.GeneralizedIKSolver_maxIters_set, doc=r"""maxIters : int""")
    useJointLimits = property(_robotsim.GeneralizedIKSolver_useJointLimits_get, _robotsim.GeneralizedIKSolver_useJointLimits_set, doc=r"""useJointLimits : bool""")
    __swig_destroy__ = _robotsim.delete_GeneralizedIKSolver

# Register GeneralizedIKSolver in _robotsim:
_robotsim.GeneralizedIKSolver_swigregister(GeneralizedIKSolver)

class SimRobotController(object):
    r"""


    A controller for a simulated robot.  

    By default a SimRobotController has three possible modes:  

    *   Motion queue + PID mode: the controller has an internal trajectory queue
        that may be added to and modified. This queue supports piecewise linear
        interpolation, cubic interpolation, and time-optimal move-to commands.  
    *   PID mode: the user controls the motor's PID setpoints directly  
    *   Torque control: the user controlls the motor torques directly.  

    The "standard" way of using this is in move-to mode which accepts a milestone
    (setMilestone) or list of milestones (repeated calls to addMilestone) and
    interpolates dynamically from the current configuration/velocity. To handle
    disturbances, a PID loop is run automatically at the controller's specified
    rate.  

    To get finer-grained control over the motion queue's timing, you may use the
    setLinear/setCubic/addLinear/addCubic functions. In these functions it is up to
    the user to respect velocity, acceleration, and torque limits.  

    Whether in motion queue or PID mode, the constants of the PID loop are initially
    set in the robot file. You can programmatically tune these via the setPIDGains
    function.  

    Arbitrary trajectories can be tracked by using setVelocity over short time
    steps. Force controllers can be implemented using setTorque, again using short
    time steps.  

    If the setVelocity, setTorque, or setPID command are called, the motion queue
    behavior will be completely overridden. To reset back to motion queue control,
    setManualMode(False) must be called first.  

    Individual joints cannot be addressed with mixed motion queue mode and
    torque/PID mode. However, you can mix PID and torque mode between different
    joints with a workaround::  


       # setup by zeroing out PID constants for torque controlled joints
       pid_joint_indices = [...]
       torque_joint_indices = [...] # complement of pid_joint_indices
       kp,ki,kp = controller.getPIDGains()
       for i in torque_joint_indices:  #turn off PID gains here
          kp[i] = ki[i] = kp[i] = 0

       # to send PID command (qcmd,dqcmd) and torque commands tcmd, use
       # a PID command with feedforward torques.  First we build a whole-robot
       # command:
       qcmd_whole = [0]*controller.model().numLinks()
       dqcmd_whole = [0]*controller.model().numLinks()
       tcmd_whole = [0]*controller.model().numLinks()
       for i,k in enumerate(pid_joint_indices):
           qcmd_whole[k],dqcmd_whole[i] = qcmd[i],dqcmd[i]
       for i,k in enumerate(torque_joint_indices):
           tcmd_whole[k] = tcmd[i]
       # Then we send it to the controller
       controller.setPIDCommand(qcmd_whole,dqcmd_whole,tcmd_whole)



    C++ includes: robotsim.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(SimRobotController self) -> SimRobotController


        """
        _robotsim.SimRobotController_swiginit(self, _robotsim.new_SimRobotController())
    __swig_destroy__ = _robotsim.delete_SimRobotController

    def model(self) -> "RobotModel":
        r"""
        model(SimRobotController self) -> RobotModel


        Retrieves the robot model associated with this controller.  

        """
        return _robotsim.SimRobotController_model(self)

    def setRate(self, dt: "double") -> "void":
        r"""
        setRate(SimRobotController self, double dt)


        Sets the current feedback control rate, in s.  

        """
        return _robotsim.SimRobotController_setRate(self, dt)

    def getRate(self) -> "double":
        r"""
        getRate(SimRobotController self) -> double


        Returns The current feedback control rate, in s.  

        """
        return _robotsim.SimRobotController_getRate(self)

    def getCommandedConfig(self) -> "void":
        r"""
        getCommandedConfig(SimRobotController self)


        Returns The current commanded configuration (size model().numLinks())  

        """
        return _robotsim.SimRobotController_getCommandedConfig(self)

    def getCommandedVelocity(self) -> "void":
        r"""
        getCommandedVelocity(SimRobotController self)


        Returns The current commanded velocity (size model().numLinks())  

        """
        return _robotsim.SimRobotController_getCommandedVelocity(self)

    def getCommandedTorque(self) -> "void":
        r"""
        getCommandedTorque(SimRobotController self)


        Returns The current commanded (feedforward) torque (size model().numDrivers())  

        """
        return _robotsim.SimRobotController_getCommandedTorque(self)

    def getSensedConfig(self) -> "void":
        r"""
        getSensedConfig(SimRobotController self)


        Returns The current "sensed" configuration from the simulator (size
        model().numLinks())  

        """
        return _robotsim.SimRobotController_getSensedConfig(self)

    def getSensedVelocity(self) -> "void":
        r"""
        getSensedVelocity(SimRobotController self)


        Returns The current "sensed" velocity from the simulator (size
        model().numLinks())  

        """
        return _robotsim.SimRobotController_getSensedVelocity(self)

    def getSensedTorque(self) -> "void":
        r"""
        getSensedTorque(SimRobotController self)


        Returns The current "sensed" (feedback) torque from the simulator. (size
        model().numDrivers())  

        Note: a default robot doesn't have a torque sensor, so this will be 0  

        """
        return _robotsim.SimRobotController_getSensedTorque(self)

    def numSensors(self) -> "int":
        r"""
        numSensors(SimRobotController self) -> int


        Returns the number of sensors.  

        """
        return _robotsim.SimRobotController_numSensors(self)

    def _sensor(self, *args) -> "SensorModel":
        r"""
        _sensor(SimRobotController self, int index) -> SensorModel
        _sensor(SimRobotController self, char const * name) -> SensorModel


        """
        return _robotsim.SimRobotController__sensor(self, *args)

    def addSensor(self, name: "char const *", type: "char const *") -> "SensorModel":
        r"""
        addSensor(SimRobotController self, char const * name, char const * type) -> SensorModel


        Adds a new sensor with a given name and type.  

        Returns:  

            The new sensor.


        """
        return _robotsim.SimRobotController_addSensor(self, name, type)

    def commands(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        commands(SimRobotController self) -> stringVector


        Returns a custom command list.  

        """
        return _robotsim.SimRobotController_commands(self)

    def sendCommand(self, name: "std::string const &", args: "std::string const &") -> "bool":
        r"""
        sendCommand(SimRobotController self, std::string const & name, std::string const & args) -> bool


        Sends a custom string command to the controller.  

        """
        return _robotsim.SimRobotController_sendCommand(self, name, args)

    def settings(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        settings(SimRobotController self) -> stringVector


        Returns all valid setting names.  

        """
        return _robotsim.SimRobotController_settings(self)

    def getSetting(self, name: "std::string const &") -> "std::string":
        r"""
        getSetting(SimRobotController self, std::string const & name) -> std::string


        Returns a setting of the controller.  

        """
        return _robotsim.SimRobotController_getSetting(self, name)

    def setSetting(self, name: "std::string const &", val: "std::string const &") -> "bool":
        r"""
        setSetting(SimRobotController self, std::string const & name, std::string const & val) -> bool


        Sets a setting of the controller.  

        """
        return _robotsim.SimRobotController_setSetting(self, name, val)

    def setMilestone(self, *args) -> "void":
        r"""
        setMilestone(SimRobotController self, doubleVector q)
        setMilestone(SimRobotController self, doubleVector q, doubleVector dq)


        Uses a dynamic interpolant to get from the current state to the desired
        milestone (with optional ending velocity). This interpolant is time-optimal with
        respect to the velocity and acceleration bounds.  

        """
        return _robotsim.SimRobotController_setMilestone(self, *args)

    def addMilestone(self, *args) -> "void":
        r"""
        addMilestone(SimRobotController self, doubleVector q)
        addMilestone(SimRobotController self, doubleVector q, doubleVector dq)


        Same as setMilestone, but appends an interpolant onto an internal motion queue
        starting at the current queued end state.  

        """
        return _robotsim.SimRobotController_addMilestone(self, *args)

    def addMilestoneLinear(self, q: "doubleVector") -> "void":
        r"""
        addMilestoneLinear(SimRobotController self, doubleVector q)


        Same as addMilestone, but enforces that the motion should move along a straight-
        line joint-space path.  

        """
        return _robotsim.SimRobotController_addMilestoneLinear(self, q)

    def setLinear(self, q: "doubleVector", dt: "double") -> "void":
        r"""
        setLinear(SimRobotController self, doubleVector q, double dt)


        Uses linear interpolation to get from the current configuration to the desired
        configuration after time dt.  

        q has size model().numLinks(). dt must be > 0.  

        """
        return _robotsim.SimRobotController_setLinear(self, q, dt)

    def setCubic(self, q: "doubleVector", v: "doubleVector", dt: "double") -> "void":
        r"""
        setCubic(SimRobotController self, doubleVector q, doubleVector v, double dt)


        Uses cubic (Hermite) interpolation to get from the current
        configuration/velocity to the desired configuration/velocity after time dt.  

        q and v have size model().numLinks(). dt must be > 0.  

        """
        return _robotsim.SimRobotController_setCubic(self, q, v, dt)

    def addLinear(self, q: "doubleVector", dt: "double") -> "void":
        r"""
        addLinear(SimRobotController self, doubleVector q, double dt)


        Same as setLinear but appends an interpolant onto the motion queue.  

        """
        return _robotsim.SimRobotController_addLinear(self, q, dt)

    def addCubic(self, q: "doubleVector", v: "doubleVector", dt: "double") -> "void":
        r"""
        addCubic(SimRobotController self, doubleVector q, doubleVector v, double dt)


        Same as setCubic but appends an interpolant onto the motion queue.  

        """
        return _robotsim.SimRobotController_addCubic(self, q, v, dt)

    def remainingTime(self) -> "double":
        r"""
        remainingTime(SimRobotController self) -> double


        Returns the remaining duration of the motion queue.  

        """
        return _robotsim.SimRobotController_remainingTime(self)

    def setVelocity(self, dq: "doubleVector", dt: "double") -> "void":
        r"""
        setVelocity(SimRobotController self, doubleVector dq, double dt)


        Sets a rate controller from the current commanded config to move at rate dq for
        time dt > 0. dq has size model().numLinks()  

        """
        return _robotsim.SimRobotController_setVelocity(self, dq, dt)

    def setTorque(self, t: "doubleVector") -> "void":
        r"""
        setTorque(SimRobotController self, doubleVector t)


        Sets a torque command controller. t can have size model().numDrivers() or
        model().numLinks().  

        """
        return _robotsim.SimRobotController_setTorque(self, t)

    def setPIDCommand(self, *args) -> "void":
        r"""
        setPIDCommand(SimRobotController self, doubleVector qdes, doubleVector dqdes)
        setPIDCommand(SimRobotController self, doubleVector qdes, doubleVector dqdes, doubleVector tfeedforward)


        Sets a PID command controller. If tfeedforward is provided, it is the
        feedforward torque vector.  

        """
        return _robotsim.SimRobotController_setPIDCommand(self, *args)

    def setManualMode(self, enabled: "bool") -> "void":
        r"""
        setManualMode(SimRobotController self, bool enabled)


        Turns on/off manual mode, if either the setTorque or setPID command were
        previously set.  

        """
        return _robotsim.SimRobotController_setManualMode(self, enabled)

    def getControlType(self) -> "std::string":
        r"""
        getControlType(SimRobotController self) -> std::string


        Returns the control type for the active controller.  

        Returns:  

            One of

            - unknown
            - off
            - torque
            - PID
            - locked_velocity


        """
        return _robotsim.SimRobotController_getControlType(self)

    def setPIDGains(self, kP: "doubleVector", kI: "doubleVector", kD: "doubleVector") -> "void":
        r"""
        setPIDGains(SimRobotController self, doubleVector kP, doubleVector kI, doubleVector kD)


        Sets the PID gains. Arguments have size model().numDrivers().  

        """
        return _robotsim.SimRobotController_setPIDGains(self, kP, kI, kD)

    def getPIDGains(self) -> "void":
        r"""
        getPIDGains(SimRobotController self)


        Returns the PID gains for the PID controller.  

        """
        return _robotsim.SimRobotController_getPIDGains(self)
    index = property(_robotsim.SimRobotController_index_get, _robotsim.SimRobotController_index_set, doc=r"""index : int""")
    sim = property(_robotsim.SimRobotController_sim_get, _robotsim.SimRobotController_sim_set, doc=r"""sim : p.Simulator""")
    controller = property(_robotsim.SimRobotController_controller_get, _robotsim.SimRobotController_controller_set, doc=r"""controller : p.Klampt::SimRobotController""")

    def sensor(self, index_or_name : Union[int,str]) -> SensorModel:
       """
       Retrieves the sensor with the given index or name.  A KeyError is
       raised if it does not exist.
       """
       res = self._sensor(index_or_name)
       if len(res.type) == 0:
           raise KeyError("Invalid sensor name: {}".format(index_or_name))
       return res

    @property
    def sensors(self) -> Sequence[SensorModel]:
        """
        A tuple of all sensors on the robot.
        """
        return tuple(self.sensor(i) for i in range(self.numSensors()))

    @property
    def sensorsDict(self) -> Dict[str,SensorModel]:
        """
        A frozen dictionary mapping sensor names to SensorModel instances.
        """
        return types.MappingProxyType({s.name:s for s in self.sensors})

    rate = property(getRate, setRate)
    """The controller's update rate in Hz."""


# Register SimRobotController in _robotsim:
_robotsim.SimRobotController_swigregister(SimRobotController)

class SimBody(object):
    r"""


    A reference to a rigid body inside a Simulator (either a RigidObjectModel,
    TerrainModel, or a link of a RobotModel).  

    Can use this class to directly apply forces to or control positions / velocities
    of objects in the simulation.  

    .. note::  

        All changes are applied in the current simulation substep, not the duration
        provided to Simulation.simulate().  If you need fine-grained control,
        make sure to call Simulation.simulate() with time steps equal to the value
        provided to Simulation.setSimStep() (this is 0.001s by default).  Or, use
        a hook from :class:`~klampt.sim.simulation.SimpleSimulator`.
     .. note::  

        The transform of the body is centered at the *object's center of mass*
        rather than the object's reference frame given in the RobotModelLink or
        RigidObjectModel.  The object's reference frame is retrieved/set by
        getObjectTransform()/setObjectTransform().


    C++ includes: robotsim.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getID(self) -> "int":
        r"""
        getID(SimBody self) -> int


        Returns the object ID that this body associated with.  

        """
        return _robotsim.SimBody_getID(self)

    def enable(self, enabled: "bool"=True) -> "void":
        r"""
        enable(SimBody self, bool enabled=True)


        Sets the simulation of this body on/off.  

        """
        return _robotsim.SimBody_enable(self, enabled)

    def isEnabled(self) -> "bool":
        r"""
        isEnabled(SimBody self) -> bool


        Returns true if this body is being simulated.  

        """
        return _robotsim.SimBody_isEnabled(self)

    def enableDynamics(self, enabled: "bool"=True) -> "void":
        r"""
        enableDynamics(SimBody self, bool enabled=True)


        Turns dynamic simulation of the body on/off. If false, velocities will simply be
        integrated forward, and forces will not affect velocity i.e., it will be pure
        kinematic simulation.  

        """
        return _robotsim.SimBody_enableDynamics(self, enabled)

    def isDynamicsEnabled(self) -> "bool":
        r"""
        isDynamicsEnabled(SimBody self) -> bool


        """
        return _robotsim.SimBody_isDynamicsEnabled(self)

    def applyWrench(self, f: "double const [3]", t: "double const [3]") -> "void":
        r"""
        applyWrench(SimBody self, double const [3] f, double const [3] t)


        Applies a force and torque about the COM over the duration of the next
        Simulator.simulate(t) call.  

        """
        return _robotsim.SimBody_applyWrench(self, f, t)

    def applyForceAtPoint(self, f: "double const [3]", pworld: "double const [3]") -> "void":
        r"""
        applyForceAtPoint(SimBody self, double const [3] f, double const [3] pworld)


        Applies a force at a given point (in world coordinates) over the duration of the
        next Simulator.simulate(t) call.  

        """
        return _robotsim.SimBody_applyForceAtPoint(self, f, pworld)

    def applyForceAtCOMLocalPoint(self, f: "double const [3]", plocal: "double const [3]") -> "void":
        r"""
        applyForceAtCOMLocalPoint(SimBody self, double const [3] f, double const [3] plocal)


        Applies a force at a given point (in local center-of-mass-centered coordinates)
        over the duration of the next Simulator.simulate(t) call.  

        """
        return _robotsim.SimBody_applyForceAtCOMLocalPoint(self, f, plocal)

    def applyForceAtObjectLocalPoint(self, f: "double const [3]", plocal: "double const [3]") -> "void":
        r"""
        applyForceAtObjectLocalPoint(SimBody self, double const [3] f, double const [3] plocal)


        Applies a force at a given point (in local object-centered coordinates) over the
        duration of the next Simulator.simulate(t) call.  

        """
        return _robotsim.SimBody_applyForceAtObjectLocalPoint(self, f, plocal)

    def applyForceAtLocalPoint(self, f: "double const [3]", plocal_com: "double const [3]") -> "void":
        r"""
        applyForceAtLocalPoint(SimBody self, double const [3] f, double const [3] plocal_com)


        Deprecated: use applyForceAtCOMLocalPoint instead to match old behavior.  

        """
        return _robotsim.SimBody_applyForceAtLocalPoint(self, f, plocal_com)

    def _setTransform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _setTransform(SimBody self, double const [9] R, double const [3] t)


        Sets the body's transformation at the current simulation time step (in center-
        of-mass centered coordinates).  

        """
        return _robotsim.SimBody__setTransform(self, R, t)

    def getTransform(self) -> "void":
        r"""
        getTransform(SimBody self)


        Gets the body's transformation at the current simulation time step (in center-
        of-mass centered coordinates).  

        Return type: RigidTransform  

        """
        return _robotsim.SimBody_getTransform(self)

    def _setObjectTransform(self, R: "double const [9]", t: "double const [3]") -> "void":
        r"""
        _setObjectTransform(SimBody self, double const [9] R, double const [3] t)


        Sets the body's transformation at the current simulation time step (in object-
        native coordinates)  

        """
        return _robotsim.SimBody__setObjectTransform(self, R, t)

    def getObjectTransform(self) -> "void":
        r"""
        getObjectTransform(SimBody self)


        Gets the body's transformation at the current simulation time step (in object-
        native coordinates).  

        Return type: RigidTransform  

        """
        return _robotsim.SimBody_getObjectTransform(self)

    def setVelocity(self, w: "double const [3]", v: "double const [3]") -> "void":
        r"""
        setVelocity(SimBody self, double const [3] w, double const [3] v)


        Sets the angular velocity and translational velocity (of the COM) at the current
        simulation time step.  

        """
        return _robotsim.SimBody_setVelocity(self, w, v)

    def getVelocity(self) -> "void":
        r"""
        getVelocity(SimBody self)


        Returns the angular velocity and translational velocity (of the COM)  

        Return type: Tuple[Vector3,Vector3]  

        """
        return _robotsim.SimBody_getVelocity(self)

    def setObjectVelocity(self, w: "double const [3]", v: "double const [3]") -> "void":
        r"""
        setObjectVelocity(SimBody self, double const [3] w, double const [3] v)


        Sets the angular velocity and translational velocity (of the object origin) at
        the current simulation time step.  

        """
        return _robotsim.SimBody_setObjectVelocity(self, w, v)

    def getObjectVelocity(self) -> "void":
        r"""
        getObjectVelocity(SimBody self)


        Returns the angular velocity and translational velocity (of the object origin)  

        Return type: Tuple[Vector3,Vector3]  

        """
        return _robotsim.SimBody_getObjectVelocity(self)

    def setCollisionPadding(self, padding: "double") -> "void":
        r"""
        setCollisionPadding(SimBody self, double padding)


        Sets the collision padding used for contact generation. At 0 padding the
        simulation will be unstable for triangle mesh and point cloud geometries. A
        larger value is useful to maintain simulation stability for thin or soft
        objects. Default is 0.0025.  

        """
        return _robotsim.SimBody_setCollisionPadding(self, padding)

    def getCollisionPadding(self) -> "double":
        r"""
        getCollisionPadding(SimBody self) -> double


        """
        return _robotsim.SimBody_getCollisionPadding(self)

    def setCollisionPreshrink(self, shrinkVisualization: "bool"=False) -> "void":
        r"""
        setCollisionPreshrink(SimBody self, bool shrinkVisualization=False)


        If set, preshrinks the geometry so that the padded geometry better matches the
        original mesh. If shrinkVisualization=true, the underlying mesh is also shrunk
        (helps debug simulation artifacts due to preshrink)  

        """
        return _robotsim.SimBody_setCollisionPreshrink(self, shrinkVisualization)

    def getSurface(self) -> "ContactParameters":
        r"""
        getSurface(SimBody self) -> ContactParameters


        Gets (a copy of) the surface properties.  

        """
        return _robotsim.SimBody_getSurface(self)

    def setSurface(self, params: "ContactParameters") -> "void":
        r"""
        setSurface(SimBody self, ContactParameters params)


        Sets the surface properties.  

        """
        return _robotsim.SimBody_setSurface(self, params)
    sim = property(_robotsim.SimBody_sim_get, _robotsim.SimBody_sim_set, doc=r"""sim : p.Simulator""")
    objectID = property(_robotsim.SimBody_objectID_get, _robotsim.SimBody_objectID_set, doc=r"""objectID : int""")
    geometry = property(_robotsim.SimBody_geometry_get, _robotsim.SimBody_geometry_set, doc=r"""geometry : p.Klampt::ODEGeometry""")
    body = property(_robotsim.SimBody_body_get, _robotsim.SimBody_body_set, doc=r"""body : dBodyID""")

    def setTransform(self, R_or_T: Union[Matrix3, RigidTransform], t: Optional[Vector3] = None):
        """
        Sets the body's transformation at the current simulation time step
        (in center-of-mass centered coordinates).
        """
        if t is not None:
            self._setTransform(R_or_T, t)
        else:
            self._setTransform(*R_or_T)

    def setObjectTransform(self, R_or_T: Union[Matrix3, RigidTransform], t: Optional[Vector3] = None):
        """
        Sets the body's transformation at the current simulation time step
        (in object-native coordinates).
        """
        if t is not None:
            self._setObjectTransform(R_or_T, t)
        else:
            self._setObjectTransform(*R_or_T)



    def __init__(self):
        r"""
        __init__(SimBody self) -> SimBody


        A reference to a rigid body inside a Simulator (either a RigidObjectModel,
        TerrainModel, or a link of a RobotModel).  

        Can use this class to directly apply forces to or control positions / velocities
        of objects in the simulation.  

        .. note::  

            All changes are applied in the current simulation substep, not the duration
            provided to Simulation.simulate().  If you need fine-grained control,
            make sure to call Simulation.simulate() with time steps equal to the value
            provided to Simulation.setSimStep() (this is 0.001s by default).  Or, use
            a hook from :class:`~klampt.sim.simulation.SimpleSimulator`.
         .. note::  

            The transform of the body is centered at the *object's center of mass*
            rather than the object's reference frame given in the RobotModelLink or
            RigidObjectModel.  The object's reference frame is retrieved/set by
            getObjectTransform()/setObjectTransform().


        C++ includes: robotsim.h

        """
        _robotsim.SimBody_swiginit(self, _robotsim.new_SimBody())
    __swig_destroy__ = _robotsim.delete_SimBody

# Register SimBody in _robotsim:
_robotsim.SimBody_swigregister(SimBody)

class SimJoint(object):
    r"""


    An interface to ODE's hinge and slider joints. You may use this to create custom
    objects, e.g., drawers, doors, cabinets, etc. It can also be used to attach
    objects together, e.g., an object to a robot's gripper.  

    C++ includes: robotsim.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(SimJoint self) -> SimJoint


        """
        _robotsim.SimJoint_swiginit(self, _robotsim.new_SimJoint())
    __swig_destroy__ = _robotsim.delete_SimJoint

    def makeHinge(self, *args) -> "void":
        r"""
        makeHinge(SimJoint self, SimBody a, SimBody b, double const [3] pt, double const [3] axis)
        makeHinge(SimJoint self, SimBody a, double const [3] pt, double const [3] axis)


        """
        return _robotsim.SimJoint_makeHinge(self, *args)

    def makeSlider(self, *args) -> "void":
        r"""
        makeSlider(SimJoint self, SimBody a, SimBody b, double const [3] axis)
        makeSlider(SimJoint self, SimBody a, double const [3] axis)


        """
        return _robotsim.SimJoint_makeSlider(self, *args)

    def makeFixed(self, a: "SimBody", b: "SimBody") -> "void":
        r"""
        makeFixed(SimJoint self, SimBody a, SimBody b)


        Creates a fixed joint between `a` and `b`. (There's no method to fix a to the
        world; just call a.enableDynamics(False))  

        """
        return _robotsim.SimJoint_makeFixed(self, a, b)

    def destroy(self) -> "void":
        r"""
        destroy(SimJoint self)


        Removes the joint from the simulation.  

        """
        return _robotsim.SimJoint_destroy(self)

    def setLimits(self, min: "double", max: "double") -> "void":
        r"""
        setLimits(SimJoint self, double min, double max)


        Sets the joint limits, relative to the initial configuration of the bodies.
        Units are in radians for hinges and meters for sliders.  

        """
        return _robotsim.SimJoint_setLimits(self, min, max)

    def setFriction(self, friction: "double") -> "void":
        r"""
        setFriction(SimJoint self, double friction)


        Sets the (dry) friction of the joint.  

        """
        return _robotsim.SimJoint_setFriction(self, friction)

    def setVelocity(self, vel: "double", fmax: "double") -> "void":
        r"""
        setVelocity(SimJoint self, double vel, double fmax)


        Locks velocity of the joint, up to force fmax. Can't be used with setFriction.  

        """
        return _robotsim.SimJoint_setVelocity(self, vel, fmax)

    def addForce(self, force: "double") -> "void":
        r"""
        addForce(SimJoint self, double force)


        Adds a torque for the hinge joint and a force for a slider joint.  

        """
        return _robotsim.SimJoint_addForce(self, force)
    type = property(_robotsim.SimJoint_type_get, _robotsim.SimJoint_type_set, doc=r"""type : int""")
    a = property(_robotsim.SimJoint_a_get, _robotsim.SimJoint_a_set, doc=r"""a : p.q(const).SimBody""")
    b = property(_robotsim.SimJoint_b_get, _robotsim.SimJoint_b_set, doc=r"""b : p.q(const).SimBody""")
    joint = property(_robotsim.SimJoint_joint_get, _robotsim.SimJoint_joint_set, doc=r"""joint : dJointID""")

# Register SimJoint in _robotsim:
_robotsim.SimJoint_swigregister(SimJoint)

class Simulator(object):
    r"""


    A dynamics simulator for a WorldModel.  

    C++ includes: robotsim.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    STATUS_NORMAL = _robotsim.Simulator_STATUS_NORMAL
    
    STATUS_ADAPTIVE_TIME_STEPPING = _robotsim.Simulator_STATUS_ADAPTIVE_TIME_STEPPING
    
    STATUS_CONTACT_UNRELIABLE = _robotsim.Simulator_STATUS_CONTACT_UNRELIABLE
    
    STATUS_UNSTABLE = _robotsim.Simulator_STATUS_UNSTABLE
    
    STATUS_ERROR = _robotsim.Simulator_STATUS_ERROR
    

    def __init__(self, model: "WorldModel"):
        r"""
        __init__(Simulator self, WorldModel model) -> Simulator


        Constructs the simulator from a WorldModel. If the WorldModel was loaded from an
        XML file, then the simulation setup is loaded from it.  

        """
        _robotsim.Simulator_swiginit(self, _robotsim.new_Simulator(model))
    __swig_destroy__ = _robotsim.delete_Simulator

    def reset(self) -> "void":
        r"""
        reset(Simulator self)


        Resets to the initial state (same as setState(initialState))  

        """
        return _robotsim.Simulator_reset(self)

    def getStatus(self) -> "int":
        r"""
        getStatus(Simulator self) -> int


        Returns an indicator code for the simulator status.  

        Returns:  

            One of the STATUS_X flags.  (Technically, this returns the *worst* status
            over the last simulate() call)


        """
        return _robotsim.Simulator_getStatus(self)

    def getStatusString(self, s: "int"=-1) -> "std::string":
        r"""
        getStatusString(Simulator self, int s=-1) -> std::string


        Returns a string indicating the simulator's status. If s is provided and >= 0,
        this function maps the indicator code s to a string.  

        """
        return _robotsim.Simulator_getStatusString(self, s)

    def checkObjectOverlap(self) -> "void":
        r"""
        checkObjectOverlap(Simulator self)


        Checks if any objects are overlapping.  

        Returns:  

            A pair of lists of integers, giving the pairs of object ids that
            are overlapping.
         Return type: Tuple[list,list]  

        """
        return _robotsim.Simulator_checkObjectOverlap(self)

    def getState(self) -> "std::string":
        r"""
        getState(Simulator self) -> std::string


        Gets the current simulation state, including controller parameters, etc.  

        Returns:  

            A Base64 string representing the binary data for the state


        """
        return _robotsim.Simulator_getState(self)

    def setState(self, str: "std::string const &") -> "void":
        r"""
        setState(Simulator self, std::string const & str)


        Sets the current simulation state from a Base64 string returned by a prior
        getState call.  

        """
        return _robotsim.Simulator_setState(self, str)

    def simulate(self, t: "double") -> "void":
        r"""
        simulate(Simulator self, double t)


        Advances the simulation by time t, and updates the world model from the
        simulation state.  

        """
        return _robotsim.Simulator_simulate(self, t)

    def fakeSimulate(self, t: "double") -> "void":
        r"""
        fakeSimulate(Simulator self, double t)


        Advances a faked simulation by time t, and updates the world model from the
        faked simulation state.  

        """
        return _robotsim.Simulator_fakeSimulate(self, t)

    def getTime(self) -> "double":
        r"""
        getTime(Simulator self) -> double


        Returns the simulation time.  

        """
        return _robotsim.Simulator_getTime(self)

    def updateWorld(self) -> "void":
        r"""
        updateWorld(Simulator self)


        Updates the world model from the current simulation state. This only needs to be
        called if you change the world model and want to revert back to the simulation
        state.  

        """
        return _robotsim.Simulator_updateWorld(self)

    def getActualConfig(self, robot: "int") -> "void":
        r"""
        getActualConfig(Simulator self, int robot)


        Returns the current actual configuration of the robot from the simulator.  

        Return type: Vector  

        """
        return _robotsim.Simulator_getActualConfig(self, robot)

    def getActualVelocity(self, robot: "int") -> "void":
        r"""
        getActualVelocity(Simulator self, int robot)


        Returns the current actual velocity of the robot from the simulator.  

        Return type: Vector  

        """
        return _robotsim.Simulator_getActualVelocity(self, robot)

    def getActualTorque(self, robot: "int") -> "void":
        r"""
        getActualTorque(Simulator self, int robot)


        Returns the current actual torques on the robot's drivers from the simulator.  

        Return type: Vector  

        """
        return _robotsim.Simulator_getActualTorque(self, robot)

    def enableContactFeedback(self, obj1: "int", obj2: "int") -> "void":
        r"""
        enableContactFeedback(Simulator self, int obj1, int obj2)


        Call this to enable contact feedback between the two objects (arguments are
        indexes returned by object.getID()). Contact feedback has a small overhead so
        you may want to do this selectively. This must be called before using inContact,
        getContacts, getContactForces, contactForce, contactTorque, hadContact,
        hadSeparation, hadPenetration, and meanContactForce.  

        """
        return _robotsim.Simulator_enableContactFeedback(self, obj1, obj2)

    def enableContactFeedbackAll(self) -> "void":
        r"""
        enableContactFeedbackAll(Simulator self)


        Call this to enable contact feedback between all pairs of objects. Contact
        feedback has a small overhead so you may want to do this selectively.  

        """
        return _robotsim.Simulator_enableContactFeedbackAll(self)

    def inContact(self, aid: "int", bid: "int") -> "bool":
        r"""
        inContact(Simulator self, int aid, int bid) -> bool


        Returns true if the objects (indexes returned by object.getID()) are in contact
        on the current time step. You can set bid=-1 to tell if object `a` is in contact
        with any object.  

        """
        return _robotsim.Simulator_inContact(self, aid, bid)

    def getContacts(self, aid: "int", bid: "int") -> "void":
        r"""
        getContacts(Simulator self, int aid, int bid)


        Returns the nx7 list of contacts (x,n,kFriction) at the last time step. Normals
        point into object `a`. Each contact point (x,n,kFriction) is represented as a
        7-element vector.  

        Return type: np.ndarray  

        """
        return _robotsim.Simulator_getContacts(self, aid, bid)

    def getContactForces(self, aid: "int", bid: "int") -> "void":
        r"""
        getContactForces(Simulator self, int aid, int bid)


        Returns the list of contact forces on object a at the last time step. Result is
        an nx3 array.  

        Return type: np.ndarray  

        """
        return _robotsim.Simulator_getContactForces(self, aid, bid)

    def contactForce(self, aid: "int", bid: "int") -> "void":
        r"""
        contactForce(Simulator self, int aid, int bid)


        Returns the contact force on object a at the last time step. You can set bid to
        -1 to get the overall contact force on object a.  

        Return type: Vector3  

        """
        return _robotsim.Simulator_contactForce(self, aid, bid)

    def contactTorque(self, aid: "int", bid: "int") -> "void":
        r"""
        contactTorque(Simulator self, int aid, int bid)


        Returns the contact force on object `a` (about `a`'s origin) at the last time
        step. You can set `bid` to -1 to get the overall contact force on object `a`.  

        Return type: Vector3  

        """
        return _robotsim.Simulator_contactTorque(self, aid, bid)

    def hadContact(self, aid: "int", bid: "int") -> "bool":
        r"""
        hadContact(Simulator self, int aid, int bid) -> bool


        Returns true if the objects had contact over the last simulate() call. You can
        set `bid` to -1 to determine if object `a` had contact with any other object.  

        """
        return _robotsim.Simulator_hadContact(self, aid, bid)

    def hadSeparation(self, aid: "int", bid: "int") -> "bool":
        r"""
        hadSeparation(Simulator self, int aid, int bid) -> bool


        Returns true if the objects had ever separated during the last simulate() call.
        You can set `bid` to -1 to determine if object `a` had no contact with any other
        object.  

        """
        return _robotsim.Simulator_hadSeparation(self, aid, bid)

    def hadPenetration(self, aid: "int", bid: "int") -> "bool":
        r"""
        hadPenetration(Simulator self, int aid, int bid) -> bool


        Returns true if the objects interpenetrated during the last simulate() call. If
        so, the simulation may lead to very inaccurate results or artifacts.  

        You can set `bid` to -1 to determine if object `a` penetrated any object, or you
        can set `aid=bid=-1` to determine whether any object is penetrating any other
        (indicating that the simulation will not be functioning properly in general).  

        """
        return _robotsim.Simulator_hadPenetration(self, aid, bid)

    def meanContactForce(self, aid: "int", bid: "int") -> "void":
        r"""
        meanContactForce(Simulator self, int aid, int bid)


        Returns the average contact force on object a over the last simulate() call.  

        Return type: Vector3  

        """
        return _robotsim.Simulator_meanContactForce(self, aid, bid)

    def controller(self, *args) -> "SimRobotController":
        r"""
        controller(Simulator self, int robot) -> SimRobotController
        controller(Simulator self, RobotModel robot) -> SimRobotController


        Returns a controller for the indicated robot, either by index or by RobotModel.  

        """
        return _robotsim.Simulator_controller(self, *args)

    def body(self, *args) -> "SimBody":
        r"""
        body(Simulator self, RobotModelLink link) -> SimBody
        body(Simulator self, RigidObjectModel object) -> SimBody
        body(Simulator self, TerrainModel terrain) -> SimBody


        Return the SimBody corresponding to the given link, rigid object, or terrain.  

        """
        return _robotsim.Simulator_body(self, *args)

    def getJointForces(self, link: "RobotModelLink") -> "void":
        r"""
        getJointForces(Simulator self, RobotModelLink link)


        Returns the joint force and torque local to the link, as would be read by a
        force-torque sensor mounted at the given link's origin.  

        Returns:  

            6 entries of the wrench (fx,fy,fz,mx,my,mz)
         Return type: Vector  

        """
        return _robotsim.Simulator_getJointForces(self, link)

    def setGravity(self, g: "double const [3]") -> "void":
        r"""
        setGravity(Simulator self, double const [3] g)


        Sets the overall gravity vector.  

        """
        return _robotsim.Simulator_setGravity(self, g)

    def setSimStep(self, dt: "double") -> "void":
        r"""
        setSimStep(Simulator self, double dt)


        Sets the internal simulation substep. Values < 0.01 are recommended.  

        """
        return _robotsim.Simulator_setSimStep(self, dt)

    def settings(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        settings(Simulator self) -> stringVector


        Returns all setting names.  

        """
        return _robotsim.Simulator_settings(self)

    def getSetting(self, name: "std::string const &") -> "std::string":
        r"""
        getSetting(Simulator self, std::string const & name) -> std::string


        Retrieves some simulation setting.  

        Valid names are:  

        *   gravity: the gravity vector (default "0 0 -9.8")  
        *   simStep: the internal simulation step (default "0.001")  
        *   autoDisable: whether to disable bodies that don't move much between time
            steps (default "0", set to "1" for many static objects)  
        *   boundaryLayerCollisions: whether to use the Klampt inflated boundaries for
            contact detection'(default "1", recommended)  
        *   rigidObjectCollisions: whether rigid objects should collide (default "1")  
        *   robotSelfCollisions: whether robots should self collide (default "0")  
        *   robotRobotCollisions: whether robots should collide with other robots
            (default "1")  
        *   adaptiveTimeStepping: whether adaptive time stepping should be used to
            improve stability. Slower but more stable. (default "1")  
        *   minimumAdaptiveTimeStep: the minimum size of an adaptive time step before
            giving up (default "1e-6")  
        *   maxContacts: max # of clustered contacts between pairs of objects (default
            "20")  
        *   clusterNormalScale: a parameter for clustering contacts (default "0.1")  
        *   errorReductionParameter: see ODE docs on ERP (default "0.95")  
        *   dampedLeastSquaresParameter: see ODE docs on CFM (default "1e-6")  
        *   instabilityConstantEnergyThreshold: parameter c0 in instability correction
            (default "1")  
        *   instabilityLinearEnergyThreshold: parameter c1 in instability correction
            (default "1.5")  
        *   instabilityMaxEnergyThreshold: parameter cmax in instability correction
            (default "100000")  
        *   instabilityPostCorrectionEnergy: kinetic energy scaling parameter if
            instability is detected (default "0.8")  

        Instability correction kicks in whenever the kinetic energy K(t) of an object
        exceeds min(c0*m + c1*K(t-dt),cmax). m is the object's mass.  

        See `Klampt/Simulation/ODESimulator.h
        <http://motion.cs.illinois.edu/software/klampt/latest/klampt_docs/classKlampt_1_1ODESimulator.html>`_
        for detailed descriptions of these parameters.  

        Returns:  

            A string encoding the data. This will need to be cast to int or
            float manually.


        """
        return _robotsim.Simulator_getSetting(self, name)

    def setSetting(self, name: "std::string const &", value: "std::string const &") -> "void":
        r"""
        setSetting(Simulator self, std::string const & name, std::string const & value)


        Sets some simulation setting. Raises an exception if the name is unknown or the
        value is of improper format.  

        """
        return _robotsim.Simulator_setSetting(self, name, value)
    index = property(_robotsim.Simulator_index_get, _robotsim.Simulator_index_set, doc=r"""index : int""")
    world = property(_robotsim.Simulator_world_get, _robotsim.Simulator_world_set, doc=r"""world : WorldModel""")
    sim = property(_robotsim.Simulator_sim_get, _robotsim.Simulator_sim_set, doc=r"""sim : p.Klampt::Simulator""")
    initialState = property(_robotsim.Simulator_initialState_get, _robotsim.Simulator_initialState_set, doc=r"""initialState : std::string""")

# Register Simulator in _robotsim:
_robotsim.Simulator_swigregister(Simulator)


def set_random_seed(seed: "int") -> "void":
    r"""
    set_random_seed(int seed)


    Sets the random seed used by the RobotModel.randomizeConfig() method and
    sampling-based motion planners.  

    """
    return _robotsim.set_random_seed(seed)

def set_log_level(level: "char const *") -> "void":
    r"""set_log_level(char const * level)"""
    return _robotsim.set_log_level(level)

def destroy() -> "void":
    r"""
    destroy()


    destroys internal data structures  

    """
    return _robotsim.destroy()

def subscribe_to_stream(*args) -> "bool":
    r"""
    subscribe_to_stream(Geometry3D g, char const * protocol, char const * name, char const * type="") -> bool


    Subscribes a Geometry3D to a stream.  

    Only ROS point clouds (PointCloud2) are supported for now. Note that you can
    also call `Geometry3D.loadFile("ros://[ROS_TOPIC]")` or
    `Geometry3D.loadFile("ros:PointCloud2//[ROS_TOPIC]")` to accomplish the same
    thing.  

    TODO: It has not yet been determined whether this interferes with Rospy, i.e.,
    klampt.io.ros.  

    Args:  

        g (Geometry3D): the geometry that will be updated
        protocol (str): only "ros" accepted for now.
        name (str): the name of the stream, i.e., ROS topic.
        type (str, optional): If provided, specifies the format of the data
            to be subscribed to. If not, tries to determine the type
            automatically.  

    Returns:  

        bool: True if successful.


    """
    return _robotsim.subscribe_to_stream(*args)

def detach_from_stream(protocol: "char const *", name: "char const *") -> "bool":
    r"""
    detach_from_stream(char const * protocol, char const * name) -> bool


    Unsubscribes from a stream previously subscribed to via
    :func:`SubscribeToStream`  

    """
    return _robotsim.detach_from_stream(protocol, name)

def process_streams(*args) -> "bool":
    r"""
    process_streams(char const * protocol="all") -> bool


    Does some processing on stream subscriptions.  

    Args:  

        protocol (str): either name the protocol to be updated, or "all" for
            updating all subscribed streams  

    Returns:  

        bool: True if any stream was updated.


    """
    return _robotsim.process_streams(*args)

def wait_for_stream(protocol: "char const *", name: "char const *", timeout: "double") -> "bool":
    r"""
    wait_for_stream(char const * protocol, char const * name, double timeout) -> bool


    Waits up to timeout seconds for an update on the given stream.  

    Returns:  

        bool: True if the stream was updated.


    """
    return _robotsim.wait_for_stream(protocol, name, timeout)

def threejs_get_scene(arg1: "WorldModel") -> "std::string":
    r"""
    threejs_get_scene(WorldModel arg1) -> std::string


    Exports the WorldModel to a JSON string ready for use in Three.js.  

    """
    return _robotsim.threejs_get_scene(arg1)

def threejs_get_transforms(arg1: "WorldModel") -> "std::string":
    r"""
    threejs_get_transforms(WorldModel arg1) -> std::string


    Exports the WorldModel to a JSON string ready for use in Three.js.  

    """
    return _robotsim.threejs_get_transforms(arg1)

def set_friction_cone_approximation_edges(numEdges: "int") -> "void":
    r"""
    set_friction_cone_approximation_edges(int numEdges)


    Globally sets the number of edges used in the friction cone approximation. The
    default value is 4.  

    """
    return _robotsim.set_friction_cone_approximation_edges(numEdges)

def force_closure(*args) -> "bool":
    r"""
    force_closure(double * np_array2) -> bool
    force_closure(doubleMatrix contactPositions, doubleMatrix frictionCones) -> bool


    Returns true if the list of contact points has force closure.  

    In the 1-argument version, each contact point is specified by a list of 7
    floats, [x,y,z,nx,ny,nz,k] where (x,y,z) is the position, (nx,ny,nz) is the
    normal, and k is the coefficient of friction.  

    The 2-argument version is a "fancy" version that allows more control over the
    constraint planes.  

    Args:  

        contacts (list of 7-float lists or tuples): the list of contacts, each
            specified as a 7-list or tuple [x,y,z,nx,ny,nz,k], with:

            - (x,y,z): the contact position
            - (nx,ny,nz): the contact normal
            - k: the coefficient of friction (>= 0)

        contactPositions (list of 3-float lists or tuples): the list of contact
            point positions.
        frictionCones (list of lists): Each item of this list specifies linear
            inequalities that must be met of the force at the corresponding
            contact point.  The item must have length k*4 where k is an integer,
            and each inequality gives the entries (ax,ay,az,b) of a constraint
            ax*fx+ay*fy+az*fz <= b that limits the contact force (fx,fy,fz) at
            the i'th contact.  Each of the k 4-tuples is laid out sequentially
            per-contact.


    """
    return _robotsim.force_closure(*args)

def force_closure_2d(*args) -> "bool":
    r"""
    force_closure_2d(double * np_array2) -> bool
    force_closure_2d(doubleMatrix contactPositions, doubleMatrix frictionCones) -> bool


    Returns true if the list of 2D contact points has force closure.  

    In the 1-argument version, each contact point is given by a list of 4 floats,
    [x,y,theta,k] where (x,y) is the position, theta is the normal angle, and k is
    the coefficient of friction  

    The 2-argument version is a "fancy" version that allows more control over the
    constraint planes.  

    Args:  

        contacts (list of 4-float lists or tuples): the list of contacts, each
            specified as a 4-list or tuple [x,y,theta,k], with:

            - (x,y): the contact position
            - theta: is the normal angle (in radians, CCW to the x axis)
            - k: the coefficient of friction (>= 0)

        contactPositions (list of 2-float lists or tuples): the list of contact
            point positions.
        frictionCones (list of lists): The i'th element in this list has length
            k*3 (for some integer k), and gives the contact force constraints
            (ax,ay,b) where ax*fx+ay*fy <= b limits the contact force (fx,fy)
            at the i'th contact. Each of the k 3-tuples is laid out sequentially
            per-contact.


    """
    return _robotsim.force_closure_2d(*args)

def com_equilibrium(*args) -> "PyObject *":
    r"""
    com_equilibrium(double * np_array2, doubleVector fext, PyObject * com) -> PyObject
    com_equilibrium(doubleMatrix contactPositions, doubleMatrix frictionCones, doubleVector fext, PyObject * com) -> PyObject *


    Tests whether the given COM com is stable for the given contacts and the given
    external force fext.  

    The 2-argument version is a "fancy" version that allows more control over the
    constraint planes.  

    Args:  

        contacts (list of 7-float lists or tuples): the list of contacts, each
            specified as a 7-list or tuple [x,y,z,nx,ny,nz,k], with:

            - (x,y,z): the contact position
            - (nx,ny,nz): the contact normal
            - k: the coefficient of friction (>= 0)

        contactPositions (list of 3-float lists or tuples): the list of contact
            point positions.
        frictionCones (list of lists): Each item of this list specifies linear
            inequalities that must be met of the force at the corresponding
            contact point.  The item must have length k*4 where k is an integer,
            and each inequality gives the entries (ax,ay,az,b) of a constraint
            ax*fx+ay*fy+az*fz <= b that limits the contact force (fx,fy,fz) at
            the i'th contact.  Each of the k 4-tuples is laid out sequentially
            per-contact.
        fext (3-tuple or list): the external force vector.
        com (3-tuple or list, or None): the center of mass coordinates.  If
            None, assumes that you want to test whether ANY COM may be in
            equilibrium for the given contacts.  

    Returns:  

        bool, None, or list: if com is given, and there are feasible
        equilibrium forces, this returns a list of 3 tuples giving
        equilibrium forces at each of the contacts. None is returned if
        no such forces exist.  

        If com = None, the result is True or False.


    """
    return _robotsim.com_equilibrium(*args)

def com_equilibrium_2d(*args) -> "PyObject *":
    r"""
    com_equilibrium_2d(double * np_array2, doubleVector fext, PyObject * com) -> PyObject
    com_equilibrium_2d(doubleMatrix contactPositions, doubleMatrix frictionCones, doubleVector fext, PyObject * com) -> PyObject *


    Tests whether the given COM com is stable for the given contacts and the given
    external force fext.  

    The 2-argument version is a "fancy" version that allows more control over the
    constraint planes.  

    Args:  

        contacts (list of 4-float lists or tuples): the list of contacts, each
            specified as a 4-list or tuple [x,y,theta,k], with:

            - (x,y,z): the contact position
            - theta: is the normal angle (in radians, CCW to the x axis)
            - k: the coefficient of friction (>= 0)

        contactPositions (list of 2-float lists or tuples): the list of contact
            point positions.
        frictionCones (list of lists): The i'th element in this list has length
            k*3 (for some integer k), and gives the contact force constraints
            (ax,ay,b) where ax*fx+ay*fy <= b limits the contact force (fx,fy)
            at the i'th contact. Each of the k 3-tuples is laid out sequentially
            per-contact.
        fext (2-tuple or list): the external force vector.
        com (2-tuple or list, or None): the center of mass coordinates.  If None,
            assumes that you want to test whether ANY COM may be in equilibrium
            for the given contacts.  

    Returns:  

        bool, None, or list: if com is given, and there are feasible
        equilibrium forces, this returns a list of 2-tuples giving
        equilibrium forces at each of the contacts. None is returned if
        no such forces exist.

        If com = None, the result is True or False.


    """
    return _robotsim.com_equilibrium_2d(*args)

def support_polygon(*args) -> "PyObject *":
    r"""
    support_polygon(double * np_array2) -> PyObject
    support_polygon(doubleMatrix contactPositions, doubleMatrix frictionCones) -> PyObject *


    Calculates the support polygon for a given set of contacts and a downward
    external force (0,0,-g).  

    In the 1-argument version, a contact point is given by a list of 7 floats,
    [x,y,z,nx,ny,nz,k] as usual. The 2-argument version is a "fancy" version that
    allows more control over the constraint planes.  

    Args:  

        contacts (list of 7-float lists or tuples): the list of contacts, each
            specified as a 7-list or tuple [x,y,z,nx,ny,nz,k], with:

            - (x,y,z): the contact position
            - (nx,ny,nz): the contact normal
            - k: the coefficient of friction (>= 0)

        contactPositions (list of 3-float lists or tuples): the list of contact
            point positions.
        frictionCones (list of lists): Each item of this list specifies linear
            inequalities that must be met of the force at the corresponding
            contact point.  The item must have length k*4 where k is an integer,
            and each inequality gives the entries (ax,ay,az,b) of a constraint
            ax*fx+ay*fy+az*fz <= b that limits the contact force (fx,fy,fz) at
            the i'th contact.  Each of the k 4-tuples is laid out sequentially
            per-contact.  

    Returns:  

        list of 3-tuples: The sorted plane boundaries of the support
        polygon. The format of a plane is (nx,ny,ofs) where (nx,ny) are the
        outward facing normals, and ofs is the offset from 0.  In other words
        to test stability of a com with x-y coordinates [x,y], you can test
        whether dot([nx,ny],[x,y]) <= ofs  for all planes.

        Hint: with numpy, you can do::

            Ab = np.array(supportPolygon(args))
            A=Ab[:,0:2]
            b=Ab[:,2]
            myComEquilibrium = lambda x: np.all(np.dot(A,x)<=b)


    """
    return _robotsim.support_polygon(*args)

def support_polygon_2d(*args) -> "PyObject *":
    r"""
    support_polygon_2d(double * np_array2) -> PyObject
    support_polygon_2d(doubleMatrix contacts, doubleMatrix frictionCones) -> PyObject *


    Calculates the support polygon (interval) for a given set of contacts and a
    downward external force (0,-g).  

    The 2-argument version is a "fancy" version that allows more control over the
    constraint planes.  

    Args:  

        contacts (list of 4-float lists or tuples): the list of contacts, each
            specified as a 4-list or tuple [x,y,theta,k], with:

            - (x,y,z): the contact position
            - theta: is the normal angle (in radians, CCW to the x axis)
            - k: the coefficient of friction (>= 0)

        contactPositions (list of 2-float lists or tuples): the list of contact
            point positions.
        frictionCones (list of lists): The i'th element in this list has length
             k*3 (for some integer k), and gives the contact force constraints
             (ax,ay,b) where ax*fx+ay*fy <= b limits the contact force (fx,fy)
             at the i'th contact. Each of the k 3-tuples is laid out sequentially
             per-contact.  

    Returns:  

        2-tuple: gives the min/max extents of the support polygon.
        If the support interval is empty, (inf,inf) is returned.


    """
    return _robotsim.support_polygon_2d(*args)

def equilibrium_torques(*args) -> "PyObject *":
    r"""
    equilibrium_torques(RobotModel robot, double * np_array2, intVector links, doubleVector fext, double norm=0) -> PyObject
    equilibrium_torques(RobotModel robot, double * np_array2, intVector links, doubleVector fext, doubleVector internalTorques, double norm=0) -> PyObject


    Solves for the torques / forces that keep the robot balanced against gravity.  

    The problem being solved is  

    :math:`min_{t,f_1,...,f_N} \|t\|_p`  

    :math:`s.t. t_{int} + G(q) = t + sum_{i=1}^N J_i(q)^T f_i`  

    :math:`|t| \leq t_{max}`  

    :math:`f_i \in FC_i`  

    Args:  

        robot (RobotModel): the robot, posed in its current configuration
        contacts (ndarray): an N x 7 array of contact points, each given as 7-lists
            [x,y,z,nx,ny,nz,kFriction]
        links (list of N ints): a list of the links on which those contact points
            lie
        fext (list of 3 floats): the external force (e.g., gravity)
        norm (double): the torque norm to minimize.  

            * If 0, minimizes the l-infinity norm (default)
            * If 1, minimizes the l-1 norm.
            * If 2, minimizes the l-2 norm (experimental, may not get good results).

        internalTorques (list of robot.numLinks() floats, optional): allows you to
            solve for dynamic situations, e.g., with coriolis forces taken into
            account.  These are added to the RHS of the torque balance equation.
            If not given, t_int is assumed to be zero.

            To use dynamics, set the robot's joint velocities dq, calculate
            then calculate the torques via robot.torquesFromAccel(ddq), and pass
            the result into internalTorques.  

    Returns:  

        pair of lists, optional: a pair (torque,force) if a solution exists,
        giving valid joint torques t and frictional contact forces (f1,...,fn).
        None is returned if no solution exists.


    """
    return _robotsim.equilibrium_torques(*args)

import warnings

def _deprecated_func(oldName,newName):
    import sys
    mod = sys.modules[__name__]
    f = getattr(mod,newName)
    def depf(*args,**kwargs):
        warnings.warn("{} will be deprecated in favor of {} in a future version of Klampt".format(oldName,newName),DeprecationWarning)
        return f(*args,**kwargs)
    depf.__doc__ = 'Deprecated in a future version of Klampt. Use {} instead'.format(newName)
    setattr(mod,oldName,depf)




