# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
Klamp't Core Python bindings
"""


from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_robotsim', [dirname(__file__)])
        except ImportError:
            import _robotsim
            return _robotsim
        if fp is not None:
            try:
                _mod = imp.load_module('_robotsim', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _robotsim = swig_import_helper()
    del swig_import_helper
else:
    import _robotsim
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _robotsim.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _robotsim.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _robotsim.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _robotsim.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _robotsim.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _robotsim.SwigPyIterator_equal(self, x)

    def copy(self):
        return _robotsim.SwigPyIterator_copy(self)

    def next(self):
        return _robotsim.SwigPyIterator_next(self)

    def __next__(self):
        return _robotsim.SwigPyIterator___next__(self)

    def previous(self):
        return _robotsim.SwigPyIterator_previous(self)

    def advance(self, n):
        return _robotsim.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _robotsim.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _robotsim.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _robotsim.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _robotsim.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _robotsim.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _robotsim.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _robotsim.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class doubleArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, doubleArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, doubleArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        this = _robotsim.new_doubleArray(nelements)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_doubleArray
    __del__ = lambda self: None

    def __getitem__(self, index):
        return _robotsim.doubleArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _robotsim.doubleArray___setitem__(self, index, value)

    def cast(self):
        return _robotsim.doubleArray_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _robotsim.doubleArray_frompointer
    if _newclass:
        frompointer = staticmethod(_robotsim.doubleArray_frompointer)
doubleArray_swigregister = _robotsim.doubleArray_swigregister
doubleArray_swigregister(doubleArray)

def doubleArray_frompointer(t):
    return _robotsim.doubleArray_frompointer(t)
doubleArray_frompointer = _robotsim.doubleArray_frompointer

class floatArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, floatArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, floatArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        this = _robotsim.new_floatArray(nelements)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_floatArray
    __del__ = lambda self: None

    def __getitem__(self, index):
        return _robotsim.floatArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _robotsim.floatArray___setitem__(self, index, value)

    def cast(self):
        return _robotsim.floatArray_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _robotsim.floatArray_frompointer
    if _newclass:
        frompointer = staticmethod(_robotsim.floatArray_frompointer)
floatArray_swigregister = _robotsim.floatArray_swigregister
floatArray_swigregister(floatArray)

def floatArray_frompointer(t):
    return _robotsim.floatArray_frompointer(t)
floatArray_frompointer = _robotsim.floatArray_frompointer

class intArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, intArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, intArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        this = _robotsim.new_intArray(nelements)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_intArray
    __del__ = lambda self: None

    def __getitem__(self, index):
        return _robotsim.intArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _robotsim.intArray___setitem__(self, index, value)

    def cast(self):
        return _robotsim.intArray_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _robotsim.intArray_frompointer
    if _newclass:
        frompointer = staticmethod(_robotsim.intArray_frompointer)
intArray_swigregister = _robotsim.intArray_swigregister
intArray_swigregister(intArray)

def intArray_frompointer(t):
    return _robotsim.intArray_frompointer(t)
intArray_frompointer = _robotsim.intArray_frompointer

class stringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, stringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, stringVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _robotsim.stringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _robotsim.stringVector___nonzero__(self)

    def __bool__(self):
        return _robotsim.stringVector___bool__(self)

    def __len__(self):
        return _robotsim.stringVector___len__(self)

    def pop(self):
        return _robotsim.stringVector_pop(self)

    def __getslice__(self, i, j):
        return _robotsim.stringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _robotsim.stringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _robotsim.stringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _robotsim.stringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _robotsim.stringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _robotsim.stringVector___setitem__(self, *args)

    def append(self, x):
        return _robotsim.stringVector_append(self, x)

    def empty(self):
        return _robotsim.stringVector_empty(self)

    def size(self):
        return _robotsim.stringVector_size(self)

    def clear(self):
        return _robotsim.stringVector_clear(self)

    def swap(self, v):
        return _robotsim.stringVector_swap(self, v)

    def get_allocator(self):
        return _robotsim.stringVector_get_allocator(self)

    def begin(self):
        return _robotsim.stringVector_begin(self)

    def end(self):
        return _robotsim.stringVector_end(self)

    def rbegin(self):
        return _robotsim.stringVector_rbegin(self)

    def rend(self):
        return _robotsim.stringVector_rend(self)

    def pop_back(self):
        return _robotsim.stringVector_pop_back(self)

    def erase(self, *args):
        return _robotsim.stringVector_erase(self, *args)

    def __init__(self, *args):
        this = _robotsim.new_stringVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _robotsim.stringVector_push_back(self, x)

    def front(self):
        return _robotsim.stringVector_front(self)

    def back(self):
        return _robotsim.stringVector_back(self)

    def assign(self, n, x):
        return _robotsim.stringVector_assign(self, n, x)

    def resize(self, *args):
        return _robotsim.stringVector_resize(self, *args)

    def insert(self, *args):
        return _robotsim.stringVector_insert(self, *args)

    def reserve(self, n):
        return _robotsim.stringVector_reserve(self, n)

    def capacity(self):
        return _robotsim.stringVector_capacity(self)
    __swig_destroy__ = _robotsim.delete_stringVector
    __del__ = lambda self: None
stringVector_swigregister = _robotsim.stringVector_swigregister
stringVector_swigregister(stringVector)

class doubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, doubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, doubleVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _robotsim.doubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _robotsim.doubleVector___nonzero__(self)

    def __bool__(self):
        return _robotsim.doubleVector___bool__(self)

    def __len__(self):
        return _robotsim.doubleVector___len__(self)

    def pop(self):
        return _robotsim.doubleVector_pop(self)

    def __getslice__(self, i, j):
        return _robotsim.doubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _robotsim.doubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _robotsim.doubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _robotsim.doubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _robotsim.doubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _robotsim.doubleVector___setitem__(self, *args)

    def append(self, x):
        return _robotsim.doubleVector_append(self, x)

    def empty(self):
        return _robotsim.doubleVector_empty(self)

    def size(self):
        return _robotsim.doubleVector_size(self)

    def clear(self):
        return _robotsim.doubleVector_clear(self)

    def swap(self, v):
        return _robotsim.doubleVector_swap(self, v)

    def get_allocator(self):
        return _robotsim.doubleVector_get_allocator(self)

    def begin(self):
        return _robotsim.doubleVector_begin(self)

    def end(self):
        return _robotsim.doubleVector_end(self)

    def rbegin(self):
        return _robotsim.doubleVector_rbegin(self)

    def rend(self):
        return _robotsim.doubleVector_rend(self)

    def pop_back(self):
        return _robotsim.doubleVector_pop_back(self)

    def erase(self, *args):
        return _robotsim.doubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _robotsim.new_doubleVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _robotsim.doubleVector_push_back(self, x)

    def front(self):
        return _robotsim.doubleVector_front(self)

    def back(self):
        return _robotsim.doubleVector_back(self)

    def assign(self, n, x):
        return _robotsim.doubleVector_assign(self, n, x)

    def resize(self, *args):
        return _robotsim.doubleVector_resize(self, *args)

    def insert(self, *args):
        return _robotsim.doubleVector_insert(self, *args)

    def reserve(self, n):
        return _robotsim.doubleVector_reserve(self, n)

    def capacity(self):
        return _robotsim.doubleVector_capacity(self)
    __swig_destroy__ = _robotsim.delete_doubleVector
    __del__ = lambda self: None
doubleVector_swigregister = _robotsim.doubleVector_swigregister
doubleVector_swigregister(doubleVector)

class floatVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, floatVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, floatVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _robotsim.floatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _robotsim.floatVector___nonzero__(self)

    def __bool__(self):
        return _robotsim.floatVector___bool__(self)

    def __len__(self):
        return _robotsim.floatVector___len__(self)

    def pop(self):
        return _robotsim.floatVector_pop(self)

    def __getslice__(self, i, j):
        return _robotsim.floatVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _robotsim.floatVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _robotsim.floatVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _robotsim.floatVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _robotsim.floatVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _robotsim.floatVector___setitem__(self, *args)

    def append(self, x):
        return _robotsim.floatVector_append(self, x)

    def empty(self):
        return _robotsim.floatVector_empty(self)

    def size(self):
        return _robotsim.floatVector_size(self)

    def clear(self):
        return _robotsim.floatVector_clear(self)

    def swap(self, v):
        return _robotsim.floatVector_swap(self, v)

    def get_allocator(self):
        return _robotsim.floatVector_get_allocator(self)

    def begin(self):
        return _robotsim.floatVector_begin(self)

    def end(self):
        return _robotsim.floatVector_end(self)

    def rbegin(self):
        return _robotsim.floatVector_rbegin(self)

    def rend(self):
        return _robotsim.floatVector_rend(self)

    def pop_back(self):
        return _robotsim.floatVector_pop_back(self)

    def erase(self, *args):
        return _robotsim.floatVector_erase(self, *args)

    def __init__(self, *args):
        this = _robotsim.new_floatVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _robotsim.floatVector_push_back(self, x)

    def front(self):
        return _robotsim.floatVector_front(self)

    def back(self):
        return _robotsim.floatVector_back(self)

    def assign(self, n, x):
        return _robotsim.floatVector_assign(self, n, x)

    def resize(self, *args):
        return _robotsim.floatVector_resize(self, *args)

    def insert(self, *args):
        return _robotsim.floatVector_insert(self, *args)

    def reserve(self, n):
        return _robotsim.floatVector_reserve(self, n)

    def capacity(self):
        return _robotsim.floatVector_capacity(self)
    __swig_destroy__ = _robotsim.delete_floatVector
    __del__ = lambda self: None
floatVector_swigregister = _robotsim.floatVector_swigregister
floatVector_swigregister(floatVector)

class intVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, intVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, intVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _robotsim.intVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _robotsim.intVector___nonzero__(self)

    def __bool__(self):
        return _robotsim.intVector___bool__(self)

    def __len__(self):
        return _robotsim.intVector___len__(self)

    def pop(self):
        return _robotsim.intVector_pop(self)

    def __getslice__(self, i, j):
        return _robotsim.intVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _robotsim.intVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _robotsim.intVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _robotsim.intVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _robotsim.intVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _robotsim.intVector___setitem__(self, *args)

    def append(self, x):
        return _robotsim.intVector_append(self, x)

    def empty(self):
        return _robotsim.intVector_empty(self)

    def size(self):
        return _robotsim.intVector_size(self)

    def clear(self):
        return _robotsim.intVector_clear(self)

    def swap(self, v):
        return _robotsim.intVector_swap(self, v)

    def get_allocator(self):
        return _robotsim.intVector_get_allocator(self)

    def begin(self):
        return _robotsim.intVector_begin(self)

    def end(self):
        return _robotsim.intVector_end(self)

    def rbegin(self):
        return _robotsim.intVector_rbegin(self)

    def rend(self):
        return _robotsim.intVector_rend(self)

    def pop_back(self):
        return _robotsim.intVector_pop_back(self)

    def erase(self, *args):
        return _robotsim.intVector_erase(self, *args)

    def __init__(self, *args):
        this = _robotsim.new_intVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _robotsim.intVector_push_back(self, x)

    def front(self):
        return _robotsim.intVector_front(self)

    def back(self):
        return _robotsim.intVector_back(self)

    def assign(self, n, x):
        return _robotsim.intVector_assign(self, n, x)

    def resize(self, *args):
        return _robotsim.intVector_resize(self, *args)

    def insert(self, *args):
        return _robotsim.intVector_insert(self, *args)

    def reserve(self, n):
        return _robotsim.intVector_reserve(self, n)

    def capacity(self):
        return _robotsim.intVector_capacity(self)
    __swig_destroy__ = _robotsim.delete_intVector
    __del__ = lambda self: None
intVector_swigregister = _robotsim.intVector_swigregister
intVector_swigregister(intVector)

class doubleMatrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, doubleMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, doubleMatrix, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _robotsim.doubleMatrix_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _robotsim.doubleMatrix___nonzero__(self)

    def __bool__(self):
        return _robotsim.doubleMatrix___bool__(self)

    def __len__(self):
        return _robotsim.doubleMatrix___len__(self)

    def pop(self):
        return _robotsim.doubleMatrix_pop(self)

    def __getslice__(self, i, j):
        return _robotsim.doubleMatrix___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _robotsim.doubleMatrix___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _robotsim.doubleMatrix___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _robotsim.doubleMatrix___delitem__(self, *args)

    def __getitem__(self, *args):
        return _robotsim.doubleMatrix___getitem__(self, *args)

    def __setitem__(self, *args):
        return _robotsim.doubleMatrix___setitem__(self, *args)

    def append(self, x):
        return _robotsim.doubleMatrix_append(self, x)

    def empty(self):
        return _robotsim.doubleMatrix_empty(self)

    def size(self):
        return _robotsim.doubleMatrix_size(self)

    def clear(self):
        return _robotsim.doubleMatrix_clear(self)

    def swap(self, v):
        return _robotsim.doubleMatrix_swap(self, v)

    def get_allocator(self):
        return _robotsim.doubleMatrix_get_allocator(self)

    def begin(self):
        return _robotsim.doubleMatrix_begin(self)

    def end(self):
        return _robotsim.doubleMatrix_end(self)

    def rbegin(self):
        return _robotsim.doubleMatrix_rbegin(self)

    def rend(self):
        return _robotsim.doubleMatrix_rend(self)

    def pop_back(self):
        return _robotsim.doubleMatrix_pop_back(self)

    def erase(self, *args):
        return _robotsim.doubleMatrix_erase(self, *args)

    def __init__(self, *args):
        this = _robotsim.new_doubleMatrix(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _robotsim.doubleMatrix_push_back(self, x)

    def front(self):
        return _robotsim.doubleMatrix_front(self)

    def back(self):
        return _robotsim.doubleMatrix_back(self)

    def assign(self, n, x):
        return _robotsim.doubleMatrix_assign(self, n, x)

    def resize(self, *args):
        return _robotsim.doubleMatrix_resize(self, *args)

    def insert(self, *args):
        return _robotsim.doubleMatrix_insert(self, *args)

    def reserve(self, n):
        return _robotsim.doubleMatrix_reserve(self, n)

    def capacity(self):
        return _robotsim.doubleMatrix_capacity(self)
    __swig_destroy__ = _robotsim.delete_doubleMatrix
    __del__ = lambda self: None
doubleMatrix_swigregister = _robotsim.doubleMatrix_swigregister
doubleMatrix_swigregister(doubleMatrix)

class TriangleMesh(_object):
    """


    A 3D indexed triangle mesh class.

    Attributes: vertices: a list of vertices, given as a flattened
    coordinate list [x1, y1, z1, x2, y2, ...]

    indices: a list of triangle vertices given as indices into the
    vertices list, i.e., [a1,b1,c2, a2,b2,c2, ...]

    C++ includes: geometry.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriangleMesh, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TriangleMesh, name)
    __repr__ = _swig_repr

    def translate(self, t):
        """
        translate(TriangleMesh self, double const [3] t)

        void
        TriangleMesh::translate(const double t[3])

        Translates all the vertices by v=v+t. 
        """
        return _robotsim.TriangleMesh_translate(self, t)


    def transform(self, R, t):
        """
        transform(TriangleMesh self, double const [9] R, double const [3] t)

        void
        TriangleMesh::transform(const double R[9], const double t[3])

        Transforms all the vertices by the rigid transform v=R*v+t. 
        """
        return _robotsim.TriangleMesh_transform(self, R, t)

    __swig_setmethods__["indices"] = _robotsim.TriangleMesh_indices_set
    __swig_getmethods__["indices"] = _robotsim.TriangleMesh_indices_get
    if _newclass:
        indices = _swig_property(_robotsim.TriangleMesh_indices_get, _robotsim.TriangleMesh_indices_set)
    __swig_setmethods__["vertices"] = _robotsim.TriangleMesh_vertices_set
    __swig_getmethods__["vertices"] = _robotsim.TriangleMesh_vertices_get
    if _newclass:
        vertices = _swig_property(_robotsim.TriangleMesh_vertices_get, _robotsim.TriangleMesh_vertices_set)

    def __init__(self):
        """
        __init__(TriangleMesh self) -> TriangleMesh



        A 3D indexed triangle mesh class.

        Attributes: vertices: a list of vertices, given as a flattened
        coordinate list [x1, y1, z1, x2, y2, ...]

        indices: a list of triangle vertices given as indices into the
        vertices list, i.e., [a1,b1,c2, a2,b2,c2, ...]

        C++ includes: geometry.h 
        """
        this = _robotsim.new_TriangleMesh()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_TriangleMesh
    __del__ = lambda self: None
TriangleMesh_swigregister = _robotsim.TriangleMesh_swigregister
TriangleMesh_swigregister(TriangleMesh)

class PointCloud(_object):
    """


    A 3D point cloud class.

    Attributes: vertices: a list of vertices, given as a list [x1, y1, z1,
    x2, y2, ... zn]

    properties: a list of vertex properties, given as a list [p11, p21,
    ..., pk1, p12, p22, ..., pk2, ... , pn1, pn2, ..., pn2] where each
    vertex has k properties. The name of each property is given by the
    propertyNames member.

    C++ includes: geometry.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PointCloud, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PointCloud, name)
    __repr__ = _swig_repr

    def translate(self, t):
        """
        translate(PointCloud self, double const [3] t)

        void
        PointCloud::translate(const double t[3])

        Translates all the points by v=v+t. 
        """
        return _robotsim.PointCloud_translate(self, t)


    def transform(self, R, t):
        """
        transform(PointCloud self, double const [9] R, double const [3] t)

        void
        PointCloud::transform(const double R[9], const double t[3])

        Transforms all the points by the rigid transform v=R*v+t. 
        """
        return _robotsim.PointCloud_transform(self, R, t)

    __swig_setmethods__["vertices"] = _robotsim.PointCloud_vertices_set
    __swig_getmethods__["vertices"] = _robotsim.PointCloud_vertices_get
    if _newclass:
        vertices = _swig_property(_robotsim.PointCloud_vertices_get, _robotsim.PointCloud_vertices_set)
    __swig_setmethods__["propertyNames"] = _robotsim.PointCloud_propertyNames_set
    __swig_getmethods__["propertyNames"] = _robotsim.PointCloud_propertyNames_get
    if _newclass:
        propertyNames = _swig_property(_robotsim.PointCloud_propertyNames_get, _robotsim.PointCloud_propertyNames_set)
    __swig_setmethods__["properties"] = _robotsim.PointCloud_properties_set
    __swig_getmethods__["properties"] = _robotsim.PointCloud_properties_get
    if _newclass:
        properties = _swig_property(_robotsim.PointCloud_properties_get, _robotsim.PointCloud_properties_set)

    def __init__(self):
        """
        __init__(PointCloud self) -> PointCloud



        A 3D point cloud class.

        Attributes: vertices: a list of vertices, given as a list [x1, y1, z1,
        x2, y2, ... zn]

        properties: a list of vertex properties, given as a list [p11, p21,
        ..., pk1, p12, p22, ..., pk2, ... , pn1, pn2, ..., pn2] where each
        vertex has k properties. The name of each property is given by the
        propertyNames member.

        C++ includes: geometry.h 
        """
        this = _robotsim.new_PointCloud()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_PointCloud
    __del__ = lambda self: None
PointCloud_swigregister = _robotsim.PointCloud_swigregister
PointCloud_swigregister(PointCloud)

class GeometricPrimitive(_object):
    """


    A geometric primitive. So far only points, spheres, segments, and
    AABBs can be constructed manually in the Python API.

    C++ includes: geometry.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeometricPrimitive, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GeometricPrimitive, name)
    __repr__ = _swig_repr

    def setPoint(self, pt):
        """
        setPoint(GeometricPrimitive self, double const [3] pt)

        void
        GeometricPrimitive::setPoint(const double pt[3]) 
        """
        return _robotsim.GeometricPrimitive_setPoint(self, pt)


    def setSphere(self, c, r):
        """
        setSphere(GeometricPrimitive self, double const [3] c, double r)

        void
        GeometricPrimitive::setSphere(const double c[3], double r) 
        """
        return _robotsim.GeometricPrimitive_setSphere(self, c, r)


    def setSegment(self, a, b):
        """
        setSegment(GeometricPrimitive self, double const [3] a, double const [3] b)

        void
        GeometricPrimitive::setSegment(const double a[3], const double b[3])

        """
        return _robotsim.GeometricPrimitive_setSegment(self, a, b)


    def setAABB(self, bmin, bmax):
        """
        setAABB(GeometricPrimitive self, double const [3] bmin, double const [3] bmax)

        void
        GeometricPrimitive::setAABB(const double bmin[3], const double
        bmax[3]) 
        """
        return _robotsim.GeometricPrimitive_setAABB(self, bmin, bmax)


    def loadString(self, str):
        """
        loadString(GeometricPrimitive self, char const * str) -> bool

        bool
        GeometricPrimitive::loadString(const char *str) 
        """
        return _robotsim.GeometricPrimitive_loadString(self, str)


    def saveString(self):
        """
        saveString(GeometricPrimitive self) -> std::string

        std::string
        GeometricPrimitive::saveString() const 
        """
        return _robotsim.GeometricPrimitive_saveString(self)

    __swig_setmethods__["type"] = _robotsim.GeometricPrimitive_type_set
    __swig_getmethods__["type"] = _robotsim.GeometricPrimitive_type_get
    if _newclass:
        type = _swig_property(_robotsim.GeometricPrimitive_type_get, _robotsim.GeometricPrimitive_type_set)
    __swig_setmethods__["properties"] = _robotsim.GeometricPrimitive_properties_set
    __swig_getmethods__["properties"] = _robotsim.GeometricPrimitive_properties_get
    if _newclass:
        properties = _swig_property(_robotsim.GeometricPrimitive_properties_get, _robotsim.GeometricPrimitive_properties_set)

    def __init__(self):
        """
        __init__(GeometricPrimitive self) -> GeometricPrimitive



        A geometric primitive. So far only points, spheres, segments, and
        AABBs can be constructed manually in the Python API.

        C++ includes: geometry.h 
        """
        this = _robotsim.new_GeometricPrimitive()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_GeometricPrimitive
    __del__ = lambda self: None
GeometricPrimitive_swigregister = _robotsim.GeometricPrimitive_swigregister
GeometricPrimitive_swigregister(GeometricPrimitive)

class Geometry3D(_object):
    """


    A three-D geometry. Can either be a reference to a world item's
    geometry, in which case modifiers change the world item's geometry, or
    it can be a standalone geometry.

    Each geometry stores a "current" transform, which is automatically
    updated for world items' geometries. The proximity queries are
    performed with respect to the transformed geometries (note the
    underlying geometry is not changed, which could be computationally
    expensive. The query is performed, however, as though they were).

    If you want to set a world item's geometry to be equal to a standalone
    geometry, use the set(rhs) function rather than the assignment (=)
    operator.

    Modifiers include any setX() functions, translate(), and transform().

    Proximity queries include collides(), withinDistance(), distance(),
    closestPoint(), and rayCast().

    Each object also has a "collision margin" which may virtually fatten
    the object, as far as proximity queries are concerned. This is useful
    for setting collision avoidance margins in motion planning. By default
    it is zero. (Note that this is NOT the same thing as simulation body
    collision padding!)

    C++ includes: geometry.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Geometry3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Geometry3D, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(Geometry3D self) -> Geometry3D

        Geometry3D::Geometry3D() 
        """
        this = _robotsim.new_Geometry3D()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_Geometry3D
    __del__ = lambda self: None

    def clone(self):
        """
        clone(Geometry3D self) -> Geometry3D

        Geometry3D
        Geometry3D::clone()

        Creates a standalone geometry from this geometry. 
        """
        return _robotsim.Geometry3D_clone(self)


    def set(self, arg2):
        """
        set(Geometry3D self, Geometry3D arg2)

        void Geometry3D::set(const
        Geometry3D &)

        Copies the geometry of the argument into this geometry. 
        """
        return _robotsim.Geometry3D_set(self, arg2)


    def isStandalone(self):
        """
        isStandalone(Geometry3D self) -> bool

        bool
        Geometry3D::isStandalone()

        Returns true if this is a standalone geometry. 
        """
        return _robotsim.Geometry3D_isStandalone(self)


    def free(self):
        """
        free(Geometry3D self)

        void Geometry3D::free()

        Frees the data associated with this geometry, if standalone. 
        """
        return _robotsim.Geometry3D_free(self)


    def type(self):
        """
        type(Geometry3D self) -> std::string

        string Geometry3D::type()

        Returns the type of geometry: TriangleMesh, PointCloud, or
        GeometricPrimitive 
        """
        return _robotsim.Geometry3D_type(self)


    def empty(self):
        """
        empty(Geometry3D self) -> bool

        bool Geometry3D::empty()

        Returns true if this has no contents. 
        """
        return _robotsim.Geometry3D_empty(self)


    def getTriangleMesh(self):
        """
        getTriangleMesh(Geometry3D self) -> TriangleMesh

        TriangleMesh
        Geometry3D::getTriangleMesh()

        Returns a TriangleMesh if this geometry is of type TriangleMesh. 
        """
        return _robotsim.Geometry3D_getTriangleMesh(self)


    def getPointCloud(self):
        """
        getPointCloud(Geometry3D self) -> PointCloud

        PointCloud
        Geometry3D::getPointCloud()

        Returns a PointCloud if this geometry is of type PointCloud. 
        """
        return _robotsim.Geometry3D_getPointCloud(self)


    def getGeometricPrimitive(self):
        """
        getGeometricPrimitive(Geometry3D self) -> GeometricPrimitive

        GeometricPrimitive Geometry3D::getGeometricPrimitive()

        Returns a GeometricPrimitive if this geometry is of type
        GeometricPrimitive. 
        """
        return _robotsim.Geometry3D_getGeometricPrimitive(self)


    def setTriangleMesh(self, arg2):
        """
        setTriangleMesh(Geometry3D self, TriangleMesh arg2)

        void
        Geometry3D::setTriangleMesh(const TriangleMesh &) 
        """
        return _robotsim.Geometry3D_setTriangleMesh(self, arg2)


    def setPointCloud(self, arg2):
        """
        setPointCloud(Geometry3D self, PointCloud arg2)

        void
        Geometry3D::setPointCloud(const PointCloud &) 
        """
        return _robotsim.Geometry3D_setPointCloud(self, arg2)


    def setGeometricPrimitive(self, arg2):
        """
        setGeometricPrimitive(Geometry3D self, GeometricPrimitive arg2)

        void
        Geometry3D::setGeometricPrimitive(const GeometricPrimitive &) 
        """
        return _robotsim.Geometry3D_setGeometricPrimitive(self, arg2)


    def loadFile(self, fn):
        """
        loadFile(Geometry3D self, char const * fn) -> bool

        bool
        Geometry3D::loadFile(const char *fn)

        Loads from file. Standard mesh types, PCD files, and .geom files are
        supported. 
        """
        return _robotsim.Geometry3D_loadFile(self, fn)


    def saveFile(self, fn):
        """
        saveFile(Geometry3D self, char const * fn) -> bool

        bool
        Geometry3D::saveFile(const char *fn)

        Saves to file. Standard mesh types, PCD files, and .geom files are
        supported. 
        """
        return _robotsim.Geometry3D_saveFile(self, fn)


    def setCurrentTransform(self, R, t):
        """
        setCurrentTransform(Geometry3D self, double const [9] R, double const [3] t)

        void
        Geometry3D::setCurrentTransform(const double R[9], const double t[3])

        Sets the current transformation (not modifying the underlying data) 
        """
        return _robotsim.Geometry3D_setCurrentTransform(self, R, t)


    def translate(self, t):
        """
        translate(Geometry3D self, double const [3] t)

        void
        Geometry3D::translate(const double t[3])

        Translates the geometry data. 
        """
        return _robotsim.Geometry3D_translate(self, t)


    def transform(self, R, t):
        """
        transform(Geometry3D self, double const [9] R, double const [3] t)

        void
        Geometry3D::transform(const double R[9], const double t[3])

        Translates/rotates the geometry data. 
        """
        return _robotsim.Geometry3D_transform(self, R, t)


    def setCollisionMargin(self, margin):
        """
        setCollisionMargin(Geometry3D self, double margin)

        void
        Geometry3D::setCollisionMargin(double margin)

        Sets a padding around the base geometry which affects the results of
        proximity queries 
        """
        return _robotsim.Geometry3D_setCollisionMargin(self, margin)


    def getCollisionMargin(self):
        """
        getCollisionMargin(Geometry3D self) -> double

        double
        Geometry3D::getCollisionMargin()

        Returns the padding around the base geometry. Default 0. 
        """
        return _robotsim.Geometry3D_getCollisionMargin(self)


    def getBB(self):
        """
        getBB(Geometry3D self)

        void
        Geometry3D::getBB(double out[3], double out2[3])

        Returns the axis-aligned bounding box of the object. 
        """
        return _robotsim.Geometry3D_getBB(self)


    def collides(self, other):
        """
        collides(Geometry3D self, Geometry3D other) -> bool

        bool
        Geometry3D::collides(const Geometry3D &other)

        Returns true if this geometry collides with the other. 
        """
        return _robotsim.Geometry3D_collides(self, other)


    def withinDistance(self, other, tol):
        """
        withinDistance(Geometry3D self, Geometry3D other, double tol) -> bool

        bool
        Geometry3D::withinDistance(const Geometry3D &other, double tol)

        Returns true if this geometry is within distance tol to other. 
        """
        return _robotsim.Geometry3D_withinDistance(self, other, tol)


    def distance(self, other, relErr=0, absErr=0):
        """
        distance(Geometry3D self, Geometry3D other, double relErr=0, double absErr=0) -> double
        distance(Geometry3D self, Geometry3D other, double relErr=0) -> double
        distance(Geometry3D self, Geometry3D other) -> double

        double
        Geometry3D::distance(const Geometry3D &other, double relErr=0, double
        absErr=0)

        Returns the distance from this geometry to the other. 
        """
        return _robotsim.Geometry3D_distance(self, other, relErr, absErr)


    def closestPoint(self, pt):
        """
        closestPoint(Geometry3D self, double const [3] pt) -> bool

        bool
        Geometry3D::closestPoint(const double pt[3], double out[3])

        Returns (success,cp) giving the closest point to the input point.
        success is false if that operation is not supported with the given
        geometry type. cp are given in world coordinates. 
        """
        return _robotsim.Geometry3D_closestPoint(self, pt)


    def rayCast(self, s, d):
        """
        rayCast(Geometry3D self, double const [3] s, double const [3] d) -> bool

        bool
        Geometry3D::rayCast(const double s[3], const double d[3], double
        out[3])

        Returns (hit,pt) where hit is true if the ray starting at s and
        pointing in direction d hits the geometry (given in world
        coordinates); pt is the hit point, in world coordinates. 
        """
        return _robotsim.Geometry3D_rayCast(self, s, d)

    __swig_setmethods__["world"] = _robotsim.Geometry3D_world_set
    __swig_getmethods__["world"] = _robotsim.Geometry3D_world_get
    if _newclass:
        world = _swig_property(_robotsim.Geometry3D_world_get, _robotsim.Geometry3D_world_set)
    __swig_setmethods__["id"] = _robotsim.Geometry3D_id_set
    __swig_getmethods__["id"] = _robotsim.Geometry3D_id_get
    if _newclass:
        id = _swig_property(_robotsim.Geometry3D_id_get, _robotsim.Geometry3D_id_set)
    __swig_setmethods__["geomPtr"] = _robotsim.Geometry3D_geomPtr_set
    __swig_getmethods__["geomPtr"] = _robotsim.Geometry3D_geomPtr_get
    if _newclass:
        geomPtr = _swig_property(_robotsim.Geometry3D_geomPtr_get, _robotsim.Geometry3D_geomPtr_set)
Geometry3D_swigregister = _robotsim.Geometry3D_swigregister
Geometry3D_swigregister(Geometry3D)

class Appearance(_object):
    """Proxy of C++ Appearance class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Appearance, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Appearance, name)
    __repr__ = _swig_repr
    ALL = _robotsim.Appearance_ALL
    VERTICES = _robotsim.Appearance_VERTICES
    EDGES = _robotsim.Appearance_EDGES
    FACES = _robotsim.Appearance_FACES

    def __init__(self):
        """__init__(Appearance self) -> Appearance"""
        this = _robotsim.new_Appearance()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_Appearance
    __del__ = lambda self: None

    def refresh(self):
        """refresh(Appearance self)"""
        return _robotsim.Appearance_refresh(self)


    def clone(self):
        """clone(Appearance self) -> Appearance"""
        return _robotsim.Appearance_clone(self)


    def set(self, arg2):
        """set(Appearance self, Appearance arg2)"""
        return _robotsim.Appearance_set(self, arg2)


    def isStandalone(self):
        """isStandalone(Appearance self) -> bool"""
        return _robotsim.Appearance_isStandalone(self)


    def free(self):
        """free(Appearance self)"""
        return _robotsim.Appearance_free(self)


    def setDraw(self, *args):
        """
        setDraw(Appearance self, bool draw)
        setDraw(Appearance self, int primitive, bool draw)
        """
        return _robotsim.Appearance_setDraw(self, *args)


    def getDraw(self, *args):
        """
        getDraw(Appearance self) -> bool
        getDraw(Appearance self, int primitive) -> bool
        """
        return _robotsim.Appearance_getDraw(self, *args)


    def setColor(self, *args):
        """
        setColor(Appearance self, float r, float g, float b, float a)
        setColor(Appearance self, int primitive, float r, float g, float b, float a)
        """
        return _robotsim.Appearance_setColor(self, *args)


    def getColor(self, *args):
        """
        getColor(Appearance self)
        getColor(Appearance self, int primitive)
        """
        return _robotsim.Appearance_getColor(self, *args)


    def setColors(self, primitive, colors, alpha=False):
        """
        setColors(Appearance self, int primitive, floatVector colors, bool alpha=False)
        setColors(Appearance self, int primitive, floatVector colors)
        """
        return _robotsim.Appearance_setColors(self, primitive, colors, alpha)


    def setTexture1D(self, w, format, bytes):
        """setTexture1D(Appearance self, int w, char const * format, std::vector< unsigned char,std::allocator< unsigned char > > const & bytes)"""
        return _robotsim.Appearance_setTexture1D(self, w, format, bytes)


    def setTexture2D(self, w, h, format, bytes):
        """setTexture2D(Appearance self, int w, int h, char const * format, std::vector< unsigned char,std::allocator< unsigned char > > const & bytes)"""
        return _robotsim.Appearance_setTexture2D(self, w, h, format, bytes)


    def setTexcoords(self, uvs):
        """setTexcoords(Appearance self, doubleVector uvs)"""
        return _robotsim.Appearance_setTexcoords(self, uvs)


    def drawGL(self, *args):
        """
        drawGL(Appearance self)
        drawGL(Appearance self, Geometry3D geom)
        """
        return _robotsim.Appearance_drawGL(self, *args)

    __swig_setmethods__["world"] = _robotsim.Appearance_world_set
    __swig_getmethods__["world"] = _robotsim.Appearance_world_get
    if _newclass:
        world = _swig_property(_robotsim.Appearance_world_get, _robotsim.Appearance_world_set)
    __swig_setmethods__["id"] = _robotsim.Appearance_id_set
    __swig_getmethods__["id"] = _robotsim.Appearance_id_get
    if _newclass:
        id = _swig_property(_robotsim.Appearance_id_get, _robotsim.Appearance_id_set)
    __swig_setmethods__["appearancePtr"] = _robotsim.Appearance_appearancePtr_set
    __swig_getmethods__["appearancePtr"] = _robotsim.Appearance_appearancePtr_get
    if _newclass:
        appearancePtr = _swig_property(_robotsim.Appearance_appearancePtr_get, _robotsim.Appearance_appearancePtr_set)
Appearance_swigregister = _robotsim.Appearance_swigregister
Appearance_swigregister(Appearance)

class Viewport(_object):
    """Proxy of C++ Viewport class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Viewport, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Viewport, name)
    __repr__ = _swig_repr

    def fromJson(self, str):
        """fromJson(Viewport self, std::string const & str) -> bool"""
        return _robotsim.Viewport_fromJson(self, str)


    def toJson(self):
        """toJson(Viewport self) -> std::string"""
        return _robotsim.Viewport_toJson(self)


    def setModelviewMatrix(self, M):
        """setModelviewMatrix(Viewport self, double const [16] M)"""
        return _robotsim.Viewport_setModelviewMatrix(self, M)


    def setRigidTransform(self, R, t):
        """setRigidTransform(Viewport self, double const [9] R, double const [3] t)"""
        return _robotsim.Viewport_setRigidTransform(self, R, t)


    def getRigidTransform(self):
        """getRigidTransform(Viewport self)"""
        return _robotsim.Viewport_getRigidTransform(self)

    __swig_setmethods__["perspective"] = _robotsim.Viewport_perspective_set
    __swig_getmethods__["perspective"] = _robotsim.Viewport_perspective_get
    if _newclass:
        perspective = _swig_property(_robotsim.Viewport_perspective_get, _robotsim.Viewport_perspective_set)
    __swig_setmethods__["scale"] = _robotsim.Viewport_scale_set
    __swig_getmethods__["scale"] = _robotsim.Viewport_scale_get
    if _newclass:
        scale = _swig_property(_robotsim.Viewport_scale_get, _robotsim.Viewport_scale_set)
    __swig_setmethods__["x"] = _robotsim.Viewport_x_set
    __swig_getmethods__["x"] = _robotsim.Viewport_x_get
    if _newclass:
        x = _swig_property(_robotsim.Viewport_x_get, _robotsim.Viewport_x_set)
    __swig_setmethods__["y"] = _robotsim.Viewport_y_set
    __swig_getmethods__["y"] = _robotsim.Viewport_y_get
    if _newclass:
        y = _swig_property(_robotsim.Viewport_y_get, _robotsim.Viewport_y_set)
    __swig_setmethods__["w"] = _robotsim.Viewport_w_set
    __swig_getmethods__["w"] = _robotsim.Viewport_w_get
    if _newclass:
        w = _swig_property(_robotsim.Viewport_w_get, _robotsim.Viewport_w_set)
    __swig_setmethods__["h"] = _robotsim.Viewport_h_set
    __swig_getmethods__["h"] = _robotsim.Viewport_h_get
    if _newclass:
        h = _swig_property(_robotsim.Viewport_h_get, _robotsim.Viewport_h_set)
    __swig_setmethods__["n"] = _robotsim.Viewport_n_set
    __swig_getmethods__["n"] = _robotsim.Viewport_n_get
    if _newclass:
        n = _swig_property(_robotsim.Viewport_n_get, _robotsim.Viewport_n_set)
    __swig_setmethods__["f"] = _robotsim.Viewport_f_set
    __swig_getmethods__["f"] = _robotsim.Viewport_f_get
    if _newclass:
        f = _swig_property(_robotsim.Viewport_f_get, _robotsim.Viewport_f_set)
    __swig_setmethods__["xform"] = _robotsim.Viewport_xform_set
    __swig_getmethods__["xform"] = _robotsim.Viewport_xform_get
    if _newclass:
        xform = _swig_property(_robotsim.Viewport_xform_get, _robotsim.Viewport_xform_set)

    def __init__(self):
        """__init__(Viewport self) -> Viewport"""
        this = _robotsim.new_Viewport()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_Viewport
    __del__ = lambda self: None
Viewport_swigregister = _robotsim.Viewport_swigregister
Viewport_swigregister(Viewport)

class Widget(_object):
    """Proxy of C++ Widget class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Widget, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Widget, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(Widget self) -> Widget"""
        this = _robotsim.new_Widget()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_Widget
    __del__ = lambda self: None

    def hover(self, x, y, viewport):
        """hover(Widget self, int x, int y, Viewport viewport) -> bool"""
        return _robotsim.Widget_hover(self, x, y, viewport)


    def beginDrag(self, x, y, viewport):
        """beginDrag(Widget self, int x, int y, Viewport viewport) -> bool"""
        return _robotsim.Widget_beginDrag(self, x, y, viewport)


    def drag(self, dx, dy, viewport):
        """drag(Widget self, int dx, int dy, Viewport viewport)"""
        return _robotsim.Widget_drag(self, dx, dy, viewport)


    def endDrag(self):
        """endDrag(Widget self)"""
        return _robotsim.Widget_endDrag(self)


    def keypress(self, c):
        """keypress(Widget self, char c)"""
        return _robotsim.Widget_keypress(self, c)


    def drawGL(self, viewport):
        """drawGL(Widget self, Viewport viewport)"""
        return _robotsim.Widget_drawGL(self, viewport)


    def idle(self):
        """idle(Widget self)"""
        return _robotsim.Widget_idle(self)


    def wantsRedraw(self):
        """wantsRedraw(Widget self) -> bool"""
        return _robotsim.Widget_wantsRedraw(self)

    __swig_setmethods__["index"] = _robotsim.Widget_index_set
    __swig_getmethods__["index"] = _robotsim.Widget_index_get
    if _newclass:
        index = _swig_property(_robotsim.Widget_index_get, _robotsim.Widget_index_set)
Widget_swigregister = _robotsim.Widget_swigregister
Widget_swigregister(Widget)

class WidgetSet(Widget):
    """Proxy of C++ WidgetSet class"""
    __swig_setmethods__ = {}
    for _s in [Widget]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WidgetSet, name, value)
    __swig_getmethods__ = {}
    for _s in [Widget]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WidgetSet, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(WidgetSet self) -> WidgetSet"""
        this = _robotsim.new_WidgetSet()
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, subwidget):
        """add(WidgetSet self, Widget subwidget)"""
        return _robotsim.WidgetSet_add(self, subwidget)


    def remove(self, subwidget):
        """remove(WidgetSet self, Widget subwidget)"""
        return _robotsim.WidgetSet_remove(self, subwidget)


    def enable(self, subwidget, enabled):
        """enable(WidgetSet self, Widget subwidget, bool enabled)"""
        return _robotsim.WidgetSet_enable(self, subwidget, enabled)

    __swig_destroy__ = _robotsim.delete_WidgetSet
    __del__ = lambda self: None
WidgetSet_swigregister = _robotsim.WidgetSet_swigregister
WidgetSet_swigregister(WidgetSet)

class PointPoser(Widget):
    """Proxy of C++ PointPoser class"""
    __swig_setmethods__ = {}
    for _s in [Widget]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PointPoser, name, value)
    __swig_getmethods__ = {}
    for _s in [Widget]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PointPoser, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(PointPoser self) -> PointPoser"""
        this = _robotsim.new_PointPoser()
        try:
            self.this.append(this)
        except:
            self.this = this

    def set(self, t):
        """set(PointPoser self, double const [3] t)"""
        return _robotsim.PointPoser_set(self, t)


    def get(self):
        """get(PointPoser self)"""
        return _robotsim.PointPoser_get(self)


    def setAxes(self, R):
        """setAxes(PointPoser self, double const [9] R)"""
        return _robotsim.PointPoser_setAxes(self, R)

    __swig_destroy__ = _robotsim.delete_PointPoser
    __del__ = lambda self: None
PointPoser_swigregister = _robotsim.PointPoser_swigregister
PointPoser_swigregister(PointPoser)

class TransformPoser(Widget):
    """Proxy of C++ TransformPoser class"""
    __swig_setmethods__ = {}
    for _s in [Widget]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransformPoser, name, value)
    __swig_getmethods__ = {}
    for _s in [Widget]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransformPoser, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(TransformPoser self) -> TransformPoser"""
        this = _robotsim.new_TransformPoser()
        try:
            self.this.append(this)
        except:
            self.this = this

    def set(self, R, t):
        """set(TransformPoser self, double const [9] R, double const [3] t)"""
        return _robotsim.TransformPoser_set(self, R, t)


    def get(self):
        """get(TransformPoser self)"""
        return _robotsim.TransformPoser_get(self)


    def enableTranslation(self, arg2):
        """enableTranslation(TransformPoser self, bool arg2)"""
        return _robotsim.TransformPoser_enableTranslation(self, arg2)


    def enableRotation(self, arg2):
        """enableRotation(TransformPoser self, bool arg2)"""
        return _robotsim.TransformPoser_enableRotation(self, arg2)

    __swig_destroy__ = _robotsim.delete_TransformPoser
    __del__ = lambda self: None
TransformPoser_swigregister = _robotsim.TransformPoser_swigregister
TransformPoser_swigregister(TransformPoser)

class ObjectPoser(Widget):
    """Proxy of C++ ObjectPoser class"""
    __swig_setmethods__ = {}
    for _s in [Widget]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ObjectPoser, name, value)
    __swig_getmethods__ = {}
    for _s in [Widget]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ObjectPoser, name)
    __repr__ = _swig_repr

    def __init__(self, object):
        """__init__(ObjectPoser self, RigidObjectModel object) -> ObjectPoser"""
        this = _robotsim.new_ObjectPoser(object)
        try:
            self.this.append(this)
        except:
            self.this = this

    def set(self, R, t):
        """set(ObjectPoser self, double const [9] R, double const [3] t)"""
        return _robotsim.ObjectPoser_set(self, R, t)


    def get(self):
        """get(ObjectPoser self)"""
        return _robotsim.ObjectPoser_get(self)

    __swig_destroy__ = _robotsim.delete_ObjectPoser
    __del__ = lambda self: None
ObjectPoser_swigregister = _robotsim.ObjectPoser_swigregister
ObjectPoser_swigregister(ObjectPoser)

class RobotPoser(Widget):
    """Proxy of C++ RobotPoser class"""
    __swig_setmethods__ = {}
    for _s in [Widget]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RobotPoser, name, value)
    __swig_getmethods__ = {}
    for _s in [Widget]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RobotPoser, name)
    __repr__ = _swig_repr

    def __init__(self, robot):
        """__init__(RobotPoser self, RobotModel robot) -> RobotPoser"""
        this = _robotsim.new_RobotPoser(robot)
        try:
            self.this.append(this)
        except:
            self.this = this

    def set(self, q):
        """set(RobotPoser self, doubleVector q)"""
        return _robotsim.RobotPoser_set(self, q)


    def get(self):
        """get(RobotPoser self)"""
        return _robotsim.RobotPoser_get(self)


    def getConditioned(self, qref):
        """getConditioned(RobotPoser self, doubleVector qref)"""
        return _robotsim.RobotPoser_getConditioned(self, qref)

    __swig_destroy__ = _robotsim.delete_RobotPoser
    __del__ = lambda self: None
RobotPoser_swigregister = _robotsim.RobotPoser_swigregister
RobotPoser_swigregister(RobotPoser)

class Mass(_object):
    """


    Stores mass information for a rigid body or robot link.

    C++ includes: robotmodel.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Mass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Mass, name)
    __repr__ = _swig_repr

    def setMass(self, _mass):
        """
        setMass(Mass self, double _mass)

        void Mass::setMass(double
        _mass) 
        """
        return _robotsim.Mass_setMass(self, _mass)


    def getMass(self):
        """
        getMass(Mass self) -> double

        double Mass::getMass() const 
        """
        return _robotsim.Mass_getMass(self)


    def setCom(self, _com):
        """
        setCom(Mass self, doubleVector _com)

        void Mass::setCom(const
        std::vector< double > &_com) 
        """
        return _robotsim.Mass_setCom(self, _com)


    def getCom(self):
        """
        getCom(Mass self)

        void Mass::getCom(std::vector<
        double > &out) const 
        """
        return _robotsim.Mass_getCom(self)


    def setInertia(self, _inertia):
        """
        setInertia(Mass self, doubleVector _inertia)

        void Mass::setInertia(const
        std::vector< double > &_inertia) 
        """
        return _robotsim.Mass_setInertia(self, _inertia)


    def getInertia(self):
        """
        getInertia(Mass self)

        void
        Mass::getInertia(std::vector< double > &out) const 
        """
        return _robotsim.Mass_getInertia(self)

    __swig_setmethods__["mass"] = _robotsim.Mass_mass_set
    __swig_getmethods__["mass"] = _robotsim.Mass_mass_get
    if _newclass:
        mass = _swig_property(_robotsim.Mass_mass_get, _robotsim.Mass_mass_set)
    __swig_setmethods__["com"] = _robotsim.Mass_com_set
    __swig_getmethods__["com"] = _robotsim.Mass_com_get
    if _newclass:
        com = _swig_property(_robotsim.Mass_com_get, _robotsim.Mass_com_set)
    __swig_setmethods__["inertia"] = _robotsim.Mass_inertia_set
    __swig_getmethods__["inertia"] = _robotsim.Mass_inertia_get
    if _newclass:
        inertia = _swig_property(_robotsim.Mass_inertia_get, _robotsim.Mass_inertia_set)

    def __init__(self):
        """
        __init__(Mass self) -> Mass



        Stores mass information for a rigid body or robot link.

        C++ includes: robotmodel.h 
        """
        this = _robotsim.new_Mass()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_Mass
    __del__ = lambda self: None
Mass_swigregister = _robotsim.Mass_swigregister
Mass_swigregister(Mass)

class ContactParameters(_object):
    """


    Stores contact parameters for an entity. Currently only used for
    simulation, but could be used for contact mechanics in the future.

    C++ includes: robotmodel.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContactParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ContactParameters, name)
    __repr__ = _swig_repr
    __swig_setmethods__["kFriction"] = _robotsim.ContactParameters_kFriction_set
    __swig_getmethods__["kFriction"] = _robotsim.ContactParameters_kFriction_get
    if _newclass:
        kFriction = _swig_property(_robotsim.ContactParameters_kFriction_get, _robotsim.ContactParameters_kFriction_set)
    __swig_setmethods__["kRestitution"] = _robotsim.ContactParameters_kRestitution_set
    __swig_getmethods__["kRestitution"] = _robotsim.ContactParameters_kRestitution_get
    if _newclass:
        kRestitution = _swig_property(_robotsim.ContactParameters_kRestitution_get, _robotsim.ContactParameters_kRestitution_set)
    __swig_setmethods__["kStiffness"] = _robotsim.ContactParameters_kStiffness_set
    __swig_getmethods__["kStiffness"] = _robotsim.ContactParameters_kStiffness_get
    if _newclass:
        kStiffness = _swig_property(_robotsim.ContactParameters_kStiffness_get, _robotsim.ContactParameters_kStiffness_set)
    __swig_setmethods__["kDamping"] = _robotsim.ContactParameters_kDamping_set
    __swig_getmethods__["kDamping"] = _robotsim.ContactParameters_kDamping_get
    if _newclass:
        kDamping = _swig_property(_robotsim.ContactParameters_kDamping_get, _robotsim.ContactParameters_kDamping_set)

    def __init__(self):
        """
        __init__(ContactParameters self) -> ContactParameters



        Stores contact parameters for an entity. Currently only used for
        simulation, but could be used for contact mechanics in the future.

        C++ includes: robotmodel.h 
        """
        this = _robotsim.new_ContactParameters()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_ContactParameters
    __del__ = lambda self: None
ContactParameters_swigregister = _robotsim.ContactParameters_swigregister
ContactParameters_swigregister(ContactParameters)

class RobotModelLink(_object):
    """


    A reference to a link of a RobotModel.

    C++ includes: robotmodel.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RobotModelLink, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RobotModelLink, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(RobotModelLink self) -> RobotModelLink

        RobotModelLink::RobotModelLink() 
        """
        this = _robotsim.new_RobotModelLink()
        try:
            self.this.append(this)
        except:
            self.this = this

    def getID(self):
        """
        getID(RobotModelLink self) -> int

        int
        RobotModelLink::getID()

        Returns the ID of the robot link in its world (Note: not the same as
        getIndex()) 
        """
        return _robotsim.RobotModelLink_getID(self)


    def getName(self):
        """
        getName(RobotModelLink self) -> char const *

        const char *
        RobotModelLink::getName() 
        """
        return _robotsim.RobotModelLink_getName(self)


    def robot(self):
        """
        robot(RobotModelLink self) -> RobotModel

        RobotModel
        RobotModelLink::robot()

        Returns a reference to the link's robot. 
        """
        return _robotsim.RobotModelLink_robot(self)


    def getRobot(self):
        """
        getRobot(RobotModelLink self) -> RobotModel

        RobotModel
        RobotModelLink::getRobot()

        Old-style: will be deprecated. 
        """
        return _robotsim.RobotModelLink_getRobot(self)


    def getIndex(self):
        """
        getIndex(RobotModelLink self) -> int

        int
        RobotModelLink::getIndex()

        Returns the index of the link (on its robot). 
        """
        return _robotsim.RobotModelLink_getIndex(self)


    def getParent(self):
        """
        getParent(RobotModelLink self) -> int

        int
        RobotModelLink::getParent()

        Returns the index of the link's parent (on its robot). 
        """
        return _robotsim.RobotModelLink_getParent(self)


    def setParent(self, p):
        """
        setParent(RobotModelLink self, int p)

        void
        RobotModelLink::setParent(int p)

        Sets the index of the link's parent (on its robot). 
        """
        return _robotsim.RobotModelLink_setParent(self, p)


    def geometry(self):
        """
        geometry(RobotModelLink self) -> Geometry3D

        Geometry3D
        RobotModelLink::geometry()

        Returns a reference to the link's geometry. 
        """
        return _robotsim.RobotModelLink_geometry(self)


    def appearance(self):
        """
        appearance(RobotModelLink self) -> Appearance

        Appearance
        RobotModelLink::appearance()

        Returns a reference to the link's appearance. 
        """
        return _robotsim.RobotModelLink_appearance(self)


    def getMass(self):
        """
        getMass(RobotModelLink self) -> Mass

        Mass
        RobotModelLink::getMass()

        Retrieves the inertial properties of the link. (Note that the Mass is
        given with origin at the link frame, not about the COM.) 
        """
        return _robotsim.RobotModelLink_getMass(self)


    def setMass(self, mass):
        """
        setMass(RobotModelLink self, Mass mass)

        void
        RobotModelLink::setMass(const Mass &mass)

        Sets the inertial proerties of the link. (Note that the Mass is given
        with origin at the link frame, not about the COM.) 
        """
        return _robotsim.RobotModelLink_setMass(self, mass)


    def getParentTransform(self):
        """
        getParentTransform(RobotModelLink self)

        void
        RobotModelLink::getParentTransform(double out[9], double out2[3])

        Gets transformation (R,t) to the parent link. 
        """
        return _robotsim.RobotModelLink_getParentTransform(self)


    def setParentTransform(self, R, t):
        """
        setParentTransform(RobotModelLink self, double const [9] R, double const [3] t)

        void
        RobotModelLink::setParentTransform(const double R[9], const double
        t[3]) 
        """
        return _robotsim.RobotModelLink_setParentTransform(self, R, t)


    def getAxis(self):
        """
        getAxis(RobotModelLink self)

        void
        RobotModelLink::getAxis(double out[3])

        Gets the local rotational / translational axis. 
        """
        return _robotsim.RobotModelLink_getAxis(self)


    def setAxis(self, axis):
        """
        setAxis(RobotModelLink self, double const [3] axis)

        void
        RobotModelLink::setAxis(const double axis[3]) 
        """
        return _robotsim.RobotModelLink_setAxis(self, axis)


    def getWorldPosition(self, plocal):
        """
        getWorldPosition(RobotModelLink self, double const [3] plocal)

        void
        RobotModelLink::getWorldPosition(const double plocal[3], double
        out[3])

        Converts point from local to world coordinates. 
        """
        return _robotsim.RobotModelLink_getWorldPosition(self, plocal)


    def getWorldDirection(self, vlocal):
        """
        getWorldDirection(RobotModelLink self, double const [3] vlocal)

        void
        RobotModelLink::getWorldDirection(const double vlocal[3], double
        out[3])

        Converts direction from local to world coordinates. 
        """
        return _robotsim.RobotModelLink_getWorldDirection(self, vlocal)


    def getLocalPosition(self, pworld):
        """
        getLocalPosition(RobotModelLink self, double const [3] pworld)

        void
        RobotModelLink::getLocalPosition(const double pworld[3], double
        out[3])

        Converts point from world to local coordinates. 
        """
        return _robotsim.RobotModelLink_getLocalPosition(self, pworld)


    def getLocalDirection(self, vworld):
        """
        getLocalDirection(RobotModelLink self, double const [3] vworld)

        void
        RobotModelLink::getLocalDirection(const double vworld[3], double
        out[3])

        Converts direction from world to local coordinates. 
        """
        return _robotsim.RobotModelLink_getLocalDirection(self, vworld)


    def getTransform(self):
        """
        getTransform(RobotModelLink self)

        void
        RobotModelLink::getTransform(double out[9], double out2[3])

        Gets transformation (R,t) to the world frame. 
        """
        return _robotsim.RobotModelLink_getTransform(self)


    def setTransform(self, R, t):
        """
        setTransform(RobotModelLink self, double const [9] R, double const [3] t)

        void
        RobotModelLink::setTransform(const double R[9], const double t[3])

        Sets transformation (R,t) to the world frame. Note: this does NOT
        perform inverse kinematics. The transform is overwritten when the
        robot's setConfig() method is called. 
        """
        return _robotsim.RobotModelLink_setTransform(self, R, t)


    def getJacobian(self, p):
        """
        getJacobian(RobotModelLink self, double const [3] p)

        void
        RobotModelLink::getJacobian(const double p[3], std::vector<
        std::vector< double > > &out)

        Returns the total jacobian of the local point p (row-major matrix)
        (orientation jacobian is stacked on position jacobian) 
        """
        return _robotsim.RobotModelLink_getJacobian(self, p)


    def getPositionJacobian(self, p):
        """
        getPositionJacobian(RobotModelLink self, double const [3] p)

        void
        RobotModelLink::getPositionJacobian(const double p[3], std::vector<
        std::vector< double > > &out)

        Returns the jacobian of the local point p (row-major matrix) 
        """
        return _robotsim.RobotModelLink_getPositionJacobian(self, p)


    def getOrientationJacobian(self):
        """
        getOrientationJacobian(RobotModelLink self)

        void
        RobotModelLink::getOrientationJacobian(std::vector< std::vector<
        double > > &out)

        Returns the orientation jacobian of the link (row-major matrix) 
        """
        return _robotsim.RobotModelLink_getOrientationJacobian(self)


    def getVelocity(self):
        """
        getVelocity(RobotModelLink self)

        void
        RobotModelLink::getVelocity(double out[3])

        Returns the velocity of the origin given the robot's current velocity.

        """
        return _robotsim.RobotModelLink_getVelocity(self)


    def getAngularVelocity(self):
        """
        getAngularVelocity(RobotModelLink self)

        void
        RobotModelLink::getAngularVelocity(double out[3])

        Returns the angular velocity given the robot's current velocity. 
        """
        return _robotsim.RobotModelLink_getAngularVelocity(self)


    def getPointVelocity(self, plocal):
        """
        getPointVelocity(RobotModelLink self, double const [3] plocal)

        void
        RobotModelLink::getPointVelocity(const double plocal[3], double
        out[3])

        Returns the world velocity of the point given the robot's current
        velocity. 
        """
        return _robotsim.RobotModelLink_getPointVelocity(self, plocal)


    def drawLocalGL(self, keepAppearance=True):
        """
        drawLocalGL(RobotModelLink self, bool keepAppearance=True)
        drawLocalGL(RobotModelLink self)

        void
        RobotModelLink::drawLocalGL(bool keepAppearance=true)

        Draws the link's geometry in its local frame. If keepAppearance=true,
        the current Appearance is honored. Otherwise, just the geometry is
        drawn. 
        """
        return _robotsim.RobotModelLink_drawLocalGL(self, keepAppearance)


    def drawWorldGL(self, keepAppearance=True):
        """
        drawWorldGL(RobotModelLink self, bool keepAppearance=True)
        drawWorldGL(RobotModelLink self)

        void
        RobotModelLink::drawWorldGL(bool keepAppearance=true)

        Draws the link's geometry in the world frame. If keepAppearance=true,
        the current Appearance is honored. Otherwise, just the geometry is
        drawn. 
        """
        return _robotsim.RobotModelLink_drawWorldGL(self, keepAppearance)

    __swig_setmethods__["world"] = _robotsim.RobotModelLink_world_set
    __swig_getmethods__["world"] = _robotsim.RobotModelLink_world_get
    if _newclass:
        world = _swig_property(_robotsim.RobotModelLink_world_get, _robotsim.RobotModelLink_world_set)
    __swig_setmethods__["robotIndex"] = _robotsim.RobotModelLink_robotIndex_set
    __swig_getmethods__["robotIndex"] = _robotsim.RobotModelLink_robotIndex_get
    if _newclass:
        robotIndex = _swig_property(_robotsim.RobotModelLink_robotIndex_get, _robotsim.RobotModelLink_robotIndex_set)
    __swig_setmethods__["robotPtr"] = _robotsim.RobotModelLink_robotPtr_set
    __swig_getmethods__["robotPtr"] = _robotsim.RobotModelLink_robotPtr_get
    if _newclass:
        robotPtr = _swig_property(_robotsim.RobotModelLink_robotPtr_get, _robotsim.RobotModelLink_robotPtr_set)
    __swig_setmethods__["index"] = _robotsim.RobotModelLink_index_set
    __swig_getmethods__["index"] = _robotsim.RobotModelLink_index_get
    if _newclass:
        index = _swig_property(_robotsim.RobotModelLink_index_get, _robotsim.RobotModelLink_index_set)
    __swig_destroy__ = _robotsim.delete_RobotModelLink
    __del__ = lambda self: None
RobotModelLink_swigregister = _robotsim.RobotModelLink_swigregister
RobotModelLink_swigregister(RobotModelLink)

class RobotModelDriver(_object):
    """


    A reference to a driver of a RobotModel.

    C++ includes: robotmodel.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RobotModelDriver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RobotModelDriver, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(RobotModelDriver self) -> RobotModelDriver

        RobotModelDriver::RobotModelDriver() 
        """
        this = _robotsim.new_RobotModelDriver()
        try:
            self.this.append(this)
        except:
            self.this = this

    def getName(self):
        """
        getName(RobotModelDriver self) -> char const *

        const char *
        RobotModelDriver::getName() 
        """
        return _robotsim.RobotModelDriver_getName(self)


    def robot(self):
        """
        robot(RobotModelDriver self) -> RobotModel

        RobotModel
        RobotModelDriver::robot()

        Returns a reference to the driver's robot. 
        """
        return _robotsim.RobotModelDriver_robot(self)


    def getRobot(self):
        """
        getRobot(RobotModelDriver self) -> RobotModel

        RobotModel
        RobotModelDriver::getRobot()

        Old-style: will be deprecated. 
        """
        return _robotsim.RobotModelDriver_getRobot(self)


    def getType(self):
        """
        getType(RobotModelDriver self) -> char const *

        const char *
        RobotModelDriver::getType()

        Currently can be "normal", "affine", "rotation",
        "translation", or "custom". 
        """
        return _robotsim.RobotModelDriver_getType(self)


    def getAffectedLink(self):
        """
        getAffectedLink(RobotModelDriver self) -> int

        int
        RobotModelDriver::getAffectedLink()

        Returns the single affected link for "normal" links. 
        """
        return _robotsim.RobotModelDriver_getAffectedLink(self)


    def getAffectedLinks(self, links):
        """
        getAffectedLinks(RobotModelDriver self, intVector links)

        void
        RobotModelDriver::getAffectedLinks(std::vector< int > &links)

        Returns the driver's affected links. 
        """
        return _robotsim.RobotModelDriver_getAffectedLinks(self, links)


    def getAffineCoeffs(self, scale, offset):
        """
        getAffineCoeffs(RobotModelDriver self, doubleVector scale, doubleVector offset)

        void
        RobotModelDriver::getAffineCoeffs(std::vector< double > &scale,
        std::vector< double > &offset)

        For "affine" links, returns the scale and offset of the driver value
        mapped to the world. 
        """
        return _robotsim.RobotModelDriver_getAffineCoeffs(self, scale, offset)


    def setValue(self, val):
        """
        setValue(RobotModelDriver self, double val)

        void
        RobotModelDriver::setValue(double val)

        Sets the robot's config to correspond to the given driver value. 
        """
        return _robotsim.RobotModelDriver_setValue(self, val)


    def getValue(self):
        """
        getValue(RobotModelDriver self) -> double

        double
        RobotModelDriver::getValue()

        Gets the current driver value from the robot's config. 
        """
        return _robotsim.RobotModelDriver_getValue(self)


    def setVelocity(self, val):
        """
        setVelocity(RobotModelDriver self, double val)

        void
        RobotModelDriver::setVelocity(double val)

        Sets the robot's velocity to correspond to the given driver velocity
        value. 
        """
        return _robotsim.RobotModelDriver_setVelocity(self, val)


    def getVelocity(self):
        """
        getVelocity(RobotModelDriver self) -> double

        double
        RobotModelDriver::getVelocity()

        Gets the current driver velocity value from the robot's velocity. 
        """
        return _robotsim.RobotModelDriver_getVelocity(self)

    __swig_setmethods__["world"] = _robotsim.RobotModelDriver_world_set
    __swig_getmethods__["world"] = _robotsim.RobotModelDriver_world_get
    if _newclass:
        world = _swig_property(_robotsim.RobotModelDriver_world_get, _robotsim.RobotModelDriver_world_set)
    __swig_setmethods__["robotIndex"] = _robotsim.RobotModelDriver_robotIndex_set
    __swig_getmethods__["robotIndex"] = _robotsim.RobotModelDriver_robotIndex_get
    if _newclass:
        robotIndex = _swig_property(_robotsim.RobotModelDriver_robotIndex_get, _robotsim.RobotModelDriver_robotIndex_set)
    __swig_setmethods__["robotPtr"] = _robotsim.RobotModelDriver_robotPtr_set
    __swig_getmethods__["robotPtr"] = _robotsim.RobotModelDriver_robotPtr_get
    if _newclass:
        robotPtr = _swig_property(_robotsim.RobotModelDriver_robotPtr_get, _robotsim.RobotModelDriver_robotPtr_set)
    __swig_setmethods__["index"] = _robotsim.RobotModelDriver_index_set
    __swig_getmethods__["index"] = _robotsim.RobotModelDriver_index_get
    if _newclass:
        index = _swig_property(_robotsim.RobotModelDriver_index_get, _robotsim.RobotModelDriver_index_set)
    __swig_destroy__ = _robotsim.delete_RobotModelDriver
    __del__ = lambda self: None
RobotModelDriver_swigregister = _robotsim.RobotModelDriver_swigregister
RobotModelDriver_swigregister(RobotModelDriver)

class RobotModel(_object):
    """


    A model of a dynamic and kinematic robot.

    It is important to understand that changing the configuration of the
    model doesn't actually send a command to the robot. In essence, this
    model maintains temporary storage for performing kinematics and
    dynamics computations.

    The robot maintains configuration/velocity/acceleration/torque bounds
    which are not enforced by the model, but must rather be enforced by
    the planner / simulator.

    The state of the robot is retrieved using getConfig/getVelocity calls,
    and is set using setConfig/setVelocity.

    C++ includes: robotmodel.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RobotModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RobotModel, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(RobotModel self) -> RobotModel

        RobotModel::RobotModel() 
        """
        this = _robotsim.new_RobotModel()
        try:
            self.this.append(this)
        except:
            self.this = this

    def getID(self):
        """
        getID(RobotModel self) -> int

        int RobotModel::getID()

        Returns the ID of the robot in its world (Note: not the same as the
        robot index) 
        """
        return _robotsim.RobotModel_getID(self)


    def getName(self):
        """
        getName(RobotModel self) -> char const *

        const char *
        RobotModel::getName() 
        """
        return _robotsim.RobotModel_getName(self)


    def numLinks(self):
        """
        numLinks(RobotModel self) -> int

        int
        RobotModel::numLinks()

        Returns the number of links = number of DOF's. 
        """
        return _robotsim.RobotModel_numLinks(self)


    def link(self, *args):
        """
        link(RobotModel self, int index) -> RobotModelLink
        link(RobotModel self, char const * name) -> RobotModelLink

        RobotModelLink
        RobotModel::link(const char *name)

        Returns a reference to the named link. 
        """
        return _robotsim.RobotModel_link(self, *args)


    def getLink(self, *args):
        """
        getLink(RobotModel self, int index) -> RobotModelLink
        getLink(RobotModel self, char const * name) -> RobotModelLink

        RobotModelLink
        RobotModel::getLink(const char *name)

        Old-style: will be deprecated. Returns a reference to the named link.

        """
        return _robotsim.RobotModel_getLink(self, *args)


    def numDrivers(self):
        """
        numDrivers(RobotModel self) -> int

        int
        RobotModel::numDrivers()

        Returns the number of drivers. 
        """
        return _robotsim.RobotModel_numDrivers(self)


    def driver(self, *args):
        """
        driver(RobotModel self, int index) -> RobotModelDriver
        driver(RobotModel self, char const * name) -> RobotModelDriver

        RobotModelDriver
        RobotModel::driver(const char *name)

        Returns a reference to the named driver. 
        """
        return _robotsim.RobotModel_driver(self, *args)


    def getDriver(self, *args):
        """
        getDriver(RobotModel self, int index) -> RobotModelDriver
        getDriver(RobotModel self, char const * name) -> RobotModelDriver

        RobotModelDriver
        RobotModel::getDriver(const char *name)

        Old-style: will be deprecated. Returns a reference to a
        RobotModelDriver. 
        """
        return _robotsim.RobotModel_getDriver(self, *args)


    def getConfig(self):
        """
        getConfig(RobotModel self)

        void
        RobotModel::getConfig(std::vector< double > &out) 
        """
        return _robotsim.RobotModel_getConfig(self)


    def getVelocity(self):
        """
        getVelocity(RobotModel self)

        void
        RobotModel::getVelocity(std::vector< double > &out) 
        """
        return _robotsim.RobotModel_getVelocity(self)


    def setConfig(self, q):
        """
        setConfig(RobotModel self, doubleVector q)

        void
        RobotModel::setConfig(const std::vector< double > &q) 
        """
        return _robotsim.RobotModel_setConfig(self, q)


    def setVelocity(self, dq):
        """
        setVelocity(RobotModel self, doubleVector dq)

        void
        RobotModel::setVelocity(const std::vector< double > &dq) 
        """
        return _robotsim.RobotModel_setVelocity(self, dq)


    def getJointLimits(self):
        """
        getJointLimits(RobotModel self)

        void
        RobotModel::getJointLimits(std::vector< double > &out, std::vector<
        double > &out2) 
        """
        return _robotsim.RobotModel_getJointLimits(self)


    def setJointLimits(self, qmin, qmax):
        """
        setJointLimits(RobotModel self, doubleVector qmin, doubleVector qmax)

        void
        RobotModel::setJointLimits(const std::vector< double > &qmin, const
        std::vector< double > &qmax) 
        """
        return _robotsim.RobotModel_setJointLimits(self, qmin, qmax)


    def getVelocityLimits(self):
        """
        getVelocityLimits(RobotModel self)

        void
        RobotModel::getVelocityLimits(std::vector< double > &out) 
        """
        return _robotsim.RobotModel_getVelocityLimits(self)


    def setVelocityLimits(self, vmax):
        """
        setVelocityLimits(RobotModel self, doubleVector vmax)

        void
        RobotModel::setVelocityLimits(const std::vector< double > &vmax) 
        """
        return _robotsim.RobotModel_setVelocityLimits(self, vmax)


    def getAccelerationLimits(self):
        """
        getAccelerationLimits(RobotModel self)

        void
        RobotModel::getAccelerationLimits(std::vector< double > &out) 
        """
        return _robotsim.RobotModel_getAccelerationLimits(self)


    def setAccelerationLimits(self, amax):
        """
        setAccelerationLimits(RobotModel self, doubleVector amax)

        void
        RobotModel::setAccelerationLimits(const std::vector< double > &amax)

        """
        return _robotsim.RobotModel_setAccelerationLimits(self, amax)


    def getTorqueLimits(self):
        """
        getTorqueLimits(RobotModel self)

        void
        RobotModel::getTorqueLimits(std::vector< double > &out) 
        """
        return _robotsim.RobotModel_getTorqueLimits(self)


    def setTorqueLimits(self, tmax):
        """
        setTorqueLimits(RobotModel self, doubleVector tmax)

        void
        RobotModel::setTorqueLimits(const std::vector< double > &tmax) 
        """
        return _robotsim.RobotModel_setTorqueLimits(self, tmax)


    def setDOFPosition(self, *args):
        """
        setDOFPosition(RobotModel self, int i, double qi)
        setDOFPosition(RobotModel self, char const * name, double qi)

        void
        RobotModel::setDOFPosition(const char *name, double qi) 
        """
        return _robotsim.RobotModel_setDOFPosition(self, *args)


    def getDOFPosition(self, *args):
        """
        getDOFPosition(RobotModel self, int i) -> double
        getDOFPosition(RobotModel self, char const * name) -> double

        double
        RobotModel::getDOFPosition(const char *name) 
        """
        return _robotsim.RobotModel_getDOFPosition(self, *args)


    def getCom(self):
        """
        getCom(RobotModel self)

        void
        RobotModel::getCom(double out[3])

        Returns the 3D center of mass at the current config. 
        """
        return _robotsim.RobotModel_getCom(self)


    def getComJacobian(self):
        """
        getComJacobian(RobotModel self)

        void
        RobotModel::getComJacobian(std::vector< std::vector< double > > &out)

        Returns the 3xn Jacobian matrix of the current center of mass. 
        """
        return _robotsim.RobotModel_getComJacobian(self)


    def getMassMatrix(self):
        """
        getMassMatrix(RobotModel self)

        void
        RobotModel::getMassMatrix(std::vector< std::vector< double > > &out)

        Returns the nxn mass matrix B(q) 
        """
        return _robotsim.RobotModel_getMassMatrix(self)


    def getMassMatrixInv(self):
        """
        getMassMatrixInv(RobotModel self)

        void
        RobotModel::getMassMatrixInv(std::vector< std::vector< double > >
        &out)

        Returns the inverse of the nxn mass matrix B(q)^-1 (faster than
        inverting result of getMassMatrix) 
        """
        return _robotsim.RobotModel_getMassMatrixInv(self)


    def getCoriolisForceMatrix(self):
        """
        getCoriolisForceMatrix(RobotModel self)

        void
        RobotModel::getCoriolisForceMatrix(std::vector< std::vector< double >
        > &out)

        Returns the Coriolis force matrix C(q,dq) for current config and
        velocity. 
        """
        return _robotsim.RobotModel_getCoriolisForceMatrix(self)


    def getCoriolisForces(self):
        """
        getCoriolisForces(RobotModel self)

        void
        RobotModel::getCoriolisForces(std::vector< double > &out)

        Returns the Coriolis forces C(q,dq)*dq for current config and velocity
        (faster than computing matrix and doing product) 
        """
        return _robotsim.RobotModel_getCoriolisForces(self)


    def getGravityForces(self, g):
        """
        getGravityForces(RobotModel self, double const [3] g)

        void
        RobotModel::getGravityForces(const double g[3], std::vector< double >
        &out)

        Returns the gravity force vector G(q) for the given workspace gravity
        vector g (usually (0,0,-9.8)) 
        """
        return _robotsim.RobotModel_getGravityForces(self, g)


    def torquesFromAccel(self, ddq):
        """
        torquesFromAccel(RobotModel self, doubleVector ddq)

        void
        RobotModel::torquesFromAccel(const std::vector< double > &ddq,
        std::vector< double > &out)

        Computes the inverse dynamics (using Recursive Newton Euler solver) 
        """
        return _robotsim.RobotModel_torquesFromAccel(self, ddq)


    def accelFromTorques(self, t):
        """
        accelFromTorques(RobotModel self, doubleVector t)

        void
        RobotModel::accelFromTorques(const std::vector< double > &t,
        std::vector< double > &out)

        Computes the foward dynamics (using Recursive Newton Euler solver) 
        """
        return _robotsim.RobotModel_accelFromTorques(self, t)


    def interpolate(self, a, b, u):
        """
        interpolate(RobotModel self, doubleVector a, doubleVector b, double u)

        void
        RobotModel::interpolate(const std::vector< double > &a, const
        std::vector< double > &b, double u, std::vector< double > &out)

        Interpolates smoothly between two configurations, properly taking into
        account nonstandard joints. 
        """
        return _robotsim.RobotModel_interpolate(self, a, b, u)


    def distance(self, a, b):
        """
        distance(RobotModel self, doubleVector a, doubleVector b) -> double

        double
        RobotModel::distance(const std::vector< double > &a, const
        std::vector< double > &b)

        Computes a distance between two configurations, properly taking into
        account nonstandard joints. 
        """
        return _robotsim.RobotModel_distance(self, a, b)


    def interpolate_deriv(self, a, b):
        """
        interpolate_deriv(RobotModel self, doubleVector a, doubleVector b)

        void
        RobotModel::interpolate_deriv(const std::vector< double > &a, const
        std::vector< double > &b, std::vector< double > &out)

        Returns the configuration derivative at a as you interpolate toward b
        at unit speed. 
        """
        return _robotsim.RobotModel_interpolate_deriv(self, a, b)


    def selfCollisionEnabled(self, link1, link2):
        """
        selfCollisionEnabled(RobotModel self, int link1, int link2) -> bool

        bool
        RobotModel::selfCollisionEnabled(int link1, int link2)

        Queries whether self collisions between two links is enabled. 
        """
        return _robotsim.RobotModel_selfCollisionEnabled(self, link1, link2)


    def enableSelfCollision(self, link1, link2, value):
        """
        enableSelfCollision(RobotModel self, int link1, int link2, bool value)

        void
        RobotModel::enableSelfCollision(int link1, int link2, bool value)

        Enables/disables self collisions between two links (depending on
        value) 
        """
        return _robotsim.RobotModel_enableSelfCollision(self, link1, link2, value)


    def selfCollides(self):
        """
        selfCollides(RobotModel self) -> bool

        bool
        RobotModel::selfCollides()

        Returns true if the robot is in self collision (faster than manual
        testing) 
        """
        return _robotsim.RobotModel_selfCollides(self)


    def drawGL(self, keepAppearance=True):
        """
        drawGL(RobotModel self, bool keepAppearance=True)
        drawGL(RobotModel self)

        void
        RobotModel::drawGL(bool keepAppearance=true)

        Draws the robot geometry. If keepAppearance=true, the current
        appearance is honored. Otherwise, only the raw geometry is drawn. 
        """
        return _robotsim.RobotModel_drawGL(self, keepAppearance)

    __swig_setmethods__["world"] = _robotsim.RobotModel_world_set
    __swig_getmethods__["world"] = _robotsim.RobotModel_world_get
    if _newclass:
        world = _swig_property(_robotsim.RobotModel_world_get, _robotsim.RobotModel_world_set)
    __swig_setmethods__["index"] = _robotsim.RobotModel_index_set
    __swig_getmethods__["index"] = _robotsim.RobotModel_index_get
    if _newclass:
        index = _swig_property(_robotsim.RobotModel_index_get, _robotsim.RobotModel_index_set)
    __swig_setmethods__["robot"] = _robotsim.RobotModel_robot_set
    __swig_getmethods__["robot"] = _robotsim.RobotModel_robot_get
    if _newclass:
        robot = _swig_property(_robotsim.RobotModel_robot_get, _robotsim.RobotModel_robot_set)
    __swig_destroy__ = _robotsim.delete_RobotModel
    __del__ = lambda self: None
RobotModel_swigregister = _robotsim.RobotModel_swigregister
RobotModel_swigregister(RobotModel)

class RigidObjectModel(_object):
    """


    A rigid movable object.

    State is retrieved/set using get/setTransform. No velocities are
    stored.

    C++ includes: robotmodel.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RigidObjectModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RigidObjectModel, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(RigidObjectModel self) -> RigidObjectModel

        RigidObjectModel::RigidObjectModel() 
        """
        this = _robotsim.new_RigidObjectModel()
        try:
            self.this.append(this)
        except:
            self.this = this

    def getID(self):
        """
        getID(RigidObjectModel self) -> int

        int
        RigidObjectModel::getID() 
        """
        return _robotsim.RigidObjectModel_getID(self)


    def getName(self):
        """
        getName(RigidObjectModel self) -> char const *

        const char *
        RigidObjectModel::getName() 
        """
        return _robotsim.RigidObjectModel_getName(self)


    def geometry(self):
        """
        geometry(RigidObjectModel self) -> Geometry3D

        Geometry3D
        RigidObjectModel::geometry() 
        """
        return _robotsim.RigidObjectModel_geometry(self)


    def appearance(self):
        """
        appearance(RigidObjectModel self) -> Appearance

        Appearance
        RigidObjectModel::appearance() 
        """
        return _robotsim.RigidObjectModel_appearance(self)


    def getMass(self):
        """
        getMass(RigidObjectModel self) -> Mass

        Mass
        RigidObjectModel::getMass() 
        """
        return _robotsim.RigidObjectModel_getMass(self)


    def setMass(self, mass):
        """
        setMass(RigidObjectModel self, Mass mass)

        void
        RigidObjectModel::setMass(const Mass &mass) 
        """
        return _robotsim.RigidObjectModel_setMass(self, mass)


    def getContactParameters(self):
        """
        getContactParameters(RigidObjectModel self) -> ContactParameters

        ContactParameters RigidObjectModel::getContactParameters() 
        """
        return _robotsim.RigidObjectModel_getContactParameters(self)


    def setContactParameters(self, params):
        """
        setContactParameters(RigidObjectModel self, ContactParameters params)

        void
        RigidObjectModel::setContactParameters(const ContactParameters
        &params) 
        """
        return _robotsim.RigidObjectModel_setContactParameters(self, params)


    def getTransform(self):
        """
        getTransform(RigidObjectModel self)

        void
        RigidObjectModel::getTransform(double out[9], double out2[3]) 
        """
        return _robotsim.RigidObjectModel_getTransform(self)


    def setTransform(self, R, t):
        """
        setTransform(RigidObjectModel self, double const [9] R, double const [3] t)

        void
        RigidObjectModel::setTransform(const double R[9], const double t[3])

        """
        return _robotsim.RigidObjectModel_setTransform(self, R, t)


    def drawGL(self, keepAppearance=True):
        """
        drawGL(RigidObjectModel self, bool keepAppearance=True)
        drawGL(RigidObjectModel self)

        void
        RigidObjectModel::drawGL(bool keepAppearance=true) 
        """
        return _robotsim.RigidObjectModel_drawGL(self, keepAppearance)

    __swig_setmethods__["world"] = _robotsim.RigidObjectModel_world_set
    __swig_getmethods__["world"] = _robotsim.RigidObjectModel_world_get
    if _newclass:
        world = _swig_property(_robotsim.RigidObjectModel_world_get, _robotsim.RigidObjectModel_world_set)
    __swig_setmethods__["index"] = _robotsim.RigidObjectModel_index_set
    __swig_getmethods__["index"] = _robotsim.RigidObjectModel_index_get
    if _newclass:
        index = _swig_property(_robotsim.RigidObjectModel_index_get, _robotsim.RigidObjectModel_index_set)
    __swig_setmethods__["object"] = _robotsim.RigidObjectModel_object_set
    __swig_getmethods__["object"] = _robotsim.RigidObjectModel_object_get
    if _newclass:
        object = _swig_property(_robotsim.RigidObjectModel_object_get, _robotsim.RigidObjectModel_object_set)
    __swig_destroy__ = _robotsim.delete_RigidObjectModel
    __del__ = lambda self: None
RigidObjectModel_swigregister = _robotsim.RigidObjectModel_swigregister
RigidObjectModel_swigregister(RigidObjectModel)

class TerrainModel(_object):
    """


    Static environment geometry.

    C++ includes: robotmodel.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TerrainModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TerrainModel, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(TerrainModel self) -> TerrainModel

        TerrainModel::TerrainModel() 
        """
        this = _robotsim.new_TerrainModel()
        try:
            self.this.append(this)
        except:
            self.this = this

    def getID(self):
        """
        getID(TerrainModel self) -> int

        int TerrainModel::getID()

        """
        return _robotsim.TerrainModel_getID(self)


    def getName(self):
        """
        getName(TerrainModel self) -> char const *

        const char *
        TerrainModel::getName() 
        """
        return _robotsim.TerrainModel_getName(self)


    def geometry(self):
        """
        geometry(TerrainModel self) -> Geometry3D

        Geometry3D
        TerrainModel::geometry() 
        """
        return _robotsim.TerrainModel_geometry(self)


    def appearance(self):
        """
        appearance(TerrainModel self) -> Appearance

        Appearance
        TerrainModel::appearance() 
        """
        return _robotsim.TerrainModel_appearance(self)


    def setFriction(self, friction):
        """
        setFriction(TerrainModel self, double friction)

        void
        TerrainModel::setFriction(double friction) 
        """
        return _robotsim.TerrainModel_setFriction(self, friction)


    def drawGL(self, keepAppearance=True):
        """
        drawGL(TerrainModel self, bool keepAppearance=True)
        drawGL(TerrainModel self)

        void
        TerrainModel::drawGL(bool keepAppearance=true) 
        """
        return _robotsim.TerrainModel_drawGL(self, keepAppearance)

    __swig_setmethods__["world"] = _robotsim.TerrainModel_world_set
    __swig_getmethods__["world"] = _robotsim.TerrainModel_world_get
    if _newclass:
        world = _swig_property(_robotsim.TerrainModel_world_get, _robotsim.TerrainModel_world_set)
    __swig_setmethods__["index"] = _robotsim.TerrainModel_index_set
    __swig_getmethods__["index"] = _robotsim.TerrainModel_index_get
    if _newclass:
        index = _swig_property(_robotsim.TerrainModel_index_get, _robotsim.TerrainModel_index_set)
    __swig_setmethods__["terrain"] = _robotsim.TerrainModel_terrain_set
    __swig_getmethods__["terrain"] = _robotsim.TerrainModel_terrain_get
    if _newclass:
        terrain = _swig_property(_robotsim.TerrainModel_terrain_get, _robotsim.TerrainModel_terrain_set)
    __swig_destroy__ = _robotsim.delete_TerrainModel
    __del__ = lambda self: None
TerrainModel_swigregister = _robotsim.TerrainModel_swigregister
TerrainModel_swigregister(TerrainModel)

class WorldModel(_object):
    """


    The main world class, containing robots, rigid objects, and static
    environment geometry.

    Note that this is just a model and can be changed at will in fact
    planners and simulators will make use of a model to "display"
    computed

    Every robot/robot link/terrain/rigid object is given a unique ID in
    the world. This is potentially a source of confusion because some
    functions take IDs and some take indices. Only the WorldModel and
    Simulator classes use IDs when the argument has 'id' as a suffix,
    e.g., geometry(), appearance(), Simulator.inContact(). All other
    functions use indices, e.g. robot(0), terrain(0), etc.

    To get an object's ID, you can see the value returned by loadElement
    and/or object.getID(). states.

    To save/restore the state of the model, you must manually maintain
    copies of the states of whichever objects you wish to save/restore.

    C++ includes: robotmodel.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WorldModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WorldModel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(WorldModel self) -> WorldModel
        __init__(WorldModel self, int index) -> WorldModel
        __init__(WorldModel self, WorldModel w) -> WorldModel
        __init__(WorldModel self, void * ptrRobotWorld) -> WorldModel

        WorldModel::WorldModel(void *ptrRobotWorld)

        Creates a WorldModel by pointer to a C++ RobotWorld structure (used
        pretty much only when interfacing C++ and Python code) 
        """
        this = _robotsim.new_WorldModel(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_WorldModel
    __del__ = lambda self: None

    def readFile(self, fn):
        """
        readFile(WorldModel self, char const * fn) -> bool

        bool
        WorldModel::readFile(const char *fn)

        Reads from a world XML file. 
        """
        return _robotsim.WorldModel_readFile(self, fn)


    def numRobots(self):
        """
        numRobots(WorldModel self) -> int

        int
        WorldModel::numRobots() 
        """
        return _robotsim.WorldModel_numRobots(self)


    def numRobotLinks(self, robot):
        """
        numRobotLinks(WorldModel self, int robot) -> int

        int
        WorldModel::numRobotLinks(int robot) 
        """
        return _robotsim.WorldModel_numRobotLinks(self, robot)


    def numRigidObjects(self):
        """
        numRigidObjects(WorldModel self) -> int

        int
        WorldModel::numRigidObjects() 
        """
        return _robotsim.WorldModel_numRigidObjects(self)


    def numTerrains(self):
        """
        numTerrains(WorldModel self) -> int

        int
        WorldModel::numTerrains() 
        """
        return _robotsim.WorldModel_numTerrains(self)


    def numIDs(self):
        """
        numIDs(WorldModel self) -> int

        int WorldModel::numIDs()

        """
        return _robotsim.WorldModel_numIDs(self)


    def robot(self, *args):
        """
        robot(WorldModel self, int index) -> RobotModel
        robot(WorldModel self, char const * name) -> RobotModel

        RobotModel
        WorldModel::robot(const char *name) 
        """
        return _robotsim.WorldModel_robot(self, *args)


    def robotLink(self, *args):
        """
        robotLink(WorldModel self, int robot, int index) -> RobotModelLink
        robotLink(WorldModel self, char const * robot, char const * name) -> RobotModelLink

        RobotModelLink
        WorldModel::robotLink(const char *robot, const char *name) 
        """
        return _robotsim.WorldModel_robotLink(self, *args)


    def rigidObject(self, *args):
        """
        rigidObject(WorldModel self, int index) -> RigidObjectModel
        rigidObject(WorldModel self, char const * name) -> RigidObjectModel

        RigidObjectModel
        WorldModel::rigidObject(const char *name) 
        """
        return _robotsim.WorldModel_rigidObject(self, *args)


    def terrain(self, *args):
        """
        terrain(WorldModel self, int index) -> TerrainModel
        terrain(WorldModel self, char const * name) -> TerrainModel

        TerrainModel
        WorldModel::terrain(const char *name) 
        """
        return _robotsim.WorldModel_terrain(self, *args)


    def makeRobot(self, name):
        """
        makeRobot(WorldModel self, char const * name) -> RobotModel

        RobotModel
        WorldModel::makeRobot(const char *name)

        Creates a new empty robot. (Not terribly useful now since you can't
        resize the number of links yet) 
        """
        return _robotsim.WorldModel_makeRobot(self, name)


    def makeRigidObject(self, name):
        """
        makeRigidObject(WorldModel self, char const * name) -> RigidObjectModel

        RigidObjectModel
        WorldModel::makeRigidObject(const char *name)

        Creates a new empty rigid object. 
        """
        return _robotsim.WorldModel_makeRigidObject(self, name)


    def makeTerrain(self, name):
        """
        makeTerrain(WorldModel self, char const * name) -> TerrainModel

        TerrainModel
        WorldModel::makeTerrain(const char *name)

        Creates a new empty terrain. 
        """
        return _robotsim.WorldModel_makeTerrain(self, name)


    def loadRobot(self, fn):
        """
        loadRobot(WorldModel self, char const * fn) -> RobotModel

        RobotModel
        WorldModel::loadRobot(const char *fn)

        Loads a robot from a .rob or .urdf file. An empty robot is returned if
        loading fails. 
        """
        return _robotsim.WorldModel_loadRobot(self, fn)


    def loadRigidObject(self, fn):
        """
        loadRigidObject(WorldModel self, char const * fn) -> RigidObjectModel

        RigidObjectModel
        WorldModel::loadRigidObject(const char *fn)

        Loads a rigid object from a .obj or a mesh file. An empty rigid object
        is returned if loading fails. 
        """
        return _robotsim.WorldModel_loadRigidObject(self, fn)


    def loadTerrain(self, fn):
        """
        loadTerrain(WorldModel self, char const * fn) -> TerrainModel

        TerrainModel
        WorldModel::loadTerrain(const char *fn)

        Loads a rigid object from a mesh file. An empty terrain is returned if
        loading fails. 
        """
        return _robotsim.WorldModel_loadTerrain(self, fn)


    def loadElement(self, fn):
        """
        loadElement(WorldModel self, char const * fn) -> int

        int
        WorldModel::loadElement(const char *fn)

        Loads some element from a file, automatically detecting its type.
        Meshes are interpreted as terrains. The ID is returned, or -1 if
        loading failed. 
        """
        return _robotsim.WorldModel_loadElement(self, fn)


    def remove(self, *args):
        """
        remove(WorldModel self, RobotModel robot)
        remove(WorldModel self, RigidObjectModel object)
        remove(WorldModel self, TerrainModel terrain)

        void
        WorldModel::remove(const TerrainModel &terrain)

        Removes a terrain. It must be in this world or an exception is raised.
        IMPORTANT: all other references to terrains will be invalidated. 
        """
        return _robotsim.WorldModel_remove(self, *args)


    def getName(self, id):
        """
        getName(WorldModel self, int id) -> std::string

        std::string
        WorldModel::getName(int id)

        Retrieves a name for a given element ID. 
        """
        return _robotsim.WorldModel_getName(self, id)


    def geometry(self, id):
        """
        geometry(WorldModel self, int id) -> Geometry3D

        Geometry3D
        WorldModel::geometry(int id)

        Retrieves a geometry for a given element ID. 
        """
        return _robotsim.WorldModel_geometry(self, id)


    def appearance(self, id):
        """
        appearance(WorldModel self, int id) -> Appearance

        Appearance
        WorldModel::appearance(int id)

        Retrieves an appearance for a given element ID. 
        """
        return _robotsim.WorldModel_appearance(self, id)


    def drawGL(self):
        """
        drawGL(WorldModel self)

        void WorldModel::drawGL()

        Draws the entire world. 
        """
        return _robotsim.WorldModel_drawGL(self)


    def enableGeometryLoading(self, enabled):
        """
        enableGeometryLoading(WorldModel self, bool enabled)

        void
        WorldModel::enableGeometryLoading(bool enabled)

        If geometry loading is set to false, then only the kinematics are
        loaded from disk, and no geometry / visualization / collision
        detection structures will be loaded. Useful for quick scripts that
        just use kinematics / dynamics of a robot. 
        """
        return _robotsim.WorldModel_enableGeometryLoading(self, enabled)

    __swig_setmethods__["index"] = _robotsim.WorldModel_index_set
    __swig_getmethods__["index"] = _robotsim.WorldModel_index_get
    if _newclass:
        index = _swig_property(_robotsim.WorldModel_index_get, _robotsim.WorldModel_index_set)
WorldModel_swigregister = _robotsim.WorldModel_swigregister
WorldModel_swigregister(WorldModel)

class IKObjective(_object):
    """


    A class defining an inverse kinematic target. Either a link on a robot
    can take on a fixed position/orientation in the world frame, or a
    relative position/orientation to another frame.

    Currently only fixed-point constraints and fixed-transform constraints
    are implemented in the Python API.

    C++ includes: robotik.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IKObjective, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IKObjective, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(IKObjective self) -> IKObjective

        IKObjective::IKObjective() 
        """
        this = _robotsim.new_IKObjective()
        try:
            self.this.append(this)
        except:
            self.this = this

    def link(self):
        """
        link(IKObjective self) -> int

        int IKObjective::link()
        const

        The index of the robot link that is constrained. 
        """
        return _robotsim.IKObjective_link(self)


    def destLink(self):
        """
        destLink(IKObjective self) -> int

        int
        IKObjective::destLink() const

        The index of the destination link, or -1 if fixed to the world. 
        """
        return _robotsim.IKObjective_destLink(self)


    def numPosDims(self):
        """
        numPosDims(IKObjective self) -> int

        int
        IKObjective::numPosDims() const

        Returns the number of position dimensions constrained (0-3) 
        """
        return _robotsim.IKObjective_numPosDims(self)


    def numRotDims(self):
        """
        numRotDims(IKObjective self) -> int

        int
        IKObjective::numRotDims() const

        Returns the number of rotation dimensions constrained (0-3) 
        """
        return _robotsim.IKObjective_numRotDims(self)


    def setFixedPoint(self, link, plocal, pworld):
        """
        setFixedPoint(IKObjective self, int link, double const [3] plocal, double const [3] pworld)

        void
        IKObjective::setFixedPoint(int link, const double plocal[3], const
        double pworld[3])

        Sets a fixed-point constraint. 
        """
        return _robotsim.IKObjective_setFixedPoint(self, link, plocal, pworld)


    def setFixedPoints(self, link, plocals, pworlds):
        """
        setFixedPoints(IKObjective self, int link, PyObject * plocals, PyObject * pworlds)

        void
        IKObjective::setFixedPoints(int link, PyObject *plocals, PyObject
        *pworlds)

        Sets a multiple fixed-point constraint. 
        """
        return _robotsim.IKObjective_setFixedPoints(self, link, plocals, pworlds)


    def setFixedTransform(self, link, R, t):
        """
        setFixedTransform(IKObjective self, int link, double const [9] R, double const [3] t)

        void
        IKObjective::setFixedTransform(int link, const double R[9], const
        double t[3])

        Sets a fixed-transform constraint (R,t) 
        """
        return _robotsim.IKObjective_setFixedTransform(self, link, R, t)


    def setRelativePoint(self, link1, link2, p1, p2):
        """
        setRelativePoint(IKObjective self, int link1, int link2, double const [3] p1, double const [3] p2)

        void
        IKObjective::setRelativePoint(int link1, int link2, const double
        p1[3], const double p2[3])

        Sets a fixed-point constraint relative to link2. 
        """
        return _robotsim.IKObjective_setRelativePoint(self, link1, link2, p1, p2)


    def setRelativePoints(self, link1, link2, p1s, p2s):
        """
        setRelativePoints(IKObjective self, int link1, int link2, PyObject * p1s, PyObject * p2s)

        void
        IKObjective::setRelativePoints(int link1, int link2, PyObject *p1s,
        PyObject *p2s)

        Sets a multiple fixed-point constraint relative to link2. 
        """
        return _robotsim.IKObjective_setRelativePoints(self, link1, link2, p1s, p2s)


    def setRelativeTransform(self, link, linkTgt, R, t):
        """
        setRelativeTransform(IKObjective self, int link, int linkTgt, double const [9] R, double const [3] t)

        void
        IKObjective::setRelativeTransform(int link, int linkTgt, const double
        R[9], const double t[3])

        Sets a fixed-transform constraint (R,t) relative to linkTgt. 
        """
        return _robotsim.IKObjective_setRelativeTransform(self, link, linkTgt, R, t)


    def setLinks(self, link, link2=-1):
        """
        setLinks(IKObjective self, int link, int link2=-1)
        setLinks(IKObjective self, int link)

        void
        IKObjective::setLinks(int link, int link2=-1)

        Manual construction. 
        """
        return _robotsim.IKObjective_setLinks(self, link, link2)


    def setFreePosition(self):
        """
        setFreePosition(IKObjective self)

        void
        IKObjective::setFreePosition()

        Manual: Sets a free position constraint. 
        """
        return _robotsim.IKObjective_setFreePosition(self)


    def setFixedPosConstraint(self, tlocal, tworld):
        """
        setFixedPosConstraint(IKObjective self, double const [3] tlocal, double const [3] tworld)

        void
        IKObjective::setFixedPosConstraint(const double tlocal[3], const
        double tworld[3])

        Manual: Sets a fixed position constraint. 
        """
        return _robotsim.IKObjective_setFixedPosConstraint(self, tlocal, tworld)


    def setPlanarPosConstraint(self, tlocal, nworld, oworld):
        """
        setPlanarPosConstraint(IKObjective self, double const [3] tlocal, double const [3] nworld, double oworld)

        void
        IKObjective::setPlanarPosConstraint(const double tlocal[3], const
        double nworld[3], double oworld)

        Manual: Sets a planar position constraint nworld^T T(link)*tlocal +
        oworld = 0 
        """
        return _robotsim.IKObjective_setPlanarPosConstraint(self, tlocal, nworld, oworld)


    def setLinearPosConstraint(self, tlocal, sworld, dworld):
        """
        setLinearPosConstraint(IKObjective self, double const [3] tlocal, double const [3] sworld, double const [3] dworld)

        void
        IKObjective::setLinearPosConstraint(const double tlocal[3], const
        double sworld[3], const double dworld[3])

        Manual: Sets a linear position constraint T(link)*tlocal = sworld +
        u*dworld for some real value u 
        """
        return _robotsim.IKObjective_setLinearPosConstraint(self, tlocal, sworld, dworld)


    def setFreeRotConstraint(self):
        """
        setFreeRotConstraint(IKObjective self)

        void
        IKObjective::setFreeRotConstraint()

        Manual: Sets a free rotation constraint. 
        """
        return _robotsim.IKObjective_setFreeRotConstraint(self)


    def setFixedRotConstraint(self, R):
        """
        setFixedRotConstraint(IKObjective self, double const [9] R)

        void
        IKObjective::setFixedRotConstraint(const double R[9])

        Manual: Sets a fixed rotation constraint. 
        """
        return _robotsim.IKObjective_setFixedRotConstraint(self, R)


    def setAxialRotConstraint(self, alocal, aworld):
        """
        setAxialRotConstraint(IKObjective self, double const [3] alocal, double const [3] aworld)

        void
        IKObjective::setAxialRotConstraint(const double alocal[3], const
        double aworld[3])

        Manual: Sets an axial rotation constraint. 
        """
        return _robotsim.IKObjective_setAxialRotConstraint(self, alocal, aworld)


    def getPosition(self):
        """
        getPosition(IKObjective self)

        void
        IKObjective::getPosition(double out[3], double out2[3]) const

        Returns the local and global position of the position constraint. 
        """
        return _robotsim.IKObjective_getPosition(self)


    def getPositionDirection(self):
        """
        getPositionDirection(IKObjective self)

        void
        IKObjective::getPositionDirection(double out[3]) const

        For linear and planar constraints, returns the direction. 
        """
        return _robotsim.IKObjective_getPositionDirection(self)


    def getRotation(self):
        """
        getRotation(IKObjective self)

        void
        IKObjective::getRotation(double out[9]) const

        For fixed rotation constraints, returns the orientation. 
        """
        return _robotsim.IKObjective_getRotation(self)


    def getRotationAxis(self):
        """
        getRotationAxis(IKObjective self)

        void
        IKObjective::getRotationAxis(double out[3], double out2[3]) const

        For axis rotation constraints, returns the local and global axes. 
        """
        return _robotsim.IKObjective_getRotationAxis(self)


    def getTransform(self):
        """
        getTransform(IKObjective self)

        void
        IKObjective::getTransform(double out[9], double out2[3]) const

        For fixed-transform constraints, returns the transform (R,T) 
        """
        return _robotsim.IKObjective_getTransform(self)

    __swig_setmethods__["goal"] = _robotsim.IKObjective_goal_set
    __swig_getmethods__["goal"] = _robotsim.IKObjective_goal_get
    if _newclass:
        goal = _swig_property(_robotsim.IKObjective_goal_get, _robotsim.IKObjective_goal_set)
    __swig_destroy__ = _robotsim.delete_IKObjective
    __del__ = lambda self: None
IKObjective_swigregister = _robotsim.IKObjective_swigregister
IKObjective_swigregister(IKObjective)

class IKSolver(_object):
    """


    An inverse kinematics solver based on the Newton-Raphson technique.

    Typical calling pattern is s = IKSolver(robot) s.add(objective1)
    s.add(objective2) (res,iters) = s.solve(100,1e-4) if res: print "IK
    solution:",robot.getConfig(),"found in",iters,"iterations,
    residual",s.getResidual() else: print "IK
    failed:",robot.getConfig(),"found in",iters,"iterations,
    residual",s.getResidual()

    sampleInitial() is a convenience routine. More initial configurations
    can be sampled in case the prior configs lead to local minima.

    C++ includes: robotik.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IKSolver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IKSolver, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IKSolver self, RobotModel robot) -> IKSolver
        __init__(IKSolver self, IKSolver solver) -> IKSolver

        IKSolver::IKSolver(const
        IKSolver &solver) 
        """
        this = _robotsim.new_IKSolver(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, objective):
        """
        add(IKSolver self, IKObjective objective)

        void IKSolver::add(const
        IKObjective &objective)

        Adds a new simultaneous objective. 
        """
        return _robotsim.IKSolver_add(self, objective)


    def setActiveDofs(self, active):
        """
        setActiveDofs(IKSolver self, intVector active)

        void
        IKSolver::setActiveDofs(const std::vector< int > &active)

        Sets the active degrees of freedom. 
        """
        return _robotsim.IKSolver_setActiveDofs(self, active)


    def getActiveDofs(self):
        """
        getActiveDofs(IKSolver self)

        void
        IKSolver::getActiveDofs(std::vector< int > &out)

        Gets the active degrees of freedom. 
        """
        return _robotsim.IKSolver_getActiveDofs(self)


    def setJointLimits(self, qmin, qmax):
        """
        setJointLimits(IKSolver self, doubleVector qmin, doubleVector qmax)

        void
        IKSolver::setJointLimits(const std::vector< double > &qmin, const
        std::vector< double > &qmax)

        Sets limits on the robot's configuration. If empty, this turns off
        joint limits. 
        """
        return _robotsim.IKSolver_setJointLimits(self, qmin, qmax)


    def getJointLimits(self):
        """
        getJointLimits(IKSolver self)

        void
        IKSolver::getJointLimits(std::vector< double > &out, std::vector<
        double > &out2)

        Gets the limits on the robot's configuration (by default this is the
        robot's joint limits. 
        """
        return _robotsim.IKSolver_getJointLimits(self)


    def getResidual(self):
        """
        getResidual(IKSolver self)

        void
        IKSolver::getResidual(std::vector< double > &out)

        Returns a vector describing the error of the objective. 
        """
        return _robotsim.IKSolver_getResidual(self)


    def getJacobian(self):
        """
        getJacobian(IKSolver self)

        void
        IKSolver::getJacobian(std::vector< std::vector< double > > &out)

        Returns a matrix describing the instantaneous derivative of the
        objective with respect to the active Dofs 
        """
        return _robotsim.IKSolver_getJacobian(self)


    def solve(self, iters, tol=1e-3):
        """
        solve(IKSolver self, int iters, double tol=1e-3) -> PyObject
        solve(IKSolver self, int iters) -> PyObject *

        PyObject *
        IKSolver::solve(int iters, double tol=1e-3)

        Tries to find a configuration that satifies all simultaneous
        objectives up to the desired tolerance. Returns (res,iters) where res
        indicates whether x converged. 
        """
        return _robotsim.IKSolver_solve(self, iters, tol)


    def sampleInitial(self):
        """
        sampleInitial(IKSolver self)

        void
        IKSolver::sampleInitial()

        Samples an initial random configuration. 
        """
        return _robotsim.IKSolver_sampleInitial(self)

    __swig_setmethods__["robot"] = _robotsim.IKSolver_robot_set
    __swig_getmethods__["robot"] = _robotsim.IKSolver_robot_get
    if _newclass:
        robot = _swig_property(_robotsim.IKSolver_robot_get, _robotsim.IKSolver_robot_set)
    __swig_setmethods__["objectives"] = _robotsim.IKSolver_objectives_set
    __swig_getmethods__["objectives"] = _robotsim.IKSolver_objectives_get
    if _newclass:
        objectives = _swig_property(_robotsim.IKSolver_objectives_get, _robotsim.IKSolver_objectives_set)
    __swig_setmethods__["activeDofs"] = _robotsim.IKSolver_activeDofs_set
    __swig_getmethods__["activeDofs"] = _robotsim.IKSolver_activeDofs_get
    if _newclass:
        activeDofs = _swig_property(_robotsim.IKSolver_activeDofs_get, _robotsim.IKSolver_activeDofs_set)
    __swig_setmethods__["useJointLimits"] = _robotsim.IKSolver_useJointLimits_set
    __swig_getmethods__["useJointLimits"] = _robotsim.IKSolver_useJointLimits_get
    if _newclass:
        useJointLimits = _swig_property(_robotsim.IKSolver_useJointLimits_get, _robotsim.IKSolver_useJointLimits_set)
    __swig_setmethods__["qmin"] = _robotsim.IKSolver_qmin_set
    __swig_getmethods__["qmin"] = _robotsim.IKSolver_qmin_get
    if _newclass:
        qmin = _swig_property(_robotsim.IKSolver_qmin_get, _robotsim.IKSolver_qmin_set)
    __swig_setmethods__["qmax"] = _robotsim.IKSolver_qmax_set
    __swig_getmethods__["qmax"] = _robotsim.IKSolver_qmax_get
    if _newclass:
        qmax = _swig_property(_robotsim.IKSolver_qmax_get, _robotsim.IKSolver_qmax_set)
    __swig_destroy__ = _robotsim.delete_IKSolver
    __del__ = lambda self: None
IKSolver_swigregister = _robotsim.IKSolver_swigregister
IKSolver_swigregister(IKSolver)

class GeneralizedIKObjective(_object):
    """


    An inverse kinematics target for matching points between two robots
    and/or objects.

    The objects are chosen upon construction, so the following are valid:
    GeneralizedIKObjective(a) is an objective for object a to be
    constrained relative to the environment.

    GeneralizedIKObjective(a,b) is an objective for object a to be
    constrained relative to b. Here a and b can be links on any robot or
    rigid objects.

    Once constructed, call setPoint, setPoints, or setTransform to specify
    the nature of the constraint.

    C++ includes: robotik.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeneralizedIKObjective, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GeneralizedIKObjective, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeneralizedIKObjective self, GeneralizedIKObjective obj) -> GeneralizedIKObjective
        __init__(GeneralizedIKObjective self, RobotModelLink link) -> GeneralizedIKObjective
        __init__(GeneralizedIKObjective self, RigidObjectModel obj) -> GeneralizedIKObjective
        __init__(GeneralizedIKObjective self, RobotModelLink link, RobotModelLink link2) -> GeneralizedIKObjective
        __init__(GeneralizedIKObjective self, RobotModelLink link, RigidObjectModel obj2) -> GeneralizedIKObjective
        __init__(GeneralizedIKObjective self, RigidObjectModel obj, RobotModelLink link2) -> GeneralizedIKObjective
        __init__(GeneralizedIKObjective self, RigidObjectModel obj, RigidObjectModel obj2) -> GeneralizedIKObjective

        GeneralizedIKObjective::GeneralizedIKObjective(const
        RigidObjectModel &obj, const RigidObjectModel &obj2) 
        """
        this = _robotsim.new_GeneralizedIKObjective(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def setPoint(self, p1, p2):
        """
        setPoint(GeneralizedIKObjective self, double const [3] p1, double const [3] p2)

        void
        GeneralizedIKObjective::setPoint(const double p1[3], const double
        p2[3]) 
        """
        return _robotsim.GeneralizedIKObjective_setPoint(self, p1, p2)


    def setPoints(self, p1s, p2s):
        """
        setPoints(GeneralizedIKObjective self, PyObject * p1s, PyObject * p2s)

        void
        GeneralizedIKObjective::setPoints(PyObject *p1s, PyObject *p2s) 
        """
        return _robotsim.GeneralizedIKObjective_setPoints(self, p1s, p2s)


    def setTransform(self, R, t):
        """
        setTransform(GeneralizedIKObjective self, double const [9] R, double const [3] t)

        void
        GeneralizedIKObjective::setTransform(const double R[9], const double
        t[3]) 
        """
        return _robotsim.GeneralizedIKObjective_setTransform(self, R, t)

    __swig_setmethods__["link1"] = _robotsim.GeneralizedIKObjective_link1_set
    __swig_getmethods__["link1"] = _robotsim.GeneralizedIKObjective_link1_get
    if _newclass:
        link1 = _swig_property(_robotsim.GeneralizedIKObjective_link1_get, _robotsim.GeneralizedIKObjective_link1_set)
    __swig_setmethods__["link2"] = _robotsim.GeneralizedIKObjective_link2_set
    __swig_getmethods__["link2"] = _robotsim.GeneralizedIKObjective_link2_get
    if _newclass:
        link2 = _swig_property(_robotsim.GeneralizedIKObjective_link2_get, _robotsim.GeneralizedIKObjective_link2_set)
    __swig_setmethods__["obj1"] = _robotsim.GeneralizedIKObjective_obj1_set
    __swig_getmethods__["obj1"] = _robotsim.GeneralizedIKObjective_obj1_get
    if _newclass:
        obj1 = _swig_property(_robotsim.GeneralizedIKObjective_obj1_get, _robotsim.GeneralizedIKObjective_obj1_set)
    __swig_setmethods__["obj2"] = _robotsim.GeneralizedIKObjective_obj2_set
    __swig_getmethods__["obj2"] = _robotsim.GeneralizedIKObjective_obj2_get
    if _newclass:
        obj2 = _swig_property(_robotsim.GeneralizedIKObjective_obj2_get, _robotsim.GeneralizedIKObjective_obj2_set)
    __swig_setmethods__["isObj1"] = _robotsim.GeneralizedIKObjective_isObj1_set
    __swig_getmethods__["isObj1"] = _robotsim.GeneralizedIKObjective_isObj1_get
    if _newclass:
        isObj1 = _swig_property(_robotsim.GeneralizedIKObjective_isObj1_get, _robotsim.GeneralizedIKObjective_isObj1_set)
    __swig_setmethods__["isObj2"] = _robotsim.GeneralizedIKObjective_isObj2_set
    __swig_getmethods__["isObj2"] = _robotsim.GeneralizedIKObjective_isObj2_get
    if _newclass:
        isObj2 = _swig_property(_robotsim.GeneralizedIKObjective_isObj2_get, _robotsim.GeneralizedIKObjective_isObj2_set)
    __swig_setmethods__["goal"] = _robotsim.GeneralizedIKObjective_goal_set
    __swig_getmethods__["goal"] = _robotsim.GeneralizedIKObjective_goal_get
    if _newclass:
        goal = _swig_property(_robotsim.GeneralizedIKObjective_goal_get, _robotsim.GeneralizedIKObjective_goal_set)
    __swig_destroy__ = _robotsim.delete_GeneralizedIKObjective
    __del__ = lambda self: None
GeneralizedIKObjective_swigregister = _robotsim.GeneralizedIKObjective_swigregister
GeneralizedIKObjective_swigregister(GeneralizedIKObjective)

class GeneralizedIKSolver(_object):
    """


    An inverse kinematics solver between multiple robots and/or objects.

    C++ includes: robotik.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeneralizedIKSolver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GeneralizedIKSolver, name)
    __repr__ = _swig_repr

    def __init__(self, world):
        """
        __init__(GeneralizedIKSolver self, WorldModel world) -> GeneralizedIKSolver

        GeneralizedIKSolver::GeneralizedIKSolver(const WorldModel &world) 
        """
        this = _robotsim.new_GeneralizedIKSolver(world)
        try:
            self.this.append(this)
        except:
            self.this = this

    def add(self, objective):
        """
        add(GeneralizedIKSolver self, GeneralizedIKObjective objective)

        void
        GeneralizedIKSolver::add(const GeneralizedIKObjective &objective)

        Adds a new simultaneous objective. 
        """
        return _robotsim.GeneralizedIKSolver_add(self, objective)


    def getResidual(self):
        """
        getResidual(GeneralizedIKSolver self)

        void
        GeneralizedIKSolver::getResidual(std::vector< double > &out)

        Returns a vector describing the error of the objective. 
        """
        return _robotsim.GeneralizedIKSolver_getResidual(self)


    def getJacobian(self):
        """
        getJacobian(GeneralizedIKSolver self)

        void
        GeneralizedIKSolver::getJacobian(std::vector< std::vector< double > >
        &out)

        Returns a matrix describing the instantaneous derivative of the
        objective with respect to the active parameters 
        """
        return _robotsim.GeneralizedIKSolver_getJacobian(self)


    def solve(self, iters, tol=1e-3):
        """
        solve(GeneralizedIKSolver self, int iters, double tol=1e-3) -> PyObject
        solve(GeneralizedIKSolver self, int iters) -> PyObject *

        PyObject *
        GeneralizedIKSolver::solve(int iters, double tol=1e-3)

        Tries to find a configuration that satifies all simultaneous
        objectives up to the desired tolerance. Returns (res,iters) where res
        indicates whether x converged. 
        """
        return _robotsim.GeneralizedIKSolver_solve(self, iters, tol)


    def sampleInitial(self):
        """
        sampleInitial(GeneralizedIKSolver self)

        void
        GeneralizedIKSolver::sampleInitial()

        Samples an initial random configuration. 
        """
        return _robotsim.GeneralizedIKSolver_sampleInitial(self)

    __swig_setmethods__["world"] = _robotsim.GeneralizedIKSolver_world_set
    __swig_getmethods__["world"] = _robotsim.GeneralizedIKSolver_world_get
    if _newclass:
        world = _swig_property(_robotsim.GeneralizedIKSolver_world_get, _robotsim.GeneralizedIKSolver_world_set)
    __swig_setmethods__["objectives"] = _robotsim.GeneralizedIKSolver_objectives_set
    __swig_getmethods__["objectives"] = _robotsim.GeneralizedIKSolver_objectives_get
    if _newclass:
        objectives = _swig_property(_robotsim.GeneralizedIKSolver_objectives_get, _robotsim.GeneralizedIKSolver_objectives_set)
    __swig_setmethods__["useJointLimits"] = _robotsim.GeneralizedIKSolver_useJointLimits_set
    __swig_getmethods__["useJointLimits"] = _robotsim.GeneralizedIKSolver_useJointLimits_get
    if _newclass:
        useJointLimits = _swig_property(_robotsim.GeneralizedIKSolver_useJointLimits_get, _robotsim.GeneralizedIKSolver_useJointLimits_set)
    __swig_destroy__ = _robotsim.delete_GeneralizedIKSolver
    __del__ = lambda self: None
GeneralizedIKSolver_swigregister = _robotsim.GeneralizedIKSolver_swigregister
GeneralizedIKSolver_swigregister(GeneralizedIKSolver)


def SampleTransform(*args):
    """
    SampleTransform(IKObjective obj)
    SampleTransform(GeneralizedIKObjective obj)

    void SampleTransform(const
    GeneralizedIKObjective &obj, double out[9], double out2[3]) 
    """
    return _robotsim.SampleTransform(*args)
class SimRobotSensor(_object):
    """


    A sensor on a simulated robot. Retreive this from the controller, and
    use getMeasurements to get the currently simulated measurement vector.

    type() gives you a string defining the sensor type. measurementNames()
    gives you a list of names for the measurements.

    C++ includes: robotsim.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimRobotSensor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SimRobotSensor, name)
    __repr__ = _swig_repr

    def __init__(self, sensor):
        """
        __init__(SimRobotSensor self, SensorBase * sensor) -> SimRobotSensor

        SimRobotSensor::SimRobotSensor(SensorBase *sensor) 
        """
        this = _robotsim.new_SimRobotSensor(sensor)
        try:
            self.this.append(this)
        except:
            self.this = this

    def name(self):
        """
        name(SimRobotSensor self) -> std::string

        std::string
        SimRobotSensor::name() 
        """
        return _robotsim.SimRobotSensor_name(self)


    def type(self):
        """
        type(SimRobotSensor self) -> std::string

        std::string
        SimRobotSensor::type() 
        """
        return _robotsim.SimRobotSensor_type(self)


    def measurementNames(self):
        """
        measurementNames(SimRobotSensor self) -> stringVector

        std::vector<
        std::string > SimRobotSensor::measurementNames() 
        """
        return _robotsim.SimRobotSensor_measurementNames(self)


    def getMeasurements(self):
        """
        getMeasurements(SimRobotSensor self)

        void
        SimRobotSensor::getMeasurements(std::vector< double > &out) 
        """
        return _robotsim.SimRobotSensor_getMeasurements(self)

    __swig_setmethods__["sensor"] = _robotsim.SimRobotSensor_sensor_set
    __swig_getmethods__["sensor"] = _robotsim.SimRobotSensor_sensor_get
    if _newclass:
        sensor = _swig_property(_robotsim.SimRobotSensor_sensor_get, _robotsim.SimRobotSensor_sensor_set)
    __swig_destroy__ = _robotsim.delete_SimRobotSensor
    __del__ = lambda self: None
SimRobotSensor_swigregister = _robotsim.SimRobotSensor_swigregister
SimRobotSensor_swigregister(SimRobotSensor)

class SimRobotController(_object):
    """


    A controller for a simulated robot.

    The basic way of using this is in "standard" move-to mode which
    accepts a milestone (setMilestone) or list of milestones (repeated
    calls to addMilestone) and interpolates dynamically from the current
    configuration/velocity. To handle disturbances, a PID loop is run. The
    constants of this loop are initially set in the robot file, or you can
    perform tuning via setPIDGains.

    Move-to motions are handled using a motion queue. To get finer-grained
    control over the motion queue you may use the setLinear/setCubic/
    addLinear/addCubic functions.

    Arbitrary trajectories can be tracked by using setVelocity over short
    time steps. Force controllers can be implemented using setTorque,
    again using short time steps. These set the controller into manual
    override mode. To reset back to regular motion queue control,

    C++ includes: robotsim.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimRobotController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SimRobotController, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(SimRobotController self) -> SimRobotController

        SimRobotController::SimRobotController() 
        """
        this = _robotsim.new_SimRobotController()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_SimRobotController
    __del__ = lambda self: None

    def setRate(self, dt):
        """
        setRate(SimRobotController self, double dt)

        void
        SimRobotController::setRate(double dt)

        Sets the current feedback control rate. 
        """
        return _robotsim.SimRobotController_setRate(self, dt)


    def getCommandedConfig(self):
        """
        getCommandedConfig(SimRobotController self)

        void
        SimRobotController::getCommandedConfig(std::vector< double > &out)

        Returns the current commanded configuration. 
        """
        return _robotsim.SimRobotController_getCommandedConfig(self)


    def getCommandedVelocity(self):
        """
        getCommandedVelocity(SimRobotController self)

        void
        SimRobotController::getCommandedVelocity(std::vector< double > &out)

        Returns the current commanded velocity. 
        """
        return _robotsim.SimRobotController_getCommandedVelocity(self)


    def getSensedConfig(self):
        """
        getSensedConfig(SimRobotController self)

        void
        SimRobotController::getSensedConfig(std::vector< double > &out)

        Returns the current "sensed" configuration from the simulator. 
        """
        return _robotsim.SimRobotController_getSensedConfig(self)


    def getSensedVelocity(self):
        """
        getSensedVelocity(SimRobotController self)

        void
        SimRobotController::getSensedVelocity(std::vector< double > &out)

        Returns the current "sensed" velocity from the simulator. 
        """
        return _robotsim.SimRobotController_getSensedVelocity(self)


    def sensor(self, *args):
        """
        sensor(SimRobotController self, int index) -> SimRobotSensor
        sensor(SimRobotController self, char const * name) -> SimRobotSensor

        SimRobotSensor
        SimRobotController::sensor(const char *name)

        Returns a sensor by name. If unavailable, a null sensor is returned.

        """
        return _robotsim.SimRobotController_sensor(self, *args)


    def getSensor(self, index):
        """
        getSensor(SimRobotController self, int index) -> SimRobotSensor

        SimRobotSensor
        SimRobotController::getSensor(int index)

        Old-style: will be deprecated. 
        """
        return _robotsim.SimRobotController_getSensor(self, index)


    def getNamedSensor(self, name):
        """
        getNamedSensor(SimRobotController self, std::string const & name) -> SimRobotSensor

        SimRobotSensor SimRobotController::getNamedSensor(const std::string
        &name)

        Old-style: will be deprecated. 
        """
        return _robotsim.SimRobotController_getNamedSensor(self, name)


    def commands(self):
        """
        commands(SimRobotController self) -> stringVector

        std::vector<
        std::string > SimRobotController::commands()

        gets a command list 
        """
        return _robotsim.SimRobotController_commands(self)


    def sendCommand(self, name, args):
        """
        sendCommand(SimRobotController self, std::string const & name, std::string const & args) -> bool

        bool
        SimRobotController::sendCommand(const std::string &name, const
        std::string &args)

        sends a command to the controller 
        """
        return _robotsim.SimRobotController_sendCommand(self, name, args)


    def getSetting(self, name):
        """
        getSetting(SimRobotController self, std::string const & name) -> std::string

        std::string
        SimRobotController::getSetting(const std::string &name)

        gets/sets settings of the controller 
        """
        return _robotsim.SimRobotController_getSetting(self, name)


    def setSetting(self, name, val):
        """
        setSetting(SimRobotController self, std::string const & name, std::string const & val) -> bool

        bool
        SimRobotController::setSetting(const std::string &name, const
        std::string &val) 
        """
        return _robotsim.SimRobotController_setSetting(self, name, val)


    def setMilestone(self, *args):
        """
        setMilestone(SimRobotController self, doubleVector q)
        setMilestone(SimRobotController self, doubleVector q, doubleVector dq)

        void
        SimRobotController::setMilestone(const std::vector< double > &q, const
        std::vector< double > &dq) 
        """
        return _robotsim.SimRobotController_setMilestone(self, *args)


    def addMilestone(self, *args):
        """
        addMilestone(SimRobotController self, doubleVector q)
        addMilestone(SimRobotController self, doubleVector q, doubleVector dq)

        void
        SimRobotController::addMilestone(const std::vector< double > &q, const
        std::vector< double > &dq) 
        """
        return _robotsim.SimRobotController_addMilestone(self, *args)


    def addMilestoneLinear(self, q):
        """
        addMilestoneLinear(SimRobotController self, doubleVector q)

        void
        SimRobotController::addMilestoneLinear(const std::vector< double > &q)

        Same as addMilestone, but enforces that the motion should move along a
        straight-line joint-space path 
        """
        return _robotsim.SimRobotController_addMilestoneLinear(self, q)


    def setLinear(self, q, dt):
        """
        setLinear(SimRobotController self, doubleVector q, double dt)

        void
        SimRobotController::setLinear(const std::vector< double > &q, double
        dt)

        Uses linear interpolation to get from the current configuration to the
        desired configuration after time dt 
        """
        return _robotsim.SimRobotController_setLinear(self, q, dt)


    def setCubic(self, q, v, dt):
        """
        setCubic(SimRobotController self, doubleVector q, doubleVector v, double dt)

        void
        SimRobotController::setCubic(const std::vector< double > &q, const
        std::vector< double > &v, double dt)

        Uses cubic (Hermite) interpolation to get from the current
        configuration/velocity to the desired configuration/velocity after
        time dt 
        """
        return _robotsim.SimRobotController_setCubic(self, q, v, dt)


    def appendLinear(self, q, dt):
        """
        appendLinear(SimRobotController self, doubleVector q, double dt)

        void
        SimRobotController::appendLinear(const std::vector< double > &q,
        double dt)

        Same as setLinear but appends an interpolant onto the motion queue. 
        """
        return _robotsim.SimRobotController_appendLinear(self, q, dt)


    def addCubic(self, q, v, dt):
        """
        addCubic(SimRobotController self, doubleVector q, doubleVector v, double dt)

        void
        SimRobotController::addCubic(const std::vector< double > &q, const
        std::vector< double > &v, double dt)

        Same as setCubic but appends an interpolant onto the motion queue. 
        """
        return _robotsim.SimRobotController_addCubic(self, q, v, dt)


    def remainingTime(self):
        """
        remainingTime(SimRobotController self) -> double

        double
        SimRobotController::remainingTime() const

        Returns the remaining duration of the motion queue. 
        """
        return _robotsim.SimRobotController_remainingTime(self)


    def setVelocity(self, dq, dt):
        """
        setVelocity(SimRobotController self, doubleVector dq, double dt)

        void
        SimRobotController::setVelocity(const std::vector< double > &dq,
        double dt)

        Sets a rate controller from the current commanded config to move at
        rate dq for time dt. 
        """
        return _robotsim.SimRobotController_setVelocity(self, dq, dt)


    def setTorque(self, t):
        """
        setTorque(SimRobotController self, doubleVector t)

        void
        SimRobotController::setTorque(const std::vector< double > &t)

        Sets a torque command controller. 
        """
        return _robotsim.SimRobotController_setTorque(self, t)


    def setPIDCommand(self, *args):
        """
        setPIDCommand(SimRobotController self, doubleVector qdes, doubleVector dqdes)
        setPIDCommand(SimRobotController self, doubleVector qdes, doubleVector dqdes, doubleVector tfeedforward)

        void
        SimRobotController::setPIDCommand(const std::vector< double > &qdes,
        const std::vector< double > &dqdes, const std::vector< double >
        &tfeedforward)

        Sets a PID command controller with feedforward torques. 
        """
        return _robotsim.SimRobotController_setPIDCommand(self, *args)


    def setManualMode(self, enabled):
        """
        setManualMode(SimRobotController self, bool enabled)

        void
        SimRobotController::setManualMode(bool enabled)

        Turns on/off manual mode, if either the setTorque or setPID command
        were previously set. 
        """
        return _robotsim.SimRobotController_setManualMode(self, enabled)


    def getControlType(self):
        """
        getControlType(SimRobotController self) -> std::string

        std::string SimRobotController::getControlType()

        Returns the control type for the active controller valid values are:
        unknown

        off

        torque

        PID

        locked_velocity 
        """
        return _robotsim.SimRobotController_getControlType(self)


    def setPIDGains(self, kP, kI, kD):
        """
        setPIDGains(SimRobotController self, doubleVector kP, doubleVector kI, doubleVector kD)

        void
        SimRobotController::setPIDGains(const std::vector< double > &kP, const
        std::vector< double > &kI, const std::vector< double > &kD)

        Sets the PID gains. 
        """
        return _robotsim.SimRobotController_setPIDGains(self, kP, kI, kD)

    __swig_setmethods__["index"] = _robotsim.SimRobotController_index_set
    __swig_getmethods__["index"] = _robotsim.SimRobotController_index_get
    if _newclass:
        index = _swig_property(_robotsim.SimRobotController_index_get, _robotsim.SimRobotController_index_set)
    __swig_setmethods__["sim"] = _robotsim.SimRobotController_sim_set
    __swig_getmethods__["sim"] = _robotsim.SimRobotController_sim_get
    if _newclass:
        sim = _swig_property(_robotsim.SimRobotController_sim_get, _robotsim.SimRobotController_sim_set)
SimRobotController_swigregister = _robotsim.SimRobotController_swigregister
SimRobotController_swigregister(SimRobotController)

class SimBody(_object):
    """


    A reference to a rigid body inside a Simulator (either a
    RigidObjectModel, TerrainModel, or a link of a RobotModel).

    Can use this class to directly apply forces to or control positions /
    velocities of objects in the simulation. However, note that the
    changes are only applied in the current simulation substep, not the
    duration provided to Simulation.simulate(). If you need fine-grained
    control, make sure to call simulate() with time steps equal to the
    value provided to Simulation.setSimStep() (this is 0.001s by default).

    C++ includes: robotsim.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimBody, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SimBody, name)
    __repr__ = _swig_repr

    def enable(self, enabled=True):
        """
        enable(SimBody self, bool enabled=True)
        enable(SimBody self)

        void SimBody::enable(bool
        enabled=true)

        Sets the simulation of this body on/off. 
        """
        return _robotsim.SimBody_enable(self, enabled)


    def isEnabled(self):
        """
        isEnabled(SimBody self) -> bool

        bool SimBody::isEnabled()

        Returns true if this body is being simulated. 
        """
        return _robotsim.SimBody_isEnabled(self)


    def enableDynamics(self, enabled=True):
        """
        enableDynamics(SimBody self, bool enabled=True)
        enableDynamics(SimBody self)

        void
        SimBody::enableDynamics(bool enabled=true)

        Sets the dynamic simulation of the body on/off. If false, velocities
        will simply be integrated forward, and forces will not affect velocity
        i.e., it will be pure kinematic simulation. 
        """
        return _robotsim.SimBody_enableDynamics(self, enabled)


    def isDynamicsEnabled(self):
        """
        isDynamicsEnabled(SimBody self) -> bool

        bool
        SimBody::isDynamicsEnabled() 
        """
        return _robotsim.SimBody_isDynamicsEnabled(self)


    def applyWrench(self, f, t):
        """
        applyWrench(SimBody self, double const [3] f, double const [3] t)

        void
        SimBody::applyWrench(const double f[3], const double t[3])

        Applies a force and torque about the COM at the current simulation
        time step. 
        """
        return _robotsim.SimBody_applyWrench(self, f, t)


    def applyForceAtPoint(self, f, pworld):
        """
        applyForceAtPoint(SimBody self, double const [3] f, double const [3] pworld)

        void
        SimBody::applyForceAtPoint(const double f[3], const double pworld[3])

        Applies a force at a given point (in world coordinates) at the current
        simulation time step. 
        """
        return _robotsim.SimBody_applyForceAtPoint(self, f, pworld)


    def applyForceAtLocalPoint(self, f, plocal):
        """
        applyForceAtLocalPoint(SimBody self, double const [3] f, double const [3] plocal)

        void
        SimBody::applyForceAtLocalPoint(const double f[3], const double
        plocal[3])

        Applies a force at a given point (in local coordinates) at the current
        simulation time step. 
        """
        return _robotsim.SimBody_applyForceAtLocalPoint(self, f, plocal)


    def setTransform(self, R, t):
        """
        setTransform(SimBody self, double const [9] R, double const [3] t)

        void
        SimBody::setTransform(const double R[9], const double t[3])

        Sets the body's transformation at the current simulation time step. 
        """
        return _robotsim.SimBody_setTransform(self, R, t)


    def getTransform(self):
        """
        getTransform(SimBody self)

        void
        SimBody::getTransform(double out[9], double out2[3]) 
        """
        return _robotsim.SimBody_getTransform(self)


    def setVelocity(self, w, v):
        """
        setVelocity(SimBody self, double const [3] w, double const [3] v)

        void
        SimBody::setVelocity(const double w[3], const double v[3])

        Sets the angular velocity and translational velocity at the current
        simulation time step. 
        """
        return _robotsim.SimBody_setVelocity(self, w, v)


    def getVelocity(self):
        """
        getVelocity(SimBody self)

        void
        SimBody::getVelocity(double out[3], double out2[3])

        Returns the angular velocity and translational velocity. 
        """
        return _robotsim.SimBody_getVelocity(self)


    def setCollisionPadding(self, padding):
        """
        setCollisionPadding(SimBody self, double padding)

        void
        SimBody::setCollisionPadding(double padding)

        Sets the collision padding (useful for thin objects). Default is
        0.0025. 
        """
        return _robotsim.SimBody_setCollisionPadding(self, padding)


    def getCollisionPadding(self):
        """
        getCollisionPadding(SimBody self) -> double

        double
        SimBody::getCollisionPadding() 
        """
        return _robotsim.SimBody_getCollisionPadding(self)


    def getSurface(self):
        """
        getSurface(SimBody self) -> ContactParameters

        ContactParameters
        SimBody::getSurface()

        Gets (a copy of) the surface properties. 
        """
        return _robotsim.SimBody_getSurface(self)


    def setSurface(self, params):
        """
        setSurface(SimBody self, ContactParameters params)

        void
        SimBody::setSurface(const ContactParameters &params)

        Sets the surface properties. 
        """
        return _robotsim.SimBody_setSurface(self, params)

    __swig_setmethods__["geometry"] = _robotsim.SimBody_geometry_set
    __swig_getmethods__["geometry"] = _robotsim.SimBody_geometry_get
    if _newclass:
        geometry = _swig_property(_robotsim.SimBody_geometry_get, _robotsim.SimBody_geometry_set)
    __swig_setmethods__["body"] = _robotsim.SimBody_body_set
    __swig_getmethods__["body"] = _robotsim.SimBody_body_get
    if _newclass:
        body = _swig_property(_robotsim.SimBody_body_get, _robotsim.SimBody_body_set)

    def __init__(self):
        """
        __init__(SimBody self) -> SimBody



        A reference to a rigid body inside a Simulator (either a
        RigidObjectModel, TerrainModel, or a link of a RobotModel).

        Can use this class to directly apply forces to or control positions /
        velocities of objects in the simulation. However, note that the
        changes are only applied in the current simulation substep, not the
        duration provided to Simulation.simulate(). If you need fine-grained
        control, make sure to call simulate() with time steps equal to the
        value provided to Simulation.setSimStep() (this is 0.001s by default).

        C++ includes: robotsim.h 
        """
        this = _robotsim.new_SimBody()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_SimBody
    __del__ = lambda self: None
SimBody_swigregister = _robotsim.SimBody_swigregister
SimBody_swigregister(SimBody)

class Simulator(_object):
    """


    A dynamics simulator for a WorldModel.

    C++ includes: robotsim.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Simulator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Simulator, name)
    __repr__ = _swig_repr

    def __init__(self, model, settings=None):
        """
        __init__(Simulator self, WorldModel model, char const * settings=None) -> Simulator
        __init__(Simulator self, WorldModel model) -> Simulator

        Simulator::Simulator(const WorldModel &model, const char
        *settings=NULL)

        Constructs the simulator from a WorldModel. If the WorldModel was
        loaded from an XML file, then the simulation setup is loaded from it.

        """
        this = _robotsim.new_Simulator(model, settings)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _robotsim.delete_Simulator
    __del__ = lambda self: None

    def reset(self):
        """
        reset(Simulator self)

        void Simulator::reset()

        Resets to the initial state (same as setState(initialState)) 
        """
        return _robotsim.Simulator_reset(self)


    def getWorld(self):
        """
        getWorld(Simulator self) -> WorldModel

        WorldModel
        Simulator::getWorld() const

        Old-style: will be deprecated. 
        """
        return _robotsim.Simulator_getWorld(self)


    def getState(self):
        """
        getState(Simulator self) -> std::string

        string
        Simulator::getState()

        Returns a Base64 string representing the binary data for the current
        simulation state, including controller parameters, etc. 
        """
        return _robotsim.Simulator_getState(self)


    def setState(self, str):
        """
        setState(Simulator self, std::string const & str)

        void
        Simulator::setState(const std::string &str)

        Sets the current simulation state from a Base64 string returned by a
        prior getState call. 
        """
        return _robotsim.Simulator_setState(self, str)


    def simulate(self, t):
        """
        simulate(Simulator self, double t)

        void
        Simulator::simulate(double t)

        Advances the simulation by time t, and updates the world model from
        the simulation state. 
        """
        return _robotsim.Simulator_simulate(self, t)


    def fakeSimulate(self, t):
        """
        fakeSimulate(Simulator self, double t)

        void
        Simulator::fakeSimulate(double t)

        Advances a faked simulation by time t, and updates the world model
        from the faked simulation state. 
        """
        return _robotsim.Simulator_fakeSimulate(self, t)


    def getTime(self):
        """
        getTime(Simulator self) -> double

        double
        Simulator::getTime()

        Returns the simulation time. 
        """
        return _robotsim.Simulator_getTime(self)


    def updateWorld(self):
        """
        updateWorld(Simulator self)

        void
        Simulator::updateWorld()

        Updates the world model from the current simulation state. This only
        needs to be called if you change the world model and want to revert
        back to the simulation state. 
        """
        return _robotsim.Simulator_updateWorld(self)


    def getActualConfig(self, robot):
        """
        getActualConfig(Simulator self, int robot)

        void
        Simulator::getActualConfig(int robot, std::vector< double > &out)

        Returns the current actual configuration of the robot from the
        simulator. 
        """
        return _robotsim.Simulator_getActualConfig(self, robot)


    def getActualVelocity(self, robot):
        """
        getActualVelocity(Simulator self, int robot)

        void
        Simulator::getActualVelocity(int robot, std::vector< double > &out)

        Returns the current actual velocity of the robot from the simulator.

        """
        return _robotsim.Simulator_getActualVelocity(self, robot)


    def getActualTorques(self, robot):
        """
        getActualTorques(Simulator self, int robot)

        void
        Simulator::getActualTorques(int robot, std::vector< double > &out)

        Returns the current actual torques on the robot's drivers from the
        simulator 
        """
        return _robotsim.Simulator_getActualTorques(self, robot)


    def enableContactFeedback(self, obj1, obj2):
        """
        enableContactFeedback(Simulator self, int obj1, int obj2)

        void
        Simulator::enableContactFeedback(int obj1, int obj2)

        Call this to enable contact feedback between the two objects
        (arguments are indexes returned by object.getID()). Contact feedback
        has a small overhead so you may want to do this selectively. 
        """
        return _robotsim.Simulator_enableContactFeedback(self, obj1, obj2)


    def enableContactFeedbackAll(self):
        """
        enableContactFeedbackAll(Simulator self)

        void
        Simulator::enableContactFeedbackAll()

        Call this to enable contact feedback between all pairs of objects.
        Contact feedback has a small overhead so you may want to do this
        selectively. 
        """
        return _robotsim.Simulator_enableContactFeedbackAll(self)


    def inContact(self, aid, bid):
        """
        inContact(Simulator self, int aid, int bid) -> bool

        bool
        Simulator::inContact(int aid, int bid)

        Returns true if the objects (indexes returned by object.getID()) are
        in contact on the current time step 
        """
        return _robotsim.Simulator_inContact(self, aid, bid)


    def getContacts(self, aid, bid):
        """
        getContacts(Simulator self, int aid, int bid)

        void
        Simulator::getContacts(int aid, int bid, std::vector< std::vector<
        double > > &out)

        Returns the list of contacts (x,n,kFriction) at the last time step.
        Normals point into object a. 
        """
        return _robotsim.Simulator_getContacts(self, aid, bid)


    def getContactForces(self, aid, bid):
        """
        getContactForces(Simulator self, int aid, int bid)

        void
        Simulator::getContactForces(int aid, int bid, std::vector<
        std::vector< double > > &out)

        Returns the list of contact forces on object a at the last time step.

        """
        return _robotsim.Simulator_getContactForces(self, aid, bid)


    def contactForce(self, aid, bid):
        """
        contactForce(Simulator self, int aid, int bid)

        void
        Simulator::contactForce(int aid, int bid, double out[3])

        Returns the contact force on object a at the last time step. 
        """
        return _robotsim.Simulator_contactForce(self, aid, bid)


    def contactTorque(self, aid, bid):
        """
        contactTorque(Simulator self, int aid, int bid)

        void
        Simulator::contactTorque(int aid, int bid, double out[3])

        Returns the contact force on object a (about a's origin) at the last
        time step. 
        """
        return _robotsim.Simulator_contactTorque(self, aid, bid)


    def hadContact(self, aid, bid):
        """
        hadContact(Simulator self, int aid, int bid) -> bool

        bool
        Simulator::hadContact(int aid, int bid)

        Returns true if the objects had contact over the last simulate() call.

        """
        return _robotsim.Simulator_hadContact(self, aid, bid)


    def hadSeparation(self, aid, bid):
        """
        hadSeparation(Simulator self, int aid, int bid) -> bool

        bool
        Simulator::hadSeparation(int aid, int bid)

        Returns true if the objects had ever separated during the last
        simulate() call 
        """
        return _robotsim.Simulator_hadSeparation(self, aid, bid)


    def meanContactForce(self, aid, bid):
        """
        meanContactForce(Simulator self, int aid, int bid)

        void
        Simulator::meanContactForce(int aid, int bid, double out[3])

        Returns the average contact force on object a over the last simulate()
        call 
        """
        return _robotsim.Simulator_meanContactForce(self, aid, bid)


    def controller(self, *args):
        """
        controller(Simulator self, int robot) -> SimRobotController
        controller(Simulator self, RobotModel robot) -> SimRobotController

        SimRobotController
        Simulator::controller(const RobotModel &robot) 
        """
        return _robotsim.Simulator_controller(self, *args)


    def body(self, *args):
        """
        body(Simulator self, RobotModelLink link) -> SimBody
        body(Simulator self, RigidObjectModel object) -> SimBody
        body(Simulator self, TerrainModel terrain) -> SimBody

        SimBody Simulator::body(const
        TerrainModel &terrain)

        Returns the SimBody corresponding to the given terrain. 
        """
        return _robotsim.Simulator_body(self, *args)


    def getController(self, *args):
        """
        getController(Simulator self, int robot) -> SimRobotController
        getController(Simulator self, RobotModel robot) -> SimRobotController

        SimRobotController
        Simulator::getController(const RobotModel &robot)

        Old-style: will be deprecated. 
        """
        return _robotsim.Simulator_getController(self, *args)


    def getBody(self, *args):
        """
        getBody(Simulator self, RobotModelLink link) -> SimBody
        getBody(Simulator self, RigidObjectModel object) -> SimBody
        getBody(Simulator self, TerrainModel terrain) -> SimBody

        SimBody
        Simulator::getBody(const TerrainModel &terrain)

        Old-style: will be deprecated. 
        """
        return _robotsim.Simulator_getBody(self, *args)


    def getJointForces(self, link):
        """
        getJointForces(Simulator self, RobotModelLink link)

        void
        Simulator::getJointForces(const RobotModelLink &link, double out[6])

        Returns the joint force and torque local to the link, as would be read
        by a force-torque sensor mounted at the given link's origin. The 6
        entries are (fx,fy,fz,mx,my,mz) 
        """
        return _robotsim.Simulator_getJointForces(self, link)


    def setGravity(self, g):
        """
        setGravity(Simulator self, double const [3] g)

        void
        Simulator::setGravity(const double g[3])

        Sets the overall gravity vector. 
        """
        return _robotsim.Simulator_setGravity(self, g)


    def setSimStep(self, dt):
        """
        setSimStep(Simulator self, double dt)

        void
        Simulator::setSimStep(double dt)

        Sets the internal simulation substep. Values < 0.01 are recommended.

        """
        return _robotsim.Simulator_setSimStep(self, dt)

    __swig_setmethods__["index"] = _robotsim.Simulator_index_set
    __swig_getmethods__["index"] = _robotsim.Simulator_index_get
    if _newclass:
        index = _swig_property(_robotsim.Simulator_index_get, _robotsim.Simulator_index_set)
    __swig_setmethods__["world"] = _robotsim.Simulator_world_set
    __swig_getmethods__["world"] = _robotsim.Simulator_world_get
    if _newclass:
        world = _swig_property(_robotsim.Simulator_world_get, _robotsim.Simulator_world_set)
    __swig_setmethods__["sim"] = _robotsim.Simulator_sim_set
    __swig_getmethods__["sim"] = _robotsim.Simulator_sim_get
    if _newclass:
        sim = _swig_property(_robotsim.Simulator_sim_get, _robotsim.Simulator_sim_set)
    __swig_setmethods__["initialState"] = _robotsim.Simulator_initialState_set
    __swig_getmethods__["initialState"] = _robotsim.Simulator_initialState_get
    if _newclass:
        initialState = _swig_property(_robotsim.Simulator_initialState_get, _robotsim.Simulator_initialState_set)
Simulator_swigregister = _robotsim.Simulator_swigregister
Simulator_swigregister(Simulator)

# This file is compatible with both classic and new-style classes.


