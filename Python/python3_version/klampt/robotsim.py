# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
Klamp't Core Python bindings 
------------------------------
"""


from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_robotsim', [dirname(__file__)])
        except ImportError:
            import _robotsim
            return _robotsim
        if fp is not None:
            try:
                _mod = imp.load_module('_robotsim', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _robotsim = swig_import_helper()
    del swig_import_helper
else:
    import _robotsim
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _robotsim.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _robotsim.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _robotsim.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _robotsim.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _robotsim.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _robotsim.SwigPyIterator_equal(self, x)

    def copy(self):
        return _robotsim.SwigPyIterator_copy(self)

    def __next__(self):
        return _robotsim.SwigPyIterator_next(self)

    def __next__(self):
        return _robotsim.SwigPyIterator___next__(self)

    def previous(self):
        return _robotsim.SwigPyIterator_previous(self)

    def advance(self, n):
        return _robotsim.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _robotsim.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _robotsim.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _robotsim.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _robotsim.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _robotsim.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _robotsim.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _robotsim.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class doubleArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, doubleArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, doubleArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        this = _robotsim.new_doubleArray(nelements)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_doubleArray
    __del__ = lambda self: None

    def __getitem__(self, index):
        return _robotsim.doubleArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _robotsim.doubleArray___setitem__(self, index, value)

    def cast(self):
        return _robotsim.doubleArray_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _robotsim.doubleArray_frompointer
    if _newclass:
        frompointer = staticmethod(_robotsim.doubleArray_frompointer)
doubleArray_swigregister = _robotsim.doubleArray_swigregister
doubleArray_swigregister(doubleArray)

def doubleArray_frompointer(t):
    return _robotsim.doubleArray_frompointer(t)
doubleArray_frompointer = _robotsim.doubleArray_frompointer

class floatArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, floatArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, floatArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        this = _robotsim.new_floatArray(nelements)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_floatArray
    __del__ = lambda self: None

    def __getitem__(self, index):
        return _robotsim.floatArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _robotsim.floatArray___setitem__(self, index, value)

    def cast(self):
        return _robotsim.floatArray_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _robotsim.floatArray_frompointer
    if _newclass:
        frompointer = staticmethod(_robotsim.floatArray_frompointer)
floatArray_swigregister = _robotsim.floatArray_swigregister
floatArray_swigregister(floatArray)

def floatArray_frompointer(t):
    return _robotsim.floatArray_frompointer(t)
floatArray_frompointer = _robotsim.floatArray_frompointer

class intArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, intArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, intArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        this = _robotsim.new_intArray(nelements)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_intArray
    __del__ = lambda self: None

    def __getitem__(self, index):
        return _robotsim.intArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _robotsim.intArray___setitem__(self, index, value)

    def cast(self):
        return _robotsim.intArray_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _robotsim.intArray_frompointer
    if _newclass:
        frompointer = staticmethod(_robotsim.intArray_frompointer)
intArray_swigregister = _robotsim.intArray_swigregister
intArray_swigregister(intArray)

def intArray_frompointer(t):
    return _robotsim.intArray_frompointer(t)
intArray_frompointer = _robotsim.intArray_frompointer

class stringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, stringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, stringVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _robotsim.stringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __bool__(self):
        return _robotsim.stringVector___nonzero__(self)

    def __bool__(self):
        return _robotsim.stringVector___bool__(self)

    def __len__(self):
        return _robotsim.stringVector___len__(self)

    def __getslice__(self, i, j):
        return _robotsim.stringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _robotsim.stringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _robotsim.stringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _robotsim.stringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _robotsim.stringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _robotsim.stringVector___setitem__(self, *args)

    def pop(self):
        return _robotsim.stringVector_pop(self)

    def append(self, x):
        return _robotsim.stringVector_append(self, x)

    def empty(self):
        return _robotsim.stringVector_empty(self)

    def size(self):
        return _robotsim.stringVector_size(self)

    def swap(self, v):
        return _robotsim.stringVector_swap(self, v)

    def begin(self):
        return _robotsim.stringVector_begin(self)

    def end(self):
        return _robotsim.stringVector_end(self)

    def rbegin(self):
        return _robotsim.stringVector_rbegin(self)

    def rend(self):
        return _robotsim.stringVector_rend(self)

    def clear(self):
        return _robotsim.stringVector_clear(self)

    def get_allocator(self):
        return _robotsim.stringVector_get_allocator(self)

    def pop_back(self):
        return _robotsim.stringVector_pop_back(self)

    def erase(self, *args):
        return _robotsim.stringVector_erase(self, *args)

    def __init__(self, *args):
        this = _robotsim.new_stringVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _robotsim.stringVector_push_back(self, x)

    def front(self):
        return _robotsim.stringVector_front(self)

    def back(self):
        return _robotsim.stringVector_back(self)

    def assign(self, n, x):
        return _robotsim.stringVector_assign(self, n, x)

    def resize(self, *args):
        return _robotsim.stringVector_resize(self, *args)

    def insert(self, *args):
        return _robotsim.stringVector_insert(self, *args)

    def reserve(self, n):
        return _robotsim.stringVector_reserve(self, n)

    def capacity(self):
        return _robotsim.stringVector_capacity(self)
    __swig_destroy__ = _robotsim.delete_stringVector
    __del__ = lambda self: None
stringVector_swigregister = _robotsim.stringVector_swigregister
stringVector_swigregister(stringVector)

class doubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, doubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, doubleVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _robotsim.doubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __bool__(self):
        return _robotsim.doubleVector___nonzero__(self)

    def __bool__(self):
        return _robotsim.doubleVector___bool__(self)

    def __len__(self):
        return _robotsim.doubleVector___len__(self)

    def __getslice__(self, i, j):
        return _robotsim.doubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _robotsim.doubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _robotsim.doubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _robotsim.doubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _robotsim.doubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _robotsim.doubleVector___setitem__(self, *args)

    def pop(self):
        return _robotsim.doubleVector_pop(self)

    def append(self, x):
        return _robotsim.doubleVector_append(self, x)

    def empty(self):
        return _robotsim.doubleVector_empty(self)

    def size(self):
        return _robotsim.doubleVector_size(self)

    def swap(self, v):
        return _robotsim.doubleVector_swap(self, v)

    def begin(self):
        return _robotsim.doubleVector_begin(self)

    def end(self):
        return _robotsim.doubleVector_end(self)

    def rbegin(self):
        return _robotsim.doubleVector_rbegin(self)

    def rend(self):
        return _robotsim.doubleVector_rend(self)

    def clear(self):
        return _robotsim.doubleVector_clear(self)

    def get_allocator(self):
        return _robotsim.doubleVector_get_allocator(self)

    def pop_back(self):
        return _robotsim.doubleVector_pop_back(self)

    def erase(self, *args):
        return _robotsim.doubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _robotsim.new_doubleVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _robotsim.doubleVector_push_back(self, x)

    def front(self):
        return _robotsim.doubleVector_front(self)

    def back(self):
        return _robotsim.doubleVector_back(self)

    def assign(self, n, x):
        return _robotsim.doubleVector_assign(self, n, x)

    def resize(self, *args):
        return _robotsim.doubleVector_resize(self, *args)

    def insert(self, *args):
        return _robotsim.doubleVector_insert(self, *args)

    def reserve(self, n):
        return _robotsim.doubleVector_reserve(self, n)

    def capacity(self):
        return _robotsim.doubleVector_capacity(self)
    __swig_destroy__ = _robotsim.delete_doubleVector
    __del__ = lambda self: None
doubleVector_swigregister = _robotsim.doubleVector_swigregister
doubleVector_swigregister(doubleVector)

class floatVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, floatVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, floatVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _robotsim.floatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __bool__(self):
        return _robotsim.floatVector___nonzero__(self)

    def __bool__(self):
        return _robotsim.floatVector___bool__(self)

    def __len__(self):
        return _robotsim.floatVector___len__(self)

    def __getslice__(self, i, j):
        return _robotsim.floatVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _robotsim.floatVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _robotsim.floatVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _robotsim.floatVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _robotsim.floatVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _robotsim.floatVector___setitem__(self, *args)

    def pop(self):
        return _robotsim.floatVector_pop(self)

    def append(self, x):
        return _robotsim.floatVector_append(self, x)

    def empty(self):
        return _robotsim.floatVector_empty(self)

    def size(self):
        return _robotsim.floatVector_size(self)

    def swap(self, v):
        return _robotsim.floatVector_swap(self, v)

    def begin(self):
        return _robotsim.floatVector_begin(self)

    def end(self):
        return _robotsim.floatVector_end(self)

    def rbegin(self):
        return _robotsim.floatVector_rbegin(self)

    def rend(self):
        return _robotsim.floatVector_rend(self)

    def clear(self):
        return _robotsim.floatVector_clear(self)

    def get_allocator(self):
        return _robotsim.floatVector_get_allocator(self)

    def pop_back(self):
        return _robotsim.floatVector_pop_back(self)

    def erase(self, *args):
        return _robotsim.floatVector_erase(self, *args)

    def __init__(self, *args):
        this = _robotsim.new_floatVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _robotsim.floatVector_push_back(self, x)

    def front(self):
        return _robotsim.floatVector_front(self)

    def back(self):
        return _robotsim.floatVector_back(self)

    def assign(self, n, x):
        return _robotsim.floatVector_assign(self, n, x)

    def resize(self, *args):
        return _robotsim.floatVector_resize(self, *args)

    def insert(self, *args):
        return _robotsim.floatVector_insert(self, *args)

    def reserve(self, n):
        return _robotsim.floatVector_reserve(self, n)

    def capacity(self):
        return _robotsim.floatVector_capacity(self)
    __swig_destroy__ = _robotsim.delete_floatVector
    __del__ = lambda self: None
floatVector_swigregister = _robotsim.floatVector_swigregister
floatVector_swigregister(floatVector)

class intVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, intVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, intVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _robotsim.intVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __bool__(self):
        return _robotsim.intVector___nonzero__(self)

    def __bool__(self):
        return _robotsim.intVector___bool__(self)

    def __len__(self):
        return _robotsim.intVector___len__(self)

    def __getslice__(self, i, j):
        return _robotsim.intVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _robotsim.intVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _robotsim.intVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _robotsim.intVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _robotsim.intVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _robotsim.intVector___setitem__(self, *args)

    def pop(self):
        return _robotsim.intVector_pop(self)

    def append(self, x):
        return _robotsim.intVector_append(self, x)

    def empty(self):
        return _robotsim.intVector_empty(self)

    def size(self):
        return _robotsim.intVector_size(self)

    def swap(self, v):
        return _robotsim.intVector_swap(self, v)

    def begin(self):
        return _robotsim.intVector_begin(self)

    def end(self):
        return _robotsim.intVector_end(self)

    def rbegin(self):
        return _robotsim.intVector_rbegin(self)

    def rend(self):
        return _robotsim.intVector_rend(self)

    def clear(self):
        return _robotsim.intVector_clear(self)

    def get_allocator(self):
        return _robotsim.intVector_get_allocator(self)

    def pop_back(self):
        return _robotsim.intVector_pop_back(self)

    def erase(self, *args):
        return _robotsim.intVector_erase(self, *args)

    def __init__(self, *args):
        this = _robotsim.new_intVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _robotsim.intVector_push_back(self, x)

    def front(self):
        return _robotsim.intVector_front(self)

    def back(self):
        return _robotsim.intVector_back(self)

    def assign(self, n, x):
        return _robotsim.intVector_assign(self, n, x)

    def resize(self, *args):
        return _robotsim.intVector_resize(self, *args)

    def insert(self, *args):
        return _robotsim.intVector_insert(self, *args)

    def reserve(self, n):
        return _robotsim.intVector_reserve(self, n)

    def capacity(self):
        return _robotsim.intVector_capacity(self)
    __swig_destroy__ = _robotsim.delete_intVector
    __del__ = lambda self: None
intVector_swigregister = _robotsim.intVector_swigregister
intVector_swigregister(intVector)

class doubleMatrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, doubleMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, doubleMatrix, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _robotsim.doubleMatrix_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __bool__(self):
        return _robotsim.doubleMatrix___nonzero__(self)

    def __bool__(self):
        return _robotsim.doubleMatrix___bool__(self)

    def __len__(self):
        return _robotsim.doubleMatrix___len__(self)

    def __getslice__(self, i, j):
        return _robotsim.doubleMatrix___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _robotsim.doubleMatrix___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _robotsim.doubleMatrix___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _robotsim.doubleMatrix___delitem__(self, *args)

    def __getitem__(self, *args):
        return _robotsim.doubleMatrix___getitem__(self, *args)

    def __setitem__(self, *args):
        return _robotsim.doubleMatrix___setitem__(self, *args)

    def pop(self):
        return _robotsim.doubleMatrix_pop(self)

    def append(self, x):
        return _robotsim.doubleMatrix_append(self, x)

    def empty(self):
        return _robotsim.doubleMatrix_empty(self)

    def size(self):
        return _robotsim.doubleMatrix_size(self)

    def swap(self, v):
        return _robotsim.doubleMatrix_swap(self, v)

    def begin(self):
        return _robotsim.doubleMatrix_begin(self)

    def end(self):
        return _robotsim.doubleMatrix_end(self)

    def rbegin(self):
        return _robotsim.doubleMatrix_rbegin(self)

    def rend(self):
        return _robotsim.doubleMatrix_rend(self)

    def clear(self):
        return _robotsim.doubleMatrix_clear(self)

    def get_allocator(self):
        return _robotsim.doubleMatrix_get_allocator(self)

    def pop_back(self):
        return _robotsim.doubleMatrix_pop_back(self)

    def erase(self, *args):
        return _robotsim.doubleMatrix_erase(self, *args)

    def __init__(self, *args):
        this = _robotsim.new_doubleMatrix(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _robotsim.doubleMatrix_push_back(self, x)

    def front(self):
        return _robotsim.doubleMatrix_front(self)

    def back(self):
        return _robotsim.doubleMatrix_back(self)

    def assign(self, n, x):
        return _robotsim.doubleMatrix_assign(self, n, x)

    def resize(self, *args):
        return _robotsim.doubleMatrix_resize(self, *args)

    def insert(self, *args):
        return _robotsim.doubleMatrix_insert(self, *args)

    def reserve(self, n):
        return _robotsim.doubleMatrix_reserve(self, n)

    def capacity(self):
        return _robotsim.doubleMatrix_capacity(self)
    __swig_destroy__ = _robotsim.delete_doubleMatrix
    __del__ = lambda self: None
doubleMatrix_swigregister = _robotsim.doubleMatrix_swigregister
doubleMatrix_swigregister(doubleMatrix)

class TriangleMesh(_object):
    """


    A 3D indexed triangle mesh class.  

    Attributes:  

        vertices (SWIG vector of floats):  a list of vertices, given as
            a flattened coordinate list [x1, y1, z1, x2, y2, ...]
        indices (SWIG vector of ints): a list of triangle vertices given
            as indices into the vertices list, i.e., [a1,b1,c2, a2,b2,c2, ...]  

    Note: because the bindings are generated by SWIG, you can access the indices /
    vertices members via some automatically generated accessors / modifiers. In
    particular len(), append(), and indexing via [] are useful. Some other methods
    like resize() are also provided. However, you CANNOT set these items via
    assignment.  

    Examples::  

        m = TriangleMesh()
        m.vertices.append(0)
        m.vertices.append(0)
        m.vertices.append(0)
        print len(m.vertices)  #prints 3
        m.vertices = [0,0,0]   #this is an error
        m.vertices += [1,2,3]   #this is also an error  

    To get all vertices as a numpy array:  

        verts = np.array(m.vertices).reshape((len(m.vertices)//3,3))  

    To get all indices as a numpy array:  

        inds = np.array(m.indices,dtype=np.int32).reshape((len(m.indices)//3,3))  

    (Or use the convenience functions in klampt.io.numpy)  

    C++ includes: geometry.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriangleMesh, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TriangleMesh, name)
    __repr__ = _swig_repr

    def translate(self, t):
        """
        Translates all the vertices by v=v+t.  

        Args:
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.TriangleMesh_translate(self, t)


    def transform(self, R, t):
        """
        Transforms all the vertices by the rigid transform v=R*v+t.  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.TriangleMesh_transform(self, R, t)

    __swig_setmethods__["indices"] = _robotsim.TriangleMesh_indices_set
    __swig_getmethods__["indices"] = _robotsim.TriangleMesh_indices_get
    if _newclass:
        indices = _swig_property(_robotsim.TriangleMesh_indices_get, _robotsim.TriangleMesh_indices_set)
    __swig_setmethods__["vertices"] = _robotsim.TriangleMesh_vertices_set
    __swig_getmethods__["vertices"] = _robotsim.TriangleMesh_vertices_get
    if _newclass:
        vertices = _swig_property(_robotsim.TriangleMesh_vertices_get, _robotsim.TriangleMesh_vertices_set)

    def __init__(self):
        """
        A 3D indexed triangle mesh class.  


        Attributes:  

            vertices (SWIG vector of floats):  a list of vertices, given as
                a flattened coordinate list [x1, y1, z1, x2, y2, ...]
            indices (SWIG vector of ints): a list of triangle vertices given
                as indices into the vertices list, i.e., [a1,b1,c2, a2,b2,c2, ...]  

        Note: because the bindings are generated by SWIG, you can access the indices /
        vertices members via some automatically generated accessors / modifiers. In
        particular len(), append(), and indexing via [] are useful. Some other methods
        like resize() are also provided. However, you CANNOT set these items via
        assignment.  

        Examples::  

            m = TriangleMesh()
            m.vertices.append(0)
            m.vertices.append(0)
            m.vertices.append(0)
            print len(m.vertices)  #prints 3
            m.vertices = [0,0,0]   #this is an error
            m.vertices += [1,2,3]   #this is also an error  

        To get all vertices as a numpy array:  

            verts = np.array(m.vertices).reshape((len(m.vertices)//3,3))  

        To get all indices as a numpy array:  

            inds = np.array(m.indices,dtype=np.int32).reshape((len(m.indices)//3,3))  

        (Or use the convenience functions in klampt.io.numpy)  

        C++ includes: geometry.h

        """
        this = _robotsim.new_TriangleMesh()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_TriangleMesh
    __del__ = lambda self: None
TriangleMesh_swigregister = _robotsim.TriangleMesh_swigregister
TriangleMesh_swigregister(TriangleMesh)

class PointCloud(_object):
    """


    A 3D point cloud class.  

    Attributes:  

        vertices (SWIG vector of floats): a list of vertices, given as a
            list [x1, y1, z1, x2, y2, ... zn]
        properties (SWIG vector of floats): a list of vertex properties,
           given as a list [p11, p21, ..., pk1,  p12, p22, ..., pk2, ...,
           p1n, p2n, ..., pkn] where each vertex has k properties.  The
           name of each property is given by the ``propertyNames`` member.
        propertyNames (SWIG vector of strs): a list of the names of each
           property
        settings (SWIG map of strs to strs): a general property map .  

    Note: because the bindings are generated by SWIG, you can access the
    vertices/properties/propertyName members via some automatically generated
    accessors / modifiers. In particular len(), append(), and indexing via [] are
    useful. Some other methods like resize() are also provided. However, you CANNOT
    set these items via assignment.  

    Properties are usually lowercase but follow PCL naming convention, and often
    include:  

    *   normal_x, normal_y, normal_z: the outward normal  
    *   rgb, rgba: integer encoding of RGB (24 bit int) or RGBA color (32 bit int)  
    *   opacity: opacity, in range [0,1]  
    *   c: opacity, in range [0,255]  
    *   r,g,b,a: color channels, in range [0,1]  
    *   u,v: texture coordinate  

    Settings are usually lowercase but follow PCL naming convention, and often
    include:  

    *   version: version of the PCL file, typically "0.7"  
    *   id: integer id  
    *   width: the width of a structured point cloud  
    *   height: the height of a structured point cloud  
    *   viewpoint: "ox oy oz qw qx qy qz"  

    Examples::  

        pc = PointCloud()
        pc.propertyNames.append('rgb')
        #add 1 point with coordinates (0,0,0) and color #000000 (black)
        pc.vertices.append(0)
        pc.vertices.append(0)
        pc.vertices.append(0)
        pc.properties.append(0)
        print len(pc.vertices)  #prints 3
        print pc.numPoints()  #prints 1
        #add another point with coordinates (1,2,3)
        pc.addPoint([1,2,3])
        #this prints 2
        print pc.numPoints()
        #this prints 2, because there is 1 property category x 2 points
        print len(pc.properties.size())
        #this prints 0; this is the default value added when addPoint is called
        print pc.getProperty(1,0)  

    To get all points as an n x 3 numpy array:  

        points = np.array(pc.vertices).reshape((pc.numPoints(),3))  

    To get all properties as a n x k numpy array:  

    properties = np.array(pc.properties).reshape((p.numPoints(),p.numProperties()))  

    (Or use the convenience functions in klampt.io.numpy)  

    C++ includes: geometry.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PointCloud, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PointCloud, name)
    __repr__ = _swig_repr

    def numPoints(self):
        """
        Returns the number of points.  

        Returns:
            (int):
        """
        return _robotsim.PointCloud_numPoints(self)


    def numProperties(self):
        """
        Returns the number of properties.  

        Returns:
            (int):
        """
        return _robotsim.PointCloud_numProperties(self)


    def setPoints(self, num, plist):
        """
        Sets all the points to the given list (a 3n-list)  

        Args:
            num (int)
            plist (:obj:`list of floats`)
        """
        return _robotsim.PointCloud_setPoints(self, num, plist)


    def addPoint(self, p):
        """
        Adds a point. Sets all its properties to 0. Returns the index.  

        Args:
            p (:obj:`list of 3 floats`)
        Returns:
            (int):
        """
        return _robotsim.PointCloud_addPoint(self, p)


    def setPoint(self, index, p):
        """
        Sets the position of the point at the given index to p.  

        Args:
            index (int)
            p (:obj:`list of 3 floats`)
        """
        return _robotsim.PointCloud_setPoint(self, index, p)


    def getPoint(self, index):
        """
        Retrieves the position of the point at the given index.  

        Args:
            index (int)
        """
        return _robotsim.PointCloud_getPoint(self, index)


    def addProperty(self, *args):
        """
        Adds a new property with name pname, and sets values for this property to the
        given list (a n-list)  

        addProperty (pname)

        addProperty (pname,properties)


        Args:
            pname (str): 
            properties (:obj:`list of floats`, optional): 
        """
        return _robotsim.PointCloud_addProperty(self, *args)


    def setProperties(self, *args):
        """
        Sets property pindex of all points to the given list (a n-list)  

        setProperties (properties)

        setProperties (pindex,properties)


        Args:
            properties (:obj:`list of floats`): 
            pindex (int, optional): 
        """
        return _robotsim.PointCloud_setProperties(self, *args)


    def setProperty(self, *args):
        """
        Sets the property named pname of point index to the given value.  

        setProperty (index,pindex,value)

        setProperty (index,pname,value)


        Args:
            index (int): 
            pindex (int, optional): 
            value (float): 
            pname (str, optional): 
        """
        return _robotsim.PointCloud_setProperty(self, *args)


    def getProperty(self, *args):
        """
        Gets the property named pname of point index.  

        getProperty (index,pindex): float

        getProperty (index,pname): float


        Args:
            index (int): 
            pindex (int, optional): 
            pname (str, optional): 

        Returns:
            (float):
        """
        return _robotsim.PointCloud_getProperty(self, *args)


    def translate(self, t):
        """
        Translates all the points by v=v+t.  

        Args:
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.PointCloud_translate(self, t)


    def transform(self, R, t):
        """
        Transforms all the points by the rigid transform v=R*v+t.  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.PointCloud_transform(self, R, t)


    def join(self, pc):
        """
        Adds the given point cloud to this one. They must share the same properties or
        else an exception is raised.  

        Args:
            pc (:class:`~klampt.PointCloud`)
        """
        return _robotsim.PointCloud_join(self, pc)


    def setSetting(self, key, value):
        """
        Sets the given setting.  

        Args:
            key (str)
            value (str)
        """
        return _robotsim.PointCloud_setSetting(self, key, value)


    def getSetting(self, key):
        """
        Retrieves the given setting.  

        Args:
            key (str)
        Returns:
            (str):
        """
        return _robotsim.PointCloud_getSetting(self, key)

    __swig_setmethods__["vertices"] = _robotsim.PointCloud_vertices_set
    __swig_getmethods__["vertices"] = _robotsim.PointCloud_vertices_get
    if _newclass:
        vertices = _swig_property(_robotsim.PointCloud_vertices_get, _robotsim.PointCloud_vertices_set)
    __swig_setmethods__["propertyNames"] = _robotsim.PointCloud_propertyNames_set
    __swig_getmethods__["propertyNames"] = _robotsim.PointCloud_propertyNames_get
    if _newclass:
        propertyNames = _swig_property(_robotsim.PointCloud_propertyNames_get, _robotsim.PointCloud_propertyNames_set)
    __swig_setmethods__["properties"] = _robotsim.PointCloud_properties_set
    __swig_getmethods__["properties"] = _robotsim.PointCloud_properties_get
    if _newclass:
        properties = _swig_property(_robotsim.PointCloud_properties_get, _robotsim.PointCloud_properties_set)
    __swig_setmethods__["settings"] = _robotsim.PointCloud_settings_set
    __swig_getmethods__["settings"] = _robotsim.PointCloud_settings_get
    if _newclass:
        settings = _swig_property(_robotsim.PointCloud_settings_get, _robotsim.PointCloud_settings_set)

    def __init__(self):
        """
        A 3D point cloud class.  


        Attributes:  

            vertices (SWIG vector of floats): a list of vertices, given as a
                list [x1, y1, z1, x2, y2, ... zn]
            properties (SWIG vector of floats): a list of vertex properties,
               given as a list [p11, p21, ..., pk1,  p12, p22, ..., pk2, ...,
               p1n, p2n, ..., pkn] where each vertex has k properties.  The
               name of each property is given by the ``propertyNames`` member.
            propertyNames (SWIG vector of strs): a list of the names of each
               property
            settings (SWIG map of strs to strs): a general property map .  

        Note: because the bindings are generated by SWIG, you can access the
        vertices/properties/propertyName members via some automatically generated
        accessors / modifiers. In particular len(), append(), and indexing via [] are
        useful. Some other methods like resize() are also provided. However, you CANNOT
        set these items via assignment.  

        Properties are usually lowercase but follow PCL naming convention, and often
        include:  

        *   normal_x, normal_y, normal_z: the outward normal  
        *   rgb, rgba: integer encoding of RGB (24 bit int) or RGBA color (32 bit int)  
        *   opacity: opacity, in range [0,1]  
        *   c: opacity, in range [0,255]  
        *   r,g,b,a: color channels, in range [0,1]  
        *   u,v: texture coordinate  

        Settings are usually lowercase but follow PCL naming convention, and often
        include:  

        *   version: version of the PCL file, typically "0.7"  
        *   id: integer id  
        *   width: the width of a structured point cloud  
        *   height: the height of a structured point cloud  
        *   viewpoint: "ox oy oz qw qx qy qz"  

        Examples::  

            pc = PointCloud()
            pc.propertyNames.append('rgb')
            #add 1 point with coordinates (0,0,0) and color #000000 (black)
            pc.vertices.append(0)
            pc.vertices.append(0)
            pc.vertices.append(0)
            pc.properties.append(0)
            print len(pc.vertices)  #prints 3
            print pc.numPoints()  #prints 1
            #add another point with coordinates (1,2,3)
            pc.addPoint([1,2,3])
            #this prints 2
            print pc.numPoints()
            #this prints 2, because there is 1 property category x 2 points
            print len(pc.properties.size())
            #this prints 0; this is the default value added when addPoint is called
            print pc.getProperty(1,0)  

        To get all points as an n x 3 numpy array:  

            points = np.array(pc.vertices).reshape((pc.numPoints(),3))  

        To get all properties as a n x k numpy array:  

        properties = np.array(pc.properties).reshape((p.numPoints(),p.numProperties()))  

        (Or use the convenience functions in klampt.io.numpy)  

        C++ includes: geometry.h

        """
        this = _robotsim.new_PointCloud()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_PointCloud
    __del__ = lambda self: None
PointCloud_swigregister = _robotsim.PointCloud_swigregister
PointCloud_swigregister(PointCloud)

class GeometricPrimitive(_object):
    """


    A geometric primitive. So far only points, spheres, segments, and AABBs can be
    constructed manually in the Python API.  

    C++ includes: geometry.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeometricPrimitive, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GeometricPrimitive, name)
    __repr__ = _swig_repr

    def setPoint(self, pt):
        """
        Args:
            pt (:obj:`list of 3 floats`)
        """
        return _robotsim.GeometricPrimitive_setPoint(self, pt)


    def setSphere(self, c, r):
        """
        Args:
            c (:obj:`list of 3 floats`)
            r (float)
        """
        return _robotsim.GeometricPrimitive_setSphere(self, c, r)


    def setSegment(self, a, b):
        """
        Args:
            a (:obj:`list of 3 floats`)
            b (:obj:`list of 3 floats`)
        """
        return _robotsim.GeometricPrimitive_setSegment(self, a, b)


    def setAABB(self, bmin, bmax):
        """
        Args:
            bmin (:obj:`list of 3 floats`)
            bmax (:obj:`list of 3 floats`)
        """
        return _robotsim.GeometricPrimitive_setAABB(self, bmin, bmax)


    def loadString(self, str):
        """
        Args:
            str (str)
        Returns:
            (bool):
        """
        return _robotsim.GeometricPrimitive_loadString(self, str)


    def saveString(self):
        """
        Returns:
            (str):
        """
        return _robotsim.GeometricPrimitive_saveString(self)

    __swig_setmethods__["type"] = _robotsim.GeometricPrimitive_type_set
    __swig_getmethods__["type"] = _robotsim.GeometricPrimitive_type_get
    if _newclass:
        type = _swig_property(_robotsim.GeometricPrimitive_type_get, _robotsim.GeometricPrimitive_type_set)
    __swig_setmethods__["properties"] = _robotsim.GeometricPrimitive_properties_set
    __swig_getmethods__["properties"] = _robotsim.GeometricPrimitive_properties_get
    if _newclass:
        properties = _swig_property(_robotsim.GeometricPrimitive_properties_get, _robotsim.GeometricPrimitive_properties_set)

    def __init__(self):
        """
        A geometric primitive. So far only points, spheres, segments, and AABBs can be
        constructed manually in the Python API.  


        C++ includes: geometry.h

        """
        this = _robotsim.new_GeometricPrimitive()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_GeometricPrimitive
    __del__ = lambda self: None
GeometricPrimitive_swigregister = _robotsim.GeometricPrimitive_swigregister
GeometricPrimitive_swigregister(GeometricPrimitive)

class VolumeGrid(_object):
    """


    An axis-aligned volumetric grid, typically a signed distance transform with > 0
    indicating outside and < 0 indicating inside. Can also store an occupancy grid
    with 1 indicating inside and 0 indicating outside.  

    Attributes: bbox (SWIG vector of 6 doubles): contains min and max bounds
    (xmin,ymin,zmin),(xmax,ymax,zmax) dims (SWIG vector of of 3 ints): size of grid
    in each of 3 dimensions values (SWIG vector of doubles): contains a 3D array of
    dims[0]*dims[1]*dims[1] values.  

    The cell index (i,j,k) is flattened to i*dims[1]*dims[2] + j*dims[2] + k.  

    The array index i is associated to cell index (i/(dims[1]*dims[2]), (i/dims[2])
    % dims[1], idims[2])  

    C++ includes: geometry.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VolumeGrid, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VolumeGrid, name)
    __repr__ = _swig_repr

    def setBounds(self, bmin, bmax):
        """
        Args:
            bmin (:obj:`list of 3 floats`)
            bmax (:obj:`list of 3 floats`)
        """
        return _robotsim.VolumeGrid_setBounds(self, bmin, bmax)


    def resize(self, sx, sy, sz):
        """
        Args:
            sx (int)
            sy (int)
            sz (int)
        """
        return _robotsim.VolumeGrid_resize(self, sx, sy, sz)


    def set(self, *args):
        """
        set (value)

        set (i,j,k,value)


        Args:
            value (float): 
            i (int, optional): 
            j (int, optional): 
            k (int, optional): 
        """
        return _robotsim.VolumeGrid_set(self, *args)


    def get(self, i, j, k):
        """
        Args:
            i (int)
            j (int)
            k (int)
        Returns:
            (float):
        """
        return _robotsim.VolumeGrid_get(self, i, j, k)


    def shift(self, dv):
        """
        Args:
            dv (float)
        """
        return _robotsim.VolumeGrid_shift(self, dv)

    __swig_setmethods__["bbox"] = _robotsim.VolumeGrid_bbox_set
    __swig_getmethods__["bbox"] = _robotsim.VolumeGrid_bbox_get
    if _newclass:
        bbox = _swig_property(_robotsim.VolumeGrid_bbox_get, _robotsim.VolumeGrid_bbox_set)
    __swig_setmethods__["dims"] = _robotsim.VolumeGrid_dims_set
    __swig_getmethods__["dims"] = _robotsim.VolumeGrid_dims_get
    if _newclass:
        dims = _swig_property(_robotsim.VolumeGrid_dims_get, _robotsim.VolumeGrid_dims_set)
    __swig_setmethods__["values"] = _robotsim.VolumeGrid_values_set
    __swig_getmethods__["values"] = _robotsim.VolumeGrid_values_get
    if _newclass:
        values = _swig_property(_robotsim.VolumeGrid_values_get, _robotsim.VolumeGrid_values_set)

    def __init__(self):
        """
        An axis-aligned volumetric grid, typically a signed distance transform with > 0
        indicating outside and < 0 indicating inside. Can also store an occupancy grid
        with 1 indicating inside and 0 indicating outside.  


        Attributes: bbox (SWIG vector of 6 doubles): contains min and max bounds
        (xmin,ymin,zmin),(xmax,ymax,zmax) dims (SWIG vector of of 3 ints): size of grid
        in each of 3 dimensions values (SWIG vector of doubles): contains a 3D array of
        dims[0]*dims[1]*dims[1] values.  

        The cell index (i,j,k) is flattened to i*dims[1]*dims[2] + j*dims[2] + k.  

        The array index i is associated to cell index (i/(dims[1]*dims[2]), (i/dims[2])
        % dims[1], idims[2])  

        C++ includes: geometry.h

        """
        this = _robotsim.new_VolumeGrid()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_VolumeGrid
    __del__ = lambda self: None
VolumeGrid_swigregister = _robotsim.VolumeGrid_swigregister
VolumeGrid_swigregister(VolumeGrid)

class DistanceQuerySettings(_object):
    """


    Configures the _ext distance queries of :class:`~klampt.Geometry3D`.  

    The calculated result satisfies :math:`Dcalc \leq D(1+relErr) + absErr` unless
    :math:`D \geq upperBound`, in which case Dcalc=upperBound may be returned.  

    Attributes:  

        relErr (float, optional): Allows a relative error in the reported
            distance to speed up computation.  Default 0.
        absErr (float, optional): Allows an absolute error in the reported
            distance to speed up computation.  Default 0.
        upperBound (float, optional): The calculation may branch if D exceeds
            this bound.  

    C++ includes: geometry.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistanceQuerySettings, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DistanceQuerySettings, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        """
        this = _robotsim.new_DistanceQuerySettings()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["relErr"] = _robotsim.DistanceQuerySettings_relErr_set
    __swig_getmethods__["relErr"] = _robotsim.DistanceQuerySettings_relErr_get
    if _newclass:
        relErr = _swig_property(_robotsim.DistanceQuerySettings_relErr_get, _robotsim.DistanceQuerySettings_relErr_set)
    __swig_setmethods__["absErr"] = _robotsim.DistanceQuerySettings_absErr_set
    __swig_getmethods__["absErr"] = _robotsim.DistanceQuerySettings_absErr_get
    if _newclass:
        absErr = _swig_property(_robotsim.DistanceQuerySettings_absErr_get, _robotsim.DistanceQuerySettings_absErr_set)
    __swig_setmethods__["upperBound"] = _robotsim.DistanceQuerySettings_upperBound_set
    __swig_getmethods__["upperBound"] = _robotsim.DistanceQuerySettings_upperBound_get
    if _newclass:
        upperBound = _swig_property(_robotsim.DistanceQuerySettings_upperBound_get, _robotsim.DistanceQuerySettings_upperBound_set)
    __swig_destroy__ = _robotsim.delete_DistanceQuerySettings
    __del__ = lambda self: None
DistanceQuerySettings_swigregister = _robotsim.DistanceQuerySettings_swigregister
DistanceQuerySettings_swigregister(DistanceQuerySettings)

class DistanceQueryResult(_object):
    """


    The result from a "fancy" distance query of :class:`~klampt.Geometry3D`.  

    Attributes:  

        d (float): The calculated distance, with negative values indicating
            penetration.  Can also be upperBound if the branch was hit.
        hasClosestPoints (bool):  If true, the closest point information is
            given in cp0 and cp1, and elem1 and elem2
        hasGradients (bool):  f true, distance gradient information is given
            in grad0 and grad1.
        cp1, cp2 (list of 3 floats, optional): closest points on self vs other,
            both given in world coordinates
        grad1, grad2 (list of 3 floats, optional): the gradients of the
            objects' signed distance fields at the closest points.  Given in
            world coordinates.

            I.e., to move object1 to touch object2, move it in direction
            grad1 by distance -d.  Note that grad2 is always -grad1.
        elems1, elems2 (int): for compound objects, these are the
            element indices corresponding to the closest points.  

    C++ includes: geometry.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistanceQueryResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DistanceQueryResult, name)
    __repr__ = _swig_repr
    __swig_setmethods__["d"] = _robotsim.DistanceQueryResult_d_set
    __swig_getmethods__["d"] = _robotsim.DistanceQueryResult_d_get
    if _newclass:
        d = _swig_property(_robotsim.DistanceQueryResult_d_get, _robotsim.DistanceQueryResult_d_set)
    __swig_setmethods__["hasClosestPoints"] = _robotsim.DistanceQueryResult_hasClosestPoints_set
    __swig_getmethods__["hasClosestPoints"] = _robotsim.DistanceQueryResult_hasClosestPoints_get
    if _newclass:
        hasClosestPoints = _swig_property(_robotsim.DistanceQueryResult_hasClosestPoints_get, _robotsim.DistanceQueryResult_hasClosestPoints_set)
    __swig_setmethods__["hasGradients"] = _robotsim.DistanceQueryResult_hasGradients_set
    __swig_getmethods__["hasGradients"] = _robotsim.DistanceQueryResult_hasGradients_get
    if _newclass:
        hasGradients = _swig_property(_robotsim.DistanceQueryResult_hasGradients_get, _robotsim.DistanceQueryResult_hasGradients_set)
    __swig_setmethods__["cp1"] = _robotsim.DistanceQueryResult_cp1_set
    __swig_getmethods__["cp1"] = _robotsim.DistanceQueryResult_cp1_get
    if _newclass:
        cp1 = _swig_property(_robotsim.DistanceQueryResult_cp1_get, _robotsim.DistanceQueryResult_cp1_set)
    __swig_setmethods__["cp2"] = _robotsim.DistanceQueryResult_cp2_set
    __swig_getmethods__["cp2"] = _robotsim.DistanceQueryResult_cp2_get
    if _newclass:
        cp2 = _swig_property(_robotsim.DistanceQueryResult_cp2_get, _robotsim.DistanceQueryResult_cp2_set)
    __swig_setmethods__["grad1"] = _robotsim.DistanceQueryResult_grad1_set
    __swig_getmethods__["grad1"] = _robotsim.DistanceQueryResult_grad1_get
    if _newclass:
        grad1 = _swig_property(_robotsim.DistanceQueryResult_grad1_get, _robotsim.DistanceQueryResult_grad1_set)
    __swig_setmethods__["grad2"] = _robotsim.DistanceQueryResult_grad2_set
    __swig_getmethods__["grad2"] = _robotsim.DistanceQueryResult_grad2_get
    if _newclass:
        grad2 = _swig_property(_robotsim.DistanceQueryResult_grad2_get, _robotsim.DistanceQueryResult_grad2_set)
    __swig_setmethods__["elem1"] = _robotsim.DistanceQueryResult_elem1_set
    __swig_getmethods__["elem1"] = _robotsim.DistanceQueryResult_elem1_get
    if _newclass:
        elem1 = _swig_property(_robotsim.DistanceQueryResult_elem1_get, _robotsim.DistanceQueryResult_elem1_set)
    __swig_setmethods__["elem2"] = _robotsim.DistanceQueryResult_elem2_set
    __swig_getmethods__["elem2"] = _robotsim.DistanceQueryResult_elem2_get
    if _newclass:
        elem2 = _swig_property(_robotsim.DistanceQueryResult_elem2_get, _robotsim.DistanceQueryResult_elem2_set)

    def __init__(self):
        """
        The result from a "fancy" distance query of :class:`~klampt.Geometry3D`.  


        Attributes:  

            d (float): The calculated distance, with negative values indicating
                penetration.  Can also be upperBound if the branch was hit.
            hasClosestPoints (bool):  If true, the closest point information is
                given in cp0 and cp1, and elem1 and elem2
            hasGradients (bool):  f true, distance gradient information is given
                in grad0 and grad1.
            cp1, cp2 (list of 3 floats, optional): closest points on self vs other,
                both given in world coordinates
            grad1, grad2 (list of 3 floats, optional): the gradients of the
                objects' signed distance fields at the closest points.  Given in
                world coordinates.

                I.e., to move object1 to touch object2, move it in direction
                grad1 by distance -d.  Note that grad2 is always -grad1.
            elems1, elems2 (int): for compound objects, these are the
                element indices corresponding to the closest points.  

        C++ includes: geometry.h

        """
        this = _robotsim.new_DistanceQueryResult()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_DistanceQueryResult
    __del__ = lambda self: None
DistanceQueryResult_swigregister = _robotsim.DistanceQueryResult_swigregister
DistanceQueryResult_swigregister(DistanceQueryResult)

class ContactQueryResult(_object):
    """


    The result from a contact query of :class:`~klampt.Geometry3D`. The number of
    contacts n is variable.  

    Attributes:  

        depths (list of n floats): penetration depths for each contact point.
            The depth is measured with respect to the padded geometry, and must
            be nonnegative. A value of 0 indicates that depth cannot be
            determined accurately.
        points1, points2 (list of n lists of floats): contact points on self vs
            other,  The top level list has n entries, and each entry is a
            3-list expressed in world coordinates.  If an object is padded,
            these points are on the surface of the padded geometry.
        normals (list of n lists of floats): the outward-facing contact normal
            from this to other at each contact point, given in world
            coordinates.  Each entry is a 3-list, and can be a unit vector,
            or [0,0,0] if the the normal cannot be computed properly.
        elems1, elems2 (list of n ints): for compound objects, these are the
            element indices corresponding to each contact.  

    C++ includes: geometry.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContactQueryResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ContactQueryResult, name)
    __repr__ = _swig_repr
    __swig_setmethods__["depths"] = _robotsim.ContactQueryResult_depths_set
    __swig_getmethods__["depths"] = _robotsim.ContactQueryResult_depths_get
    if _newclass:
        depths = _swig_property(_robotsim.ContactQueryResult_depths_get, _robotsim.ContactQueryResult_depths_set)
    __swig_setmethods__["points1"] = _robotsim.ContactQueryResult_points1_set
    __swig_getmethods__["points1"] = _robotsim.ContactQueryResult_points1_get
    if _newclass:
        points1 = _swig_property(_robotsim.ContactQueryResult_points1_get, _robotsim.ContactQueryResult_points1_set)
    __swig_setmethods__["points2"] = _robotsim.ContactQueryResult_points2_set
    __swig_getmethods__["points2"] = _robotsim.ContactQueryResult_points2_get
    if _newclass:
        points2 = _swig_property(_robotsim.ContactQueryResult_points2_get, _robotsim.ContactQueryResult_points2_set)
    __swig_setmethods__["normals"] = _robotsim.ContactQueryResult_normals_set
    __swig_getmethods__["normals"] = _robotsim.ContactQueryResult_normals_get
    if _newclass:
        normals = _swig_property(_robotsim.ContactQueryResult_normals_get, _robotsim.ContactQueryResult_normals_set)
    __swig_setmethods__["elems1"] = _robotsim.ContactQueryResult_elems1_set
    __swig_getmethods__["elems1"] = _robotsim.ContactQueryResult_elems1_get
    if _newclass:
        elems1 = _swig_property(_robotsim.ContactQueryResult_elems1_get, _robotsim.ContactQueryResult_elems1_set)
    __swig_setmethods__["elems2"] = _robotsim.ContactQueryResult_elems2_set
    __swig_getmethods__["elems2"] = _robotsim.ContactQueryResult_elems2_get
    if _newclass:
        elems2 = _swig_property(_robotsim.ContactQueryResult_elems2_get, _robotsim.ContactQueryResult_elems2_set)

    def __init__(self):
        """
        The result from a contact query of :class:`~klampt.Geometry3D`. The number of
        contacts n is variable.  


        Attributes:  

            depths (list of n floats): penetration depths for each contact point.
                The depth is measured with respect to the padded geometry, and must
                be nonnegative. A value of 0 indicates that depth cannot be
                determined accurately.
            points1, points2 (list of n lists of floats): contact points on self vs
                other,  The top level list has n entries, and each entry is a
                3-list expressed in world coordinates.  If an object is padded,
                these points are on the surface of the padded geometry.
            normals (list of n lists of floats): the outward-facing contact normal
                from this to other at each contact point, given in world
                coordinates.  Each entry is a 3-list, and can be a unit vector,
                or [0,0,0] if the the normal cannot be computed properly.
            elems1, elems2 (list of n ints): for compound objects, these are the
                element indices corresponding to each contact.  

        C++ includes: geometry.h

        """
        this = _robotsim.new_ContactQueryResult()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_ContactQueryResult
    __del__ = lambda self: None
ContactQueryResult_swigregister = _robotsim.ContactQueryResult_swigregister
ContactQueryResult_swigregister(ContactQueryResult)

class Geometry3D(_object):
    """


    A three-D geometry. Can either be a reference to a world item's geometry, in
    which case modifiers change the world item's geometry, or it can be a standalone
    geometry.  

    There are five currently supported types of geometry:  

    *   primitives (GeometricPrimitive)  
    *   triangle meshes (TriangleMesh)  
    *   point clouds (PointCloud)  
    *   volumetric grids (VolumeGrid)  
    *   groups (Group)  

    This class acts as a uniform container of all of these types.  

    Each geometry stores a "current" transform, which is automatically updated for
    world items' geometries. The proximity queries are performed with respect to the
    transformed geometries (note the underlying geometry is not changed, which could
    be computationally expensive. The query is performed, however, as though they
    were).  

    If you want to set a world item's geometry to be equal to a standalone geometry,
    use the set(rhs) function rather than the assignment (=) operator.  

    Modifiers include any setX() functions, translate(), and transform().  

    Proximity queries include collides(), withinDistance(), distance(),
    closestPoint(), and rayCast().  

    Each object also has a "collision margin" which may virtually fatten the
    object, as far as proximity queries are concerned. This is useful for setting
    collision avoidance margins in motion planning. By default it is zero. (Note
    that this is NOT the same thing as simulation body collision padding!)  

    C++ includes: geometry.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Geometry3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Geometry3D, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__ (): :class:`~klampt.Geometry3D`

        __init__ (arg2): :class:`~klampt.Geometry3D`


        Args:
            arg2 (:class:`~klampt.VolumeGrid` or :class:`~klampt.TriangleMesh` or :class:`~klampt.GeometricPrimitive` or :class:`~klampt.PointCloud` or :class:`~klampt.Geometry3D`, optional): 
        """
        this = _robotsim.new_Geometry3D(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_Geometry3D
    __del__ = lambda self: None

    def clone(self):
        """
        Creates a standalone geometry from this geometry.  

        Returns:
            (:class:`~klampt.Geometry3D`):
        """
        return _robotsim.Geometry3D_clone(self)


    def set(self, arg2):
        """
        Copies the geometry of the argument into this geometry.  

        Args:
            arg2 (:class:`~klampt.Geometry3D`)
        """
        return _robotsim.Geometry3D_set(self, arg2)


    def isStandalone(self):
        """
        Returns true if this is a standalone geometry.  

        Returns:
            (bool):
        """
        return _robotsim.Geometry3D_isStandalone(self)


    def free(self):
        """
        Frees the data associated with this geometry, if standalone.  

        """
        return _robotsim.Geometry3D_free(self)


    def type(self):
        """
        Returns the type of geometry: TriangleMesh, PointCloud, VolumeGrid,
        GeometricPrimitive, or Group.  

        Returns:
            (str):
        """
        return _robotsim.Geometry3D_type(self)


    def empty(self):
        """
        Returns true if this has no contents (not the same as numElements()==0)  

        Returns:
            (bool):
        """
        return _robotsim.Geometry3D_empty(self)


    def getTriangleMesh(self):
        """
        Returns a TriangleMesh if this geometry is of type TriangleMesh.  

        Returns:
            (:class:`~klampt.TriangleMesh`):
        """
        return _robotsim.Geometry3D_getTriangleMesh(self)


    def getPointCloud(self):
        """
        Returns a PointCloud if this geometry is of type PointCloud.  

        Returns:
            (:class:`~klampt.PointCloud`):
        """
        return _robotsim.Geometry3D_getPointCloud(self)


    def getGeometricPrimitive(self):
        """
        Returns a GeometricPrimitive if this geometry is of type GeometricPrimitive.  

        Returns:
            (:class:`~klampt.GeometricPrimitive`):
        """
        return _robotsim.Geometry3D_getGeometricPrimitive(self)


    def getVolumeGrid(self):
        """
        Returns a VoumeGrid if this geometry is of type VolumeGrid.  

        Returns:
            (:class:`~klampt.VolumeGrid`):
        """
        return _robotsim.Geometry3D_getVolumeGrid(self)


    def setTriangleMesh(self, arg2):
        """
        Sets this Geometry3D to a TriangleMesh.  

        Args:
            arg2 (:class:`~klampt.TriangleMesh`)
        """
        return _robotsim.Geometry3D_setTriangleMesh(self, arg2)


    def setPointCloud(self, arg2):
        """
        Sets this Geometry3D to a PointCloud.  

        Args:
            arg2 (:class:`~klampt.PointCloud`)
        """
        return _robotsim.Geometry3D_setPointCloud(self, arg2)


    def setGeometricPrimitive(self, arg2):
        """
        Sets this Geometry3D to a GeometricPrimitive.  

        Args:
            arg2 (:class:`~klampt.GeometricPrimitive`)
        """
        return _robotsim.Geometry3D_setGeometricPrimitive(self, arg2)


    def setVolumeGrid(self, arg2):
        """
        Sets this Geometry3D to a volumeGrid.  

        Args:
            arg2 (:class:`~klampt.VolumeGrid`)
        """
        return _robotsim.Geometry3D_setVolumeGrid(self, arg2)


    def setGroup(self):
        """
        Sets this Geometry3D to a group geometry. To add sub-geometries, repeatedly call
        setElement() with increasing indices.  

        """
        return _robotsim.Geometry3D_setGroup(self)


    def getElement(self, element):
        """
        Returns an element of the Geometry3D if it is a Group, TriangleMesh, or
        PointCloud. The element will be in local coordinates. Raises an error if this is
        of any other type.  

        Args:
            element (int)
        Returns:
            (:class:`~klampt.Geometry3D`):
        """
        return _robotsim.Geometry3D_getElement(self, element)


    def setElement(self, element, data):
        """
        Sets an element of the Geometry3D if it is a Group, TriangleMesh, or PointCloud.
        The element will be in local coordinates. Raises an error if this is of any
        other type.  

        Args:
            element (int)
            data (:class:`~klampt.Geometry3D`)
        """
        return _robotsim.Geometry3D_setElement(self, element, data)


    def numElements(self):
        """
        Returns the number of sub-elements in this geometry.  

        Returns:
            (int):
        """
        return _robotsim.Geometry3D_numElements(self)


    def loadFile(self, fn):
        """
        Loads from file. Standard mesh types, PCD files, and .geom files are supported.  

        Args:
            fn (str)
        Returns:
            (bool):
        """
        return _robotsim.Geometry3D_loadFile(self, fn)


    def saveFile(self, fn):
        """
        Saves to file. Standard mesh types, PCD files, and .geom files are supported.  

        Args:
            fn (str)
        Returns:
            (bool):
        """
        return _robotsim.Geometry3D_saveFile(self, fn)


    def setCurrentTransform(self, R, t):
        """
        Sets the current transformation (not modifying the underlying data)  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.Geometry3D_setCurrentTransform(self, R, t)


    def getCurrentTransform(self):
        """
        Gets the current transformation.  

        """
        return _robotsim.Geometry3D_getCurrentTransform(self)


    def translate(self, t):
        """
        Translates the geometry data. Permanently modifies the data and resets any
        collision data structures.  

        Args:
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.Geometry3D_translate(self, t)


    def scale(self, *args):
        """
        Scales the geometry data with different factors on each axis. Permanently
        modifies the data and resets any collision data structures.  

        scale (s)

        scale (sx,sy,sz)


        Args:
            s (float, optional): 
            sx (float, optional): 
            sy (float, optional): 
            sz (float, optional): 
        """
        return _robotsim.Geometry3D_scale(self, *args)


    def rotate(self, R):
        """
        Rotates the geometry data. Permanently modifies the data and resets any
        collision data structures.  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
        """
        return _robotsim.Geometry3D_rotate(self, R)


    def transform(self, R, t):
        """
        Translates/rotates/scales the geometry data. Permanently modifies the data and
        resets any collision data structures.  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.Geometry3D_transform(self, R, t)


    def setCollisionMargin(self, margin):
        """
        Sets a padding around the base geometry which affects the results of proximity
        queries.  

        Args:
            margin (float)
        """
        return _robotsim.Geometry3D_setCollisionMargin(self, margin)


    def getCollisionMargin(self):
        """
        Returns the padding around the base geometry. Default 0.  

        Returns:
            (float):
        """
        return _robotsim.Geometry3D_getCollisionMargin(self)


    def getBB(self):
        """
        Returns the axis-aligned bounding box of the object. Note: O(1) time, but may
        not be tight.  

        """
        return _robotsim.Geometry3D_getBB(self)


    def getBBTight(self):
        """
        Returns a tighter axis-aligned bounding box of the object than getBB. Worst case
        O(n) time.  

        """
        return _robotsim.Geometry3D_getBBTight(self)


    def convert(self, type, param=0):
        """
        Converts a geometry to another type, if a conversion is available. The
        interpretation of param depends on the type of conversion, with 0 being a
        reasonable default.  

        convert (type,param=0): :class:`~klampt.Geometry3D`

        convert (type): :class:`~klampt.Geometry3D`


        Args:
            type (str): 
            param (float, optional): default value 0

        Returns:
            (:class:`~klampt.Geometry3D`):

        Available conversions are:  

        *   TriangleMesh -> PointCloud. param is the desired dispersion of the points,
            by default set to the average triangle diameter. At least all of the mesh's
            vertices will be returned.  
        *   TriangleMesh -> VolumeGrid. Converted using the fast marching method with
            good results only if the mesh is watertight. param is the grid resolution,
            by default set to the average triangle diameter.  
        *   PointCloud -> TriangleMesh. Available if the point cloud is structured.
            param is the threshold for splitting triangles by depth discontinuity. param
            is by default infinity.  
        *   GeometricPrimitive -> anything. param determines the desired resolution.  
        *   VolumeGrid -> TriangleMesh. param determines the level set for the marching
            cubes algorithm.  
        *   VolumeGrid -> PointCloud. param determines the level set.  

        """
        return _robotsim.Geometry3D_convert(self, type, param)


    def collides(self, other):
        """
        Returns true if this geometry collides with the other.  

        Args:
            other (:class:`~klampt.Geometry3D`)
        Returns:
            (bool):

        Unsupported types:  

        *   VolumeGrid - TriangleMesh  
        *   VolumeGrid - VolumeGrid  

        """
        return _robotsim.Geometry3D_collides(self, other)


    def withinDistance(self, other, tol):
        """
        Returns true if this geometry is within distance tol to other.  

        Args:
            other (:class:`~klampt.Geometry3D`)
            tol (float)
        Returns:
            (bool):
        """
        return _robotsim.Geometry3D_withinDistance(self, other, tol)


    def distance_simple(self, other, relErr=0, absErr=0):
        """
        Version 0.8: this is the same as the old distance() function.  

        distance_simple (other,relErr=0,absErr=0): float

        distance_simple (other,relErr=0): float

        distance_simple (other): float


        Args:
            other (:class:`~klampt.Geometry3D`): 
            relErr (float, optional): default value 0
            absErr (float, optional): default value 0

        Returns:
            (float):

        Returns the distance from this geometry to the other. If either geometry
        contains volume information, this value may be negative to indicate penetration.  

        """
        return _robotsim.Geometry3D_distance_simple(self, other, relErr, absErr)


    def distance_point(self, pt):
        """
        Returns the the distance and closest point to the input point, given in world
        coordinates. An exception is raised if this operation is not supported with the
        given geometry type.  

        Args:
            pt (:obj:`list of 3 floats`)
        Returns:
            (:class:`~klampt.DistanceQueryResult`):

        The return value contains the distance, closest points, and gradients if
        available.  

        """
        return _robotsim.Geometry3D_distance_point(self, pt)


    def distance_point_ext(self, pt, settings):
        """
        A customizable version of distance_point. The settings for the calculation can
        be customized with relErr, absErr, and upperBound, e.g., to break if the closest
        points are at least upperBound distance from one another.  

        Args:
            pt (:obj:`list of 3 floats`)
            settings (:class:`~klampt.DistanceQuerySettings`)
        Returns:
            (:class:`~klampt.DistanceQueryResult`):
        """
        return _robotsim.Geometry3D_distance_point_ext(self, pt, settings)


    def distance(self, other):
        """
        Returns the the distance and closest points between the given geometries.  

        Args:
            other (:class:`~klampt.Geometry3D`)
        Returns:
            (:class:`~klampt.DistanceQueryResult`):

        If the objects are penetrating, some combinations of geometry types allow
        calculating penetration depths:  

        *   GeometricPrimitive-GeometricPrimitive (Python-supported sub-types only)  
        *   GeometricPrimitive-TriangleMesh (surface only)  
        *   GeometricPrimitive-PointCloud  
        *   GeometricPrimitive-VolumeGrid  
        *   TriangleMesh (surface only)-GeometricPrimitive  
        *   PointCloud-VolumeGrid  

        If penetration is supported, a negative distance is returned and cp1,cp2 are the
        deepest penetrating points.  

        Unsupported types:  

        *   GeometricPrimitive-GeometricPrimitive subtypes segment vs aabb  
        *   PointCloud-PointCloud  
        *   VolumeGrid-TriangleMesh  
        *   VolumeGrid-VolumeGrid  

        See the comments of the distance_point function  

        """
        return _robotsim.Geometry3D_distance(self, other)


    def distance_ext(self, other, settings):
        """
        A customizable version of distance. The settings for the calculation can be
        customized with relErr, absErr, and upperBound, e.g., to break if the closest
        points are at least upperBound distance from one another.  

        Args:
            other (:class:`~klampt.Geometry3D`)
            settings (:class:`~klampt.DistanceQuerySettings`)
        Returns:
            (:class:`~klampt.DistanceQueryResult`):
        """
        return _robotsim.Geometry3D_distance_ext(self, other, settings)


    def rayCast(self, s, d):
        """
        Returns (hit,pt) where hit is true if the ray starting at s and pointing in
        direction d hits the geometry (given in world coordinates); pt is the hit point,
        in world coordinates.  

        Args:
            s (:obj:`list of 3 floats`)
            d (:obj:`list of 3 floats`)
        Returns:
            (bool):
        """
        return _robotsim.Geometry3D_rayCast(self, s, d)


    def contacts(self, other, padding1, padding2, maxContacts=0):
        """
        Returns the set of contact points between this and other. This set is a discrete
        representation of the region of surface overlap, which is defined as all pairs
        of points within distance self.collisionMargin + other.collisionMargin +
        padding1 + padding2.  

        contacts (other,padding1,padding2,maxContacts=0): :obj:`ContactQueryResult`

        contacts (other,padding1,padding2): :obj:`ContactQueryResult`


        Args:
            other (:class:`~klampt.Geometry3D`): 
            padding1 (float): 
            padding2 (float): 
            maxContacts (int, optional): default value 0

        Returns:
            (:obj:`ContactQueryResult`):

        For some geometry types (TriangleMesh-TriangleMesh, TriangleMesh-PointCloud,
        PointCloud-PointCloud) padding must be positive to get meaningful contact poitns
        and normals.  

        If maxContacts != 0 a clustering postprocessing step is performed.  

        Unsupported types:  

        *   GeometricPrimitive-GeometricPrimitive subtypes segment vs aabb  
        *   VolumeGrid-GeometricPrimitive any subtypes except point and sphere. also,
            the results are potentially inaccurate for non-convex VolumeGrids.  
        *   VolumeGrid-TriangleMesh  
        *   VolumeGrid-VolumeGrid  

        """
        return _robotsim.Geometry3D_contacts(self, other, padding1, padding2, maxContacts)

    __swig_setmethods__["world"] = _robotsim.Geometry3D_world_set
    __swig_getmethods__["world"] = _robotsim.Geometry3D_world_get
    if _newclass:
        world = _swig_property(_robotsim.Geometry3D_world_get, _robotsim.Geometry3D_world_set)
    __swig_setmethods__["id"] = _robotsim.Geometry3D_id_set
    __swig_getmethods__["id"] = _robotsim.Geometry3D_id_get
    if _newclass:
        id = _swig_property(_robotsim.Geometry3D_id_get, _robotsim.Geometry3D_id_set)
    __swig_setmethods__["geomPtr"] = _robotsim.Geometry3D_geomPtr_set
    __swig_getmethods__["geomPtr"] = _robotsim.Geometry3D_geomPtr_get
    if _newclass:
        geomPtr = _swig_property(_robotsim.Geometry3D_geomPtr_get, _robotsim.Geometry3D_geomPtr_set)
Geometry3D_swigregister = _robotsim.Geometry3D_swigregister
Geometry3D_swigregister(Geometry3D)

class Appearance(_object):
    """


    Geometry appearance information. Supports vertex/edge/face rendering, per-vertex
    color, and basic color texture mapping. Uses OpenGL display lists, so repeated
    calls are fast.  

    For more complex appearances, you will need to call your own OpenGL calls.  

    Appearances can be either references to appearances of objects in the world, or
    they can be standalone.  

    Performance note: Avoid rebuilding buffers (e.g., via :meth:`refresh` as much as
    possible.  

    C++ includes: appearance.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Appearance, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Appearance, name)
    __repr__ = _swig_repr
    ALL = _robotsim.Appearance_ALL
    VERTICES = _robotsim.Appearance_VERTICES
    EDGES = _robotsim.Appearance_EDGES
    FACES = _robotsim.Appearance_FACES

    def __init__(self, *args):
        """
        __init__ (): :class:`~klampt.Appearance`

        __init__ (app): :class:`~klampt.Appearance`


        Args:
            app (:class:`~klampt.Appearance`, optional): 
        """
        this = _robotsim.new_Appearance(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_Appearance
    __del__ = lambda self: None

    def refresh(self, deep=True):
        """
        call this to rebuild internal buffers, e.g., when the OpenGL context changes. If
        deep=True, the entire data structure will be revised. Use this for streaming
        data, for example.  

        refresh (deep=True)

        refresh ()


        Args:
            deep (bool, optional): default value True
        """
        return _robotsim.Appearance_refresh(self, deep)


    def clone(self):
        """
        Creates a standalone appearance from this appearance.  

        Returns:
            (:class:`~klampt.Appearance`):
        """
        return _robotsim.Appearance_clone(self)


    def set(self, arg2):
        """
        Copies the appearance of the argument into this appearance.  

        Args:
            arg2 (:class:`~klampt.Appearance`)
        """
        return _robotsim.Appearance_set(self, arg2)


    def isStandalone(self):
        """
        Returns true if this is a standalone appearance.  

        Returns:
            (bool):
        """
        return _robotsim.Appearance_isStandalone(self)


    def free(self):
        """
        Frees the data associated with this appearance, if standalone.  

        """
        return _robotsim.Appearance_free(self)


    def setDraw(self, *args):
        """
        Turns on/off visibility of the object or a feature.  

        setDraw (draw)

        setDraw (feature,draw)


        Args:
            draw (bool): 
            feature (int, optional): 

        If one argument is given, turns the object visibility on or off  

        If two arguments are given, turns the feature (first int argument) visibility on
        or off. feature can be ALL, VERTICES, EDGES, or FACES.  

        """
        return _robotsim.Appearance_setDraw(self, *args)


    def getDraw(self, *args):
        """
        Returns whether this object or feature is visible.  

        getDraw (): bool

        getDraw (feature): bool


        Args:
            feature (int, optional): 

        Returns:
            (bool):

        If no arguments are given, returns whether the object is visible.  

        If one int argument is given, returns whether the given feature is visible.
        feature can be ALL, VERTICES, EDGES, or FACES.  

        """
        return _robotsim.Appearance_getDraw(self, *args)


    def setColor(self, *args):
        """
        Sets color of the object or a feature.  

        setColor (r,g,b,a=1)

        setColor (r,g,b)

        setColor (feature,r,g,b,a)


        Args:
            r (float): 
            g (float): 
            b (float): 
            a (float, optional): default value 1
            feature (int, optional): 

        If 3 or 4 arguments are given, changes the object color.  

        If 5 arguments are given, changes the color of the given feature. feature can be
        ALL, VERTICES, EDGES, or FACES.  

        """
        return _robotsim.Appearance_setColor(self, *args)


    def getColor(self, *args):
        """
        getColor ()

        getColor (feature)


        Args:
            feature (int, optional): 
        """
        return _robotsim.Appearance_getColor(self, *args)


    def setColors(self, feature, colors, alpha=False):
        """
        Sets per-element color for elements of the given feature type.  

        setColors (feature,colors,alpha=False)

        setColors (feature,colors)


        Args:
            feature (int): 
            colors (:obj:`list of floats`): 
            alpha (bool, optional): default value False

        If alpha=True, colors are assumed to be 4*N rgba values, where N is the number
        of features of that type.  

        Otherwise they are assumed to be 3*N rgb values. Only supports feature=VERTICES
        and feature=FACES  

        """
        return _robotsim.Appearance_setColors(self, feature, colors, alpha)


    def setElementColor(self, feature, element, r, g, b, a=1):
        """
        Sets the per-element color for the given feature.  

        setElementColor (feature,element,r,g,b,a=1)

        setElementColor (feature,element,r,g,b)


        Args:
            feature (int): 
            element (int): 
            r (float): 
            g (float): 
            b (float): 
            a (float, optional): default value 1
        """
        return _robotsim.Appearance_setElementColor(self, feature, element, r, g, b, a)


    def getElementColor(self, feature, element):
        """
        Gets the per-element color for the given feature.  

        Args:
            feature (int)
            element (int)
        """
        return _robotsim.Appearance_getElementColor(self, feature, element)


    def setTexture1D(self, w, format, bytes):
        """
        Sets a 1D texture of the given width. Valid format strings are.  

        Args:
            w (int)
            format (str)
            char (:obj:`std::vector< unsigned`)
            bytes (:obj:`std::allocator< unsigned char > >`)

        *   "": turn off texture mapping  
        *   rgb8: unsigned byte RGB colors with red in the most significant byte  
        *   argb8: unsigned byte RGBA colors with alpha in the most significant byte  
        *   l8: unsigned byte grayscale colors  

        """
        return _robotsim.Appearance_setTexture1D(self, w, format, bytes)


    def setTexture2D(self, w, h, format, bytes):
        """
        Sets a 2D texture of the given width/height. See setTexture1D for valid format
        strings.  

        Args:
            w (int)
            h (int)
            format (str)
            char (:obj:`std::vector< unsigned`)
            bytes (:obj:`std::allocator< unsigned char > >`)
        """
        return _robotsim.Appearance_setTexture2D(self, w, h, format, bytes)


    def setTexcoords(self, uvs):
        """
        Sets per-vertex texture coordinates.  

        Args:
            uvs (:obj:`list of floats`)

        If the texture is 1D, uvs is an array of length n containing 1D texture
        coordinates.  

        If the texture is 2D, uvs is an array of length 2n containing U-V coordinates
        u1, v1, u2, v2, ..., un, vn.  

        You may also set uvs to be empty, which turns off texture mapping altogether.  

        """
        return _robotsim.Appearance_setTexcoords(self, uvs)


    def setPointSize(self, size):
        """
        For point clouds, sets the point size.  

        Args:
            size (float)
        """
        return _robotsim.Appearance_setPointSize(self, size)


    def setCreaseAngle(self, creaseAngleRads):
        """
        For meshes, sets the crease angle. Set to 0 to disable smoothing.  

        Args:
            creaseAngleRads (float)
        """
        return _robotsim.Appearance_setCreaseAngle(self, creaseAngleRads)


    def setSilhouette(self, radius, r=0, g=0, b=0, a=1):
        """
        For meshes sets a silhouette radius and color. Set the radius to 0 to disable
        silhouette drawing.  

        setSilhouette (radius,r=0,g=0,b=0,a=1)

        setSilhouette (radius,r=0,g=0,b=0)

        setSilhouette (radius,r=0,g=0)

        setSilhouette (radius,r=0)

        setSilhouette (radius)


        Args:
            radius (float): 
            r (float, optional): default value 0
            g (float, optional): default value 0
            b (float, optional): default value 0
            a (float, optional): default value 1
        """
        return _robotsim.Appearance_setSilhouette(self, radius, r, g, b, a)


    def drawGL(self, *args):
        """
        Draws the given geometry with this appearance. NOTE: for best performance, an
        appearance should only be drawn with a single geometry. Otherwise, the OpenGL
        display lists will be completely recreated.  

        drawGL ()

        drawGL (geom)


        Args:
            geom (:class:`~klampt.Geometry3D`, optional): 

        Note that the geometry's current transform is NOT respected, and this only draws
        the geometry in its local transform.  

        """
        return _robotsim.Appearance_drawGL(self, *args)


    def drawWorldGL(self, geom):
        """
        Draws the given geometry with this appearance. NOTE: for best performance, an
        appearance should only be drawn with a single geometry. Otherwise, the OpenGL
        display lists will be completely recreated.  

        Args:
            geom (:class:`~klampt.Geometry3D`)

        Differs from drawGL in that the geometry's current transform is applied before
        drawing.  

        """
        return _robotsim.Appearance_drawWorldGL(self, geom)

    __swig_setmethods__["world"] = _robotsim.Appearance_world_set
    __swig_getmethods__["world"] = _robotsim.Appearance_world_get
    if _newclass:
        world = _swig_property(_robotsim.Appearance_world_get, _robotsim.Appearance_world_set)
    __swig_setmethods__["id"] = _robotsim.Appearance_id_set
    __swig_getmethods__["id"] = _robotsim.Appearance_id_get
    if _newclass:
        id = _swig_property(_robotsim.Appearance_id_get, _robotsim.Appearance_id_set)
    __swig_setmethods__["appearancePtr"] = _robotsim.Appearance_appearancePtr_set
    __swig_getmethods__["appearancePtr"] = _robotsim.Appearance_appearancePtr_get
    if _newclass:
        appearancePtr = _swig_property(_robotsim.Appearance_appearancePtr_get, _robotsim.Appearance_appearancePtr_set)
Appearance_swigregister = _robotsim.Appearance_swigregister
Appearance_swigregister(Appearance)

class Viewport(_object):
    """


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Viewport, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Viewport, name)
    __repr__ = _swig_repr

    def fromJson(self, str):
        """
        Args:
            str (str)
        Returns:
            (bool):
        """
        return _robotsim.Viewport_fromJson(self, str)


    def toJson(self):
        """
        Returns:
            (str):
        """
        return _robotsim.Viewport_toJson(self)


    def setModelviewMatrix(self, M):
        """
        Args:
            M (:obj:`double const [16]`)
        """
        return _robotsim.Viewport_setModelviewMatrix(self, M)


    def setRigidTransform(self, R, t):
        """
        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.Viewport_setRigidTransform(self, R, t)


    def getRigidTransform(self):
        """
        """
        return _robotsim.Viewport_getRigidTransform(self)

    __swig_setmethods__["perspective"] = _robotsim.Viewport_perspective_set
    __swig_getmethods__["perspective"] = _robotsim.Viewport_perspective_get
    if _newclass:
        perspective = _swig_property(_robotsim.Viewport_perspective_get, _robotsim.Viewport_perspective_set)
    __swig_setmethods__["scale"] = _robotsim.Viewport_scale_set
    __swig_getmethods__["scale"] = _robotsim.Viewport_scale_get
    if _newclass:
        scale = _swig_property(_robotsim.Viewport_scale_get, _robotsim.Viewport_scale_set)
    __swig_setmethods__["x"] = _robotsim.Viewport_x_set
    __swig_getmethods__["x"] = _robotsim.Viewport_x_get
    if _newclass:
        x = _swig_property(_robotsim.Viewport_x_get, _robotsim.Viewport_x_set)
    __swig_setmethods__["y"] = _robotsim.Viewport_y_set
    __swig_getmethods__["y"] = _robotsim.Viewport_y_get
    if _newclass:
        y = _swig_property(_robotsim.Viewport_y_get, _robotsim.Viewport_y_set)
    __swig_setmethods__["w"] = _robotsim.Viewport_w_set
    __swig_getmethods__["w"] = _robotsim.Viewport_w_get
    if _newclass:
        w = _swig_property(_robotsim.Viewport_w_get, _robotsim.Viewport_w_set)
    __swig_setmethods__["h"] = _robotsim.Viewport_h_set
    __swig_getmethods__["h"] = _robotsim.Viewport_h_get
    if _newclass:
        h = _swig_property(_robotsim.Viewport_h_get, _robotsim.Viewport_h_set)
    __swig_setmethods__["n"] = _robotsim.Viewport_n_set
    __swig_getmethods__["n"] = _robotsim.Viewport_n_get
    if _newclass:
        n = _swig_property(_robotsim.Viewport_n_get, _robotsim.Viewport_n_set)
    __swig_setmethods__["f"] = _robotsim.Viewport_f_set
    __swig_getmethods__["f"] = _robotsim.Viewport_f_get
    if _newclass:
        f = _swig_property(_robotsim.Viewport_f_get, _robotsim.Viewport_f_set)
    __swig_setmethods__["xform"] = _robotsim.Viewport_xform_set
    __swig_getmethods__["xform"] = _robotsim.Viewport_xform_get
    if _newclass:
        xform = _swig_property(_robotsim.Viewport_xform_get, _robotsim.Viewport_xform_set)

    def __init__(self):
        """
        """
        this = _robotsim.new_Viewport()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_Viewport
    __del__ = lambda self: None
Viewport_swigregister = _robotsim.Viewport_swigregister
Viewport_swigregister(Viewport)

class Widget(_object):
    """


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Widget, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Widget, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        """
        this = _robotsim.new_Widget()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_Widget
    __del__ = lambda self: None

    def hover(self, x, y, viewport):
        """
        Args:
            x (int)
            y (int)
            viewport (:obj:`Viewport`)
        Returns:
            (bool):
        """
        return _robotsim.Widget_hover(self, x, y, viewport)


    def beginDrag(self, x, y, viewport):
        """
        Args:
            x (int)
            y (int)
            viewport (:obj:`Viewport`)
        Returns:
            (bool):
        """
        return _robotsim.Widget_beginDrag(self, x, y, viewport)


    def drag(self, dx, dy, viewport):
        """
        Args:
            dx (int)
            dy (int)
            viewport (:obj:`Viewport`)
        """
        return _robotsim.Widget_drag(self, dx, dy, viewport)


    def endDrag(self):
        """
        """
        return _robotsim.Widget_endDrag(self)


    def keypress(self, c):
        """
        Args:
            c (str)
        """
        return _robotsim.Widget_keypress(self, c)


    def drawGL(self, viewport):
        """
        Args:
            viewport (:obj:`Viewport`)
        """
        return _robotsim.Widget_drawGL(self, viewport)


    def idle(self):
        """
        """
        return _robotsim.Widget_idle(self)


    def wantsRedraw(self):
        """
        Returns:
            (bool):
        """
        return _robotsim.Widget_wantsRedraw(self)


    def hasHighlight(self):
        """
        Returns:
            (bool):
        """
        return _robotsim.Widget_hasHighlight(self)


    def hasFocus(self):
        """
        Returns:
            (bool):
        """
        return _robotsim.Widget_hasFocus(self)

    __swig_setmethods__["index"] = _robotsim.Widget_index_set
    __swig_getmethods__["index"] = _robotsim.Widget_index_get
    if _newclass:
        index = _swig_property(_robotsim.Widget_index_get, _robotsim.Widget_index_set)
Widget_swigregister = _robotsim.Widget_swigregister
Widget_swigregister(Widget)

class WidgetSet(Widget):
    """


    """

    __swig_setmethods__ = {}
    for _s in [Widget]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WidgetSet, name, value)
    __swig_getmethods__ = {}
    for _s in [Widget]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WidgetSet, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        """
        this = _robotsim.new_WidgetSet()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add(self, subwidget):
        """
        Args:
            subwidget (:obj:`Widget`)
        """
        return _robotsim.WidgetSet_add(self, subwidget)


    def remove(self, subwidget):
        """
        Args:
            subwidget (:obj:`Widget`)
        """
        return _robotsim.WidgetSet_remove(self, subwidget)


    def enable(self, subwidget, enabled):
        """
        Args:
            subwidget (:obj:`Widget`)
            enabled (bool)
        """
        return _robotsim.WidgetSet_enable(self, subwidget, enabled)

    __swig_destroy__ = _robotsim.delete_WidgetSet
    __del__ = lambda self: None
WidgetSet_swigregister = _robotsim.WidgetSet_swigregister
WidgetSet_swigregister(WidgetSet)

class PointPoser(Widget):
    """


    """

    __swig_setmethods__ = {}
    for _s in [Widget]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PointPoser, name, value)
    __swig_getmethods__ = {}
    for _s in [Widget]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PointPoser, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        """
        this = _robotsim.new_PointPoser()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set(self, t):
        """
        Args:
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.PointPoser_set(self, t)


    def get(self):
        """
        """
        return _robotsim.PointPoser_get(self)


    def setAxes(self, R):
        """
        Sets the reference axes (by default aligned to x,y,z)  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
        """
        return _robotsim.PointPoser_setAxes(self, R)

    __swig_destroy__ = _robotsim.delete_PointPoser
    __del__ = lambda self: None
PointPoser_swigregister = _robotsim.PointPoser_swigregister
PointPoser_swigregister(PointPoser)

class TransformPoser(Widget):
    """


    """

    __swig_setmethods__ = {}
    for _s in [Widget]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransformPoser, name, value)
    __swig_getmethods__ = {}
    for _s in [Widget]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransformPoser, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        """
        this = _robotsim.new_TransformPoser()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set(self, R, t):
        """
        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.TransformPoser_set(self, R, t)


    def get(self):
        """
        """
        return _robotsim.TransformPoser_get(self)


    def enableTranslation(self, arg2):
        """
        Args:
            arg2 (bool)
        """
        return _robotsim.TransformPoser_enableTranslation(self, arg2)


    def enableRotation(self, arg2):
        """
        Args:
            arg2 (bool)
        """
        return _robotsim.TransformPoser_enableRotation(self, arg2)

    __swig_destroy__ = _robotsim.delete_TransformPoser
    __del__ = lambda self: None
TransformPoser_swigregister = _robotsim.TransformPoser_swigregister
TransformPoser_swigregister(TransformPoser)

class ObjectPoser(Widget):
    """


    """

    __swig_setmethods__ = {}
    for _s in [Widget]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ObjectPoser, name, value)
    __swig_getmethods__ = {}
    for _s in [Widget]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ObjectPoser, name)
    __repr__ = _swig_repr

    def __init__(self, object):
        """
        Args:
            object (:class:`~klampt.RigidObjectModel`)
        """
        this = _robotsim.new_ObjectPoser(object)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set(self, R, t):
        """
        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.ObjectPoser_set(self, R, t)


    def get(self):
        """
        """
        return _robotsim.ObjectPoser_get(self)

    __swig_destroy__ = _robotsim.delete_ObjectPoser
    __del__ = lambda self: None
ObjectPoser_swigregister = _robotsim.ObjectPoser_swigregister
ObjectPoser_swigregister(ObjectPoser)

class RobotPoser(Widget):
    """


    """

    __swig_setmethods__ = {}
    for _s in [Widget]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RobotPoser, name, value)
    __swig_getmethods__ = {}
    for _s in [Widget]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RobotPoser, name)
    __repr__ = _swig_repr

    def __init__(self, robot):
        """
        Args:
            robot (:class:`~klampt.RobotModel`)
        """
        this = _robotsim.new_RobotPoser(robot)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def setActiveDofs(self, dofs):
        """
        Args:
            dofs (:obj:`list of int`)
        """
        return _robotsim.RobotPoser_setActiveDofs(self, dofs)


    def set(self, q):
        """
        Args:
            q (:obj:`list of floats`)
        """
        return _robotsim.RobotPoser_set(self, q)


    def get(self):
        """
        """
        return _robotsim.RobotPoser_get(self)


    def getConditioned(self, qref):
        """
        Args:
            qref (:obj:`list of floats`)
        """
        return _robotsim.RobotPoser_getConditioned(self, qref)


    def addIKConstraint(self, obj):
        """
        Args:
            obj (:obj:`IKObjective`)
        """
        return _robotsim.RobotPoser_addIKConstraint(self, obj)


    def clearIKConstraints(self):
        """
        """
        return _robotsim.RobotPoser_clearIKConstraints(self)

    __swig_destroy__ = _robotsim.delete_RobotPoser
    __del__ = lambda self: None
RobotPoser_swigregister = _robotsim.RobotPoser_swigregister
RobotPoser_swigregister(RobotPoser)

class Mass(_object):
    """


    Stores mass information for a rigid body or robot link.  

    Note:  

        You should use the set/get functions rather than changing the members
        directly due to strangeness in SWIG's handling of vectors.  

    Attributes:  

        mass (float): the actual mass (typically in kg)
        com (SWIG-based list of 3 floats): the center of mass position, in
            local coordinates.  (Better to use setCom/getCom)
        inertia (SWIG-based list of 3 floats or 9 floats): the inertia matrix
            in local coordinates.  If 3 floats, this is a diagonal matrix.
            If 9 floats, this gives all entries of the 3x3 inertia matrix
            (in column major or row major order, it doesn't matter since
            inertia matrices are symmetric)  

    C++ includes: robotmodel.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Mass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Mass, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        """
        this = _robotsim.new_Mass()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def setMass(self, _mass):
        """
        Args:
            _mass (float)
        """
        return _robotsim.Mass_setMass(self, _mass)


    def getMass(self):
        """
        Returns:
            (float):
        """
        return _robotsim.Mass_getMass(self)


    def setCom(self, _com):
        """
        Args:
            _com (:obj:`list of floats`)
        """
        return _robotsim.Mass_setCom(self, _com)


    def getCom(self):
        """
        Returns the COM as a list of 3 floats.  

        """
        return _robotsim.Mass_getCom(self)


    def setInertia(self, _inertia):
        """
        Sets an inertia matrix.  

        Args:
            _inertia (:obj:`list of floats`)
        """
        return _robotsim.Mass_setInertia(self, _inertia)


    def getInertia(self):
        """
        Returns the inertia matrix as a list of 3 floats or 9 floats.  

        """
        return _robotsim.Mass_getInertia(self)

    __swig_setmethods__["mass"] = _robotsim.Mass_mass_set
    __swig_getmethods__["mass"] = _robotsim.Mass_mass_get
    if _newclass:
        mass = _swig_property(_robotsim.Mass_mass_get, _robotsim.Mass_mass_set)
    __swig_setmethods__["com"] = _robotsim.Mass_com_set
    __swig_getmethods__["com"] = _robotsim.Mass_com_get
    if _newclass:
        com = _swig_property(_robotsim.Mass_com_get, _robotsim.Mass_com_set)
    __swig_setmethods__["inertia"] = _robotsim.Mass_inertia_set
    __swig_getmethods__["inertia"] = _robotsim.Mass_inertia_get
    if _newclass:
        inertia = _swig_property(_robotsim.Mass_inertia_get, _robotsim.Mass_inertia_set)
    __swig_destroy__ = _robotsim.delete_Mass
    __del__ = lambda self: None
Mass_swigregister = _robotsim.Mass_swigregister
Mass_swigregister(Mass)

class ContactParameters(_object):
    """


    Stores contact parameters for an entity. Currently only used for simulation, but
    could be used for contact mechanics in the future.  

    Attributes:  

        kFriction (float): The coefficient of (Coulomb) friction, in range
            [0,inf).
        kRestitution (float): The coefficient of restitution, in range [0,1].
        kStiffness (float): The stiffness of the material, in range (0,inf)
            (default inf, perfectly rigid).
        kDamping (float): The damping of the material, in range (0,inf)
            (default inf, perfectly rigid).  

    C++ includes: robotmodel.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContactParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ContactParameters, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        """
        this = _robotsim.new_ContactParameters()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["kFriction"] = _robotsim.ContactParameters_kFriction_set
    __swig_getmethods__["kFriction"] = _robotsim.ContactParameters_kFriction_get
    if _newclass:
        kFriction = _swig_property(_robotsim.ContactParameters_kFriction_get, _robotsim.ContactParameters_kFriction_set)
    __swig_setmethods__["kRestitution"] = _robotsim.ContactParameters_kRestitution_set
    __swig_getmethods__["kRestitution"] = _robotsim.ContactParameters_kRestitution_get
    if _newclass:
        kRestitution = _swig_property(_robotsim.ContactParameters_kRestitution_get, _robotsim.ContactParameters_kRestitution_set)
    __swig_setmethods__["kStiffness"] = _robotsim.ContactParameters_kStiffness_set
    __swig_getmethods__["kStiffness"] = _robotsim.ContactParameters_kStiffness_get
    if _newclass:
        kStiffness = _swig_property(_robotsim.ContactParameters_kStiffness_get, _robotsim.ContactParameters_kStiffness_set)
    __swig_setmethods__["kDamping"] = _robotsim.ContactParameters_kDamping_set
    __swig_getmethods__["kDamping"] = _robotsim.ContactParameters_kDamping_get
    if _newclass:
        kDamping = _swig_property(_robotsim.ContactParameters_kDamping_get, _robotsim.ContactParameters_kDamping_set)
    __swig_destroy__ = _robotsim.delete_ContactParameters
    __del__ = lambda self: None
ContactParameters_swigregister = _robotsim.ContactParameters_swigregister
ContactParameters_swigregister(ContactParameters)

class RobotModelLink(_object):
    """


    A reference to a link of a RobotModel.  

    The link stores many mostly-constant items (id, name, parent, geometry,
    appearance, mass, joint axes). There are two exceptions:  

    *   the link's current transform, which is affected by the RobotModel's current
        configuration, i.e., the last :meth:`RobotModel.setConfig` (q) call.  
    *   The various Jacobians of points on the link, accessed by
        :meth:`RobotModelLink.getJacobian` ,
        :meth:`RobotModelLink.getPositionJacobian` , and
        :meth:`RobotModelLink.getOrientationJacobian` , which are configuration
        dependent.  

    A RobotModelLink is not created by hand, but instead accessed using
    :meth:`RobotModel.link` (index or name)  

    C++ includes: robotmodel.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RobotModelLink, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RobotModelLink, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        """
        this = _robotsim.new_RobotModelLink()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getID(self):
        """
        Returns the ID of the robot link in its world.  

        Returns:
            (int):

        Note: The world ID is not the same as the link's index, retrieved by getIndex.  

        """
        return _robotsim.RobotModelLink_getID(self)


    def getName(self):
        """
        Returns the name of the robot link.  

        Returns:
            (str):
        """
        return _robotsim.RobotModelLink_getName(self)


    def setName(self, name):
        """
        Sets the name of the robot link.  

        Args:
            name (str)
        """
        return _robotsim.RobotModelLink_setName(self, name)


    def robot(self):
        """
        Returns a reference to the link's robot.  

        Returns:
            (:class:`~klampt.RobotModel`):
        """
        return _robotsim.RobotModelLink_robot(self)


    def getIndex(self):
        """
        Returns the index of the link (on its robot).  

        Returns:
            (int):
        """
        return _robotsim.RobotModelLink_getIndex(self)


    def getParent(self):
        """
        Returns the index of the link's parent (on its robot).  

        Returns:
            (int):
        """
        return _robotsim.RobotModelLink_getParent(self)


    def parent(self):
        """
        Returns a reference to the link's parent, or a NULL link if it has no parent.  

        Returns:
            (:class:`~klampt.RobotModelLink`):
        """
        return _robotsim.RobotModelLink_parent(self)


    def setParent(self, *args):
        """
        Sets the link's parent (must be on the same robot).  

        setParent (p)

        setParent (l)


        Args:
            p (int, optional): 
            l (:class:`~klampt.RobotModelLink`, optional): 
        """
        return _robotsim.RobotModelLink_setParent(self, *args)


    def geometry(self):
        """
        Returns a reference to the link's geometry.  

        Returns:
            (:class:`~klampt.Geometry3D`):
        """
        return _robotsim.RobotModelLink_geometry(self)


    def appearance(self):
        """
        Returns a reference to the link's appearance.  

        Returns:
            (:class:`~klampt.Appearance`):
        """
        return _robotsim.RobotModelLink_appearance(self)


    def getMass(self):
        """
        Retrieves the inertial properties of the link. (Note that the Mass is given with
        origin at the link frame, not about the COM.)  

        Returns:
            (:class:`~klampt.Mass`):
        """
        return _robotsim.RobotModelLink_getMass(self)


    def setMass(self, mass):
        """
        Sets the inertial proerties of the link. (Note that the Mass is given with
        origin at the link frame, not about the COM.)  

        Args:
            mass (:class:`~klampt.Mass`)
        """
        return _robotsim.RobotModelLink_setMass(self, mass)


    def getParentTransform(self):
        """
        Gets transformation (R,t) to the parent link.  


        Returns:  

            (se3 object): a pair (R,t), with R a 9-list and t a 3-list of floats,
            giving the local transform from this link to its parent, in the
            reference (zero) configuration.  

        """
        return _robotsim.RobotModelLink_getParentTransform(self)


    def setParentTransform(self, R, t):
        """
        Sets transformation (R,t) to the parent link.  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.RobotModelLink_setParentTransform(self, R, t)


    def getAxis(self):
        """
        Gets the local rotational / translational axis.  

        """
        return _robotsim.RobotModelLink_getAxis(self)


    def setAxis(self, axis):
        """
        Sets the local rotational / translational axis.  

        Args:
            axis (:obj:`list of 3 floats`)
        """
        return _robotsim.RobotModelLink_setAxis(self, axis)


    def getWorldPosition(self, plocal):
        """
        Converts point from local to world coordinates.  

        Args:
            plocal (:obj:`list of 3 floats`)

        Returns:  

            (list of 3 floats): the world coordinates of the local point plocal  

        """
        return _robotsim.RobotModelLink_getWorldPosition(self, plocal)


    def getWorldDirection(self, vlocal):
        """
        Converts direction from local to world coordinates.  

        Args:
            vlocal (:obj:`list of 3 floats`)

        Returns:  

            (list of 3 floats): the world coordinates of the local direction
            vlocal  

        """
        return _robotsim.RobotModelLink_getWorldDirection(self, vlocal)


    def getLocalPosition(self, pworld):
        """
        Converts point from world to local coordinates.  

        Args:
            pworld (:obj:`list of 3 floats`)

        Returns:  

            (list of 3 floats): the local coordinates of the world point pworld  

        """
        return _robotsim.RobotModelLink_getLocalPosition(self, pworld)


    def getLocalDirection(self, vworld):
        """
        Converts direction from world to local coordinates.  

        Args:
            vworld (:obj:`list of 3 floats`)

        Returns:  

            (list of 3 floats): the local coordinates of the world direction
            vworld  

        """
        return _robotsim.RobotModelLink_getLocalDirection(self, vworld)


    def getTransform(self):
        """
        Gets the link's current transformation (R,t) to the world frame.  


        Returns:  

            (se3 object): a pair (R,t), with R a 9-list and t a 3-list of floats.  

        """
        return _robotsim.RobotModelLink_getTransform(self)


    def setTransform(self, R, t):
        """
        Sets the link's current transformation (R,t) to the world frame.  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)

        Note:  

            This does NOT perform inverse kinematics.  The transform is
            overwritten when the robot's setConfig() method is called.  

        """
        return _robotsim.RobotModelLink_setTransform(self, R, t)


    def getVelocity(self):
        """
        Returns the velocity of the link's origin given the robot's current joint
        configuration and velocities. Equivalent to getPointVelocity([0,0,0]).  


        Returns:  

            (list of 3 floats): the current velocity of the link's origin, in
            world coordinates  

        """
        return _robotsim.RobotModelLink_getVelocity(self)


    def getAngularVelocity(self):
        """
        Returns the angular velocity of the link given the robot's current joint
        configuration and velocities.  


        Returns:  

            (list of 3 floats): the current angular velocity of the link, in world
            coordinates  

        """
        return _robotsim.RobotModelLink_getAngularVelocity(self)


    def getPointVelocity(self, plocal):
        """
        Returns the world velocity of a point attached to the link, given the robot's
        current joint configuration and velocities.  

        Args:
            plocal (:obj:`list of 3 floats`)

        Returns:  

            (list of 3 floats): the current velocity of the point, in
            world coordinates.  

        """
        return _robotsim.RobotModelLink_getPointVelocity(self, plocal)


    def getJacobian(self, plocal):
        """
        Returns the total jacobian of a point on this link w.r.t. the robot's
        configuration q.  

        Args:
            plocal (:obj:`list of 3 floats`)

        Returns:  

            (list of 6 lists of floats): the 6xn total Jacobian matrix of the
            point given by local coordinates plocal.  The matrix is row-major.

            The orientation jacobian is given in the first 3 rows, and is stacked
            on the position jacobian, which is given in the last 3 rows.  

        """
        return _robotsim.RobotModelLink_getJacobian(self, plocal)


    def getPositionJacobian(self, plocal):
        """
        Returns the position jacobian of a point on this link w.r.t. the robot's
        configuration q.  

        Args:
            plocal (:obj:`list of 3 floats`)

        Returns:  

            (list of 3 lists of floats): the 3xn Jacobian matrix of the
            point given by local coordinates plocal.  The matrix is row-major.

            This matrix J gives the point's velocity (in world coordinates) via
            np.dot(J,dq), where dq is the robot's joint velocities.  

        """
        return _robotsim.RobotModelLink_getPositionJacobian(self, plocal)


    def getOrientationJacobian(self):
        """
        Returns the orientation jacobian of this link w.r.t. the robot's configuration
        q.  


        Returns:  

            (list of 3 lists of floats): the 3xn orientation Jacobian matrix of
            the link.  The matrix is row-major.

            This matrix J gives the link's angular velocity (in world coordinates)
            via np.dot(J,dq), where dq is the robot's joint velocities.  

        """
        return _robotsim.RobotModelLink_getOrientationJacobian(self)


    def getAcceleration(self, ddq):
        """
        Returns the acceleration of the link origin given the robot's current joint
        configuration and velocities, and the joint accelerations ddq.  

        Args:
            ddq (:obj:`list of floats`)

        ddq can be empty, which calculates the acceleration with acceleration 0, and is
        a little faster than setting ddq to [0]*n  

        Returns:  

            (list of 3 floats): the acceleration of the link's origin, in
            world coordinates.  

        """
        return _robotsim.RobotModelLink_getAcceleration(self, ddq)


    def getPointAcceleration(self, plocal, ddq):
        """
        Returns the acceleration of the point given the robot's current joint
        configuration and velocities, and the joint accelerations ddq.  

        Args:
            plocal (:obj:`list of 3 floats`)
            ddq (:obj:`list of floats`)

        Returns:  

            (list of 3 floats): the acceleration of the point, in
            world coordinates.  

        """
        return _robotsim.RobotModelLink_getPointAcceleration(self, plocal, ddq)


    def getAngularAcceleration(self, ddq):
        """
        Returns the angular acceleration of the link given the robot's current joint
        configuration and velocities, and the joint accelerations ddq.  

        Args:
            ddq (:obj:`list of floats`)

        Returns:  

            (list of 3 floats): the angular acceleration of the link, in
            world coordinates.  

        """
        return _robotsim.RobotModelLink_getAngularAcceleration(self, ddq)


    def getPositionHessian(self, plocal):
        """
        Returns the Hessians of each component of the position p w.r.t the robot's
        configuration q.  

        Args:
            plocal (:obj:`list of 3 floats`)

        Returns:  

            (3-tuple): a triple (Hx,Hy,Hz) of of nxn matrices corresponding,
            respectively, to the (x,y,z) components of the Hessian.  

        """
        return _robotsim.RobotModelLink_getPositionHessian(self, plocal)


    def getOrientationHessian(self):
        """
        Returns the Hessians of each orientation component of the link w.r.t the robot's
        configuration q.  


        Returns:  

            (3-tuple): a triple (Hx,Hy,Hz) of of nxn matrices corresponding,
            respectively, to the (wx,wy,wz) components of the Hessian.  

        """
        return _robotsim.RobotModelLink_getOrientationHessian(self)


    def drawLocalGL(self, keepAppearance=True):
        """
        Draws the link's geometry in its local frame. If keepAppearance=true, the
        current Appearance is honored. Otherwise, just the geometry is drawn.  

        drawLocalGL (keepAppearance=True)

        drawLocalGL ()


        Args:
            keepAppearance (bool, optional): default value True
        """
        return _robotsim.RobotModelLink_drawLocalGL(self, keepAppearance)


    def drawWorldGL(self, keepAppearance=True):
        """
        Draws the link's geometry in the world frame. If keepAppearance=true, the
        current Appearance is honored. Otherwise, just the geometry is drawn.  

        drawWorldGL (keepAppearance=True)

        drawWorldGL ()


        Args:
            keepAppearance (bool, optional): default value True
        """
        return _robotsim.RobotModelLink_drawWorldGL(self, keepAppearance)

    __swig_setmethods__["world"] = _robotsim.RobotModelLink_world_set
    __swig_getmethods__["world"] = _robotsim.RobotModelLink_world_get
    if _newclass:
        world = _swig_property(_robotsim.RobotModelLink_world_get, _robotsim.RobotModelLink_world_set)
    __swig_setmethods__["robotIndex"] = _robotsim.RobotModelLink_robotIndex_set
    __swig_getmethods__["robotIndex"] = _robotsim.RobotModelLink_robotIndex_get
    if _newclass:
        robotIndex = _swig_property(_robotsim.RobotModelLink_robotIndex_get, _robotsim.RobotModelLink_robotIndex_set)
    __swig_setmethods__["robotPtr"] = _robotsim.RobotModelLink_robotPtr_set
    __swig_getmethods__["robotPtr"] = _robotsim.RobotModelLink_robotPtr_get
    if _newclass:
        robotPtr = _swig_property(_robotsim.RobotModelLink_robotPtr_get, _robotsim.RobotModelLink_robotPtr_set)
    __swig_setmethods__["index"] = _robotsim.RobotModelLink_index_set
    __swig_getmethods__["index"] = _robotsim.RobotModelLink_index_get
    if _newclass:
        index = _swig_property(_robotsim.RobotModelLink_index_get, _robotsim.RobotModelLink_index_set)
    __swig_destroy__ = _robotsim.delete_RobotModelLink
    __del__ = lambda self: None
RobotModelLink_swigregister = _robotsim.RobotModelLink_swigregister
RobotModelLink_swigregister(RobotModelLink)

class RobotModelDriver(_object):
    """


    A reference to a driver of a RobotModel.  

    A driver corresponds to one of the robot's actuators and encodes how its forces
    are transmitted to joints.  

    A RobotModelDriver is not created by hand, but instead accessed using
    :meth:`RobotModel.driver` (index or name)  

    C++ includes: robotmodel.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RobotModelDriver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RobotModelDriver, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        """
        this = _robotsim.new_RobotModelDriver()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def getName(self):
        """
        Returns:
            (str):
        """
        return _robotsim.RobotModelDriver_getName(self)


    def robot(self):
        """
        Returns a reference to the driver's robot.  

        Returns:
            (:class:`~klampt.RobotModel`):
        """
        return _robotsim.RobotModelDriver_robot(self)


    def getType(self):
        """
        Currently can be "normal", "affine", "rotation", "translation", or
        "custom".  

        Returns:
            (str):
        """
        return _robotsim.RobotModelDriver_getType(self)


    def getAffectedLink(self):
        """
        Returns the single affected link for "normal" links.  

        Returns:
            (int):
        """
        return _robotsim.RobotModelDriver_getAffectedLink(self)


    def getAffectedLinks(self):
        """
        Returns the indices of the driver's affected links.  

        """
        return _robotsim.RobotModelDriver_getAffectedLinks(self)


    def getAffineCoeffs(self):
        """
        For "affine" links, returns the scale and offset of the driver value mapped to
        the world.  


        Returns: tuple: a pair (scale,offset), each of length len(getAffectedLinks()).  

        """
        return _robotsim.RobotModelDriver_getAffineCoeffs(self)


    def setValue(self, val):
        """
        Sets the robot's config to correspond to the given driver value.  

        Args:
            val (float)
        """
        return _robotsim.RobotModelDriver_setValue(self, val)


    def getValue(self):
        """
        Gets the current driver value from the robot's config.  

        Returns:
            (float):
        """
        return _robotsim.RobotModelDriver_getValue(self)


    def setVelocity(self, val):
        """
        Sets the robot's velocity to correspond to the given driver velocity value.  

        Args:
            val (float)
        """
        return _robotsim.RobotModelDriver_setVelocity(self, val)


    def getVelocity(self):
        """
        Gets the current driver velocity value from the robot's velocity.  

        Returns:
            (float):
        """
        return _robotsim.RobotModelDriver_getVelocity(self)

    __swig_setmethods__["world"] = _robotsim.RobotModelDriver_world_set
    __swig_getmethods__["world"] = _robotsim.RobotModelDriver_world_get
    if _newclass:
        world = _swig_property(_robotsim.RobotModelDriver_world_get, _robotsim.RobotModelDriver_world_set)
    __swig_setmethods__["robotIndex"] = _robotsim.RobotModelDriver_robotIndex_set
    __swig_getmethods__["robotIndex"] = _robotsim.RobotModelDriver_robotIndex_get
    if _newclass:
        robotIndex = _swig_property(_robotsim.RobotModelDriver_robotIndex_get, _robotsim.RobotModelDriver_robotIndex_set)
    __swig_setmethods__["robotPtr"] = _robotsim.RobotModelDriver_robotPtr_set
    __swig_getmethods__["robotPtr"] = _robotsim.RobotModelDriver_robotPtr_get
    if _newclass:
        robotPtr = _swig_property(_robotsim.RobotModelDriver_robotPtr_get, _robotsim.RobotModelDriver_robotPtr_set)
    __swig_setmethods__["index"] = _robotsim.RobotModelDriver_index_set
    __swig_getmethods__["index"] = _robotsim.RobotModelDriver_index_get
    if _newclass:
        index = _swig_property(_robotsim.RobotModelDriver_index_get, _robotsim.RobotModelDriver_index_set)
    __swig_destroy__ = _robotsim.delete_RobotModelDriver
    __del__ = lambda self: None
RobotModelDriver_swigregister = _robotsim.RobotModelDriver_swigregister
RobotModelDriver_swigregister(RobotModelDriver)

class RobotModel(_object):
    """


    A model of a dynamic and kinematic robot.  

    Stores both constant information, like the reference placement of the links,
    joint limits, velocity limits, etc, as well as a *current configuration* and
    *current velocity* which are state-dependent. Several functions depend on the
    robot's current configuration and/or velocity. To update that, use the
    setConfig() and setVelocity() functions. setConfig() also update's the robot's
    link transforms via forward kinematics. You may also use setDOFPosition and
    setDOFVelocity for individual changes, but this is more expensive because each
    call updates all of the affected the link transforms.  

    It is important to understand that changing the configuration of the model
    doesn't actually send a command to the physical / simulated robot. Moreover, the
    model does not automatically get updated when the physical / simulated robot
    moves. In essence, the model maintains temporary storage for performing
    kinematics, dynamics, and planning computations, as well as for visualization.  

    The state of the robot is retrieved using getConfig/getVelocity calls, and is
    set using setConfig/setVelocity. Because many routines change the robot's
    configuration, like IK and motion planning, a common design pattern is to
    save/restore the configuration as follows::  

        q = robot.getConfig()
        do some stuff that may touch the robot's configuration...
        robot.setConfig(q)  

    The model maintains configuration/velocity/acceleration/torque bounds. However,
    these are not enforced by the model, so you can happily set configurations
    outside must rather be enforced by the planner / simulator.  

    C++ includes: robotmodel.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RobotModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RobotModel, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        """
        this = _robotsim.new_RobotModel()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def loadFile(self, fn):
        """
        Loads the robot from the file fn.  

        Args:
            fn (str)
        Returns:
            (bool):
        """
        return _robotsim.RobotModel_loadFile(self, fn)


    def saveFile(self, fn, geometryPrefix=None):
        """
        Saves the robot to the file fn.  

        saveFile (fn,geometryPrefix=None): bool

        saveFile (fn): bool


        Args:
            fn (str): 
            geometryPrefix (str, optional): default value None

        Returns:
            (bool):

        If `geometryPrefix == None` (default), the geometry is not saved. Otherwise, the
        geometry of each link will be saved to files named `geometryPrefix+name`, where
        `name` is either the name of the geometry file that was loaded, or
        `[link_name].off`  

        """
        return _robotsim.RobotModel_saveFile(self, fn, geometryPrefix)


    def getID(self):
        """
        Returns the ID of the robot in its world.  

        Returns:
            (int):

        Note: The world ID is not the same as the robot index.  

        """
        return _robotsim.RobotModel_getID(self)


    def getName(self):
        """
        Returns:
            (str):
        """
        return _robotsim.RobotModel_getName(self)


    def setName(self, name):
        """
        Args:
            name (str)
        """
        return _robotsim.RobotModel_setName(self, name)


    def numLinks(self):
        """
        Returns the number of links = number of DOF's.  

        Returns:
            (int):
        """
        return _robotsim.RobotModel_numLinks(self)


    def link(self, *args):
        """
        Returns a reference to the link by index or name.  

        link (index): :class:`~klampt.RobotModelLink`

        link (name): :class:`~klampt.RobotModelLink`


        Args:
            index (int, optional): 
            name (str, optional): 

        Returns:
            (:class:`~klampt.RobotModelLink`):
        """
        return _robotsim.RobotModel_link(self, *args)


    def numDrivers(self):
        """
        Returns the number of drivers.  

        Returns:
            (int):
        """
        return _robotsim.RobotModel_numDrivers(self)


    def driver(self, *args):
        """
        Returns a reference to the driver by index or name.  

        driver (index): :obj:`RobotModelDriver`

        driver (name): :obj:`RobotModelDriver`


        Args:
            index (int, optional): 
            name (str, optional): 

        Returns:
            (:obj:`RobotModelDriver`):
        """
        return _robotsim.RobotModel_driver(self, *args)


    def getJointType(self, *args):
        """
        Returns the joint type of the joint connecting the link to its parent, where the
        link is identified by index or by name.  

        getJointType (index): str

        getJointType (name): str


        Args:
            index (int, optional): 
            name (str, optional): 

        Returns:
            (str):
        """
        return _robotsim.RobotModel_getJointType(self, *args)


    def getConfig(self):
        """
        Retrieves the current configuration of the robot model.  

        """
        return _robotsim.RobotModel_getConfig(self)


    def getVelocity(self):
        """
        Retreives the current velocity of the robot model.  

        """
        return _robotsim.RobotModel_getVelocity(self)


    def setConfig(self, q):
        """
        Sets the current configuration of the robot. Input q is a vector of length
        numLinks(). This also updates forward kinematics of all links.  

        Args:
            q (:obj:`list of floats`)

        Again, it is important to realize that the RobotModel is not the same as a
        simulated robot, and this will not change the simulation world. Many functions
        such as IK and motion planning use the RobotModel configuration as a temporary
        variable, so if you need to keep the configuration through a robot-modifying
        function call, you should call `q = robot.getConfig()` before the call, and then
        `robot.setConfig(q)` after it.  

        """
        return _robotsim.RobotModel_setConfig(self, q)


    def setVelocity(self, dq):
        """
        Sets the current velocity of the robot model. Like the configuration, this is
        also essentially a temporary variable.  

        Args:
            dq (:obj:`list of floats`)
        """
        return _robotsim.RobotModel_setVelocity(self, dq)


    def getJointLimits(self):
        """
        Retrieves a pair (qmin,qmax) of min/max joint limit vectors.  

        """
        return _robotsim.RobotModel_getJointLimits(self)


    def setJointLimits(self, qmin, qmax):
        """
        Sets the min/max joint limit vectors (must have length numLinks())  

        Args:
            qmin (:obj:`list of floats`)
            qmax (:obj:`list of floats`)
        """
        return _robotsim.RobotModel_setJointLimits(self, qmin, qmax)


    def getVelocityLimits(self):
        """
        Retrieve the velocity limit vector vmax, the constraint is :math:`|dq[i]| \leq
        vmax[i]`  

        """
        return _robotsim.RobotModel_getVelocityLimits(self)


    def setVelocityLimits(self, vmax):
        """
        Sets the velocity limit vector vmax, the constraint is :math:`|dq[i]| \leq
        vmax[i]`  

        Args:
            vmax (:obj:`list of floats`)
        """
        return _robotsim.RobotModel_setVelocityLimits(self, vmax)


    def getAccelerationLimits(self):
        """
        Retrieve the acceleration limit vector amax, the constraint is :math:`|ddq[i]|
        \leq amax[i]`  

        """
        return _robotsim.RobotModel_getAccelerationLimits(self)


    def setAccelerationLimits(self, amax):
        """
        Sets the acceleration limit vector amax, the constraint is :math:`|ddq[i]| \leq
        amax[i]`  

        Args:
            amax (:obj:`list of floats`)
        """
        return _robotsim.RobotModel_setAccelerationLimits(self, amax)


    def getTorqueLimits(self):
        """
        Retrieve the torque limit vector tmax, the constraint is :math:`|torque[i]|
        \leq tmax[i]`  

        """
        return _robotsim.RobotModel_getTorqueLimits(self)


    def setTorqueLimits(self, tmax):
        """
        Sets the torque limit vector tmax, the constraint is :math:`|torque[i]|
        <\leqtmax[i]`  

        Args:
            tmax (:obj:`list of floats`)
        """
        return _robotsim.RobotModel_setTorqueLimits(self, tmax)


    def setDOFPosition(self, *args):
        """
        Sets a single DOF's position (by index or by name).  

        setDOFPosition (i,qi)

        setDOFPosition (name,qi)


        Args:
            i (int, optional): 
            qi (float): 
            name (str, optional): 

        Note: if you are setting several joints at once, use setConfig because this
        function computes forward kinematics each time it is called.  

        """
        return _robotsim.RobotModel_setDOFPosition(self, *args)


    def getDOFPosition(self, *args):
        """
        Returns a single DOF's position (by name)  

        getDOFPosition (i): float

        getDOFPosition (name): float


        Args:
            i (int, optional): 
            name (str, optional): 

        Returns:
            (float):
        """
        return _robotsim.RobotModel_getDOFPosition(self, *args)


    def getCom(self):
        """
        Returns the 3D center of mass at the current config.  

        """
        return _robotsim.RobotModel_getCom(self)


    def getComVelocity(self):
        """
        Returns the 3D velocity of the center of mass at the current config / velocity.  

        """
        return _robotsim.RobotModel_getComVelocity(self)


    def getComJacobian(self):
        """
        Returns the Jacobian matrix of the current center of mass.  


        Returns:  

            (list of 3 lists): a 3xn matrix J such that np.dot(J,dq) gives the
            COM velocity at the currene configuration  

        """
        return _robotsim.RobotModel_getComJacobian(self)


    def getLinearMomentum(self):
        """
        Returns the 3D linear momentum vector.  

        """
        return _robotsim.RobotModel_getLinearMomentum(self)


    def getAngularMomentum(self):
        """
        Returns the 3D angular momentum vector.  

        """
        return _robotsim.RobotModel_getAngularMomentum(self)


    def getKineticEnergy(self):
        """
        Returns the kinetic energy at the current config / velocity.  

        Returns:
            (float):
        """
        return _robotsim.RobotModel_getKineticEnergy(self)


    def getTotalInertia(self):
        """
        Calculates the 3x3 total inertia matrix of the robot.  

        """
        return _robotsim.RobotModel_getTotalInertia(self)


    def getMassMatrix(self):
        """
        Returns the nxn mass matrix B(q). Takes O(n^2) time.  

        """
        return _robotsim.RobotModel_getMassMatrix(self)


    def getMassMatrixInv(self):
        """
        Returns the inverse of the nxn mass matrix B(q)^-1. Takes O(n^2) time, which is
        much faster than inverting the result of getMassMatrix.  

        """
        return _robotsim.RobotModel_getMassMatrixInv(self)


    def getMassMatrixDeriv(self, i):
        """
        Returns the derivative of the nxn mass matrix with respect to q_i. Takes O(n^3)
        time.  

        Args:
            i (int)
        """
        return _robotsim.RobotModel_getMassMatrixDeriv(self, i)


    def getMassMatrixTimeDeriv(self):
        """
        Returns the derivative of the nxn mass matrix with respect to t, given the
        robot's current velocity. Takes O(n^4) time.  

        """
        return _robotsim.RobotModel_getMassMatrixTimeDeriv(self)


    def getCoriolisForceMatrix(self):
        """
        Returns the Coriolis force matrix C(q,dq) for current config and velocity. Takes
        O(n^2) time.  

        """
        return _robotsim.RobotModel_getCoriolisForceMatrix(self)


    def getCoriolisForces(self):
        """
        Returns the Coriolis forces C(q,dq)*dq for current config and velocity. Takes
        O(n) time, which is faster than computing matrix and doing product. ("Forces"
        is somewhat of a misnomer; the result is a joint torque vector)  

        """
        return _robotsim.RobotModel_getCoriolisForces(self)


    def getGravityForces(self, g):
        """
        Returns the generalized gravity vector G(q) for the given workspace gravity
        vector g (usually (0,0,-9.8)).  

        Args:
            g (:obj:`list of 3 floats`)

        Note:  

            "Forces" is somewhat of a misnomer; the result is a vector of joint
            torques.  

        Returns:  

            (list of floats): the n-element generalized gravity vector at the
            robot's current configuration.  

        """
        return _robotsim.RobotModel_getGravityForces(self, g)


    def torquesFromAccel(self, ddq):
        """
        Computes the inverse dynamics. Uses Recursive Newton Euler solver and takes O(n)
        time.  

        Args:
            ddq (:obj:`list of floats`)

        Note:  

            Does not include gravity term G(q).  getGravityForces(g) will need
            to be added to the result.  

        Returns:  

            (list of floats): the n-element torque vector that would produce
            the joint accelerations ddq in the absence of external forces.  

        """
        return _robotsim.RobotModel_torquesFromAccel(self, ddq)


    def accelFromTorques(self, t):
        """
        Computes the foward dynamics (using Recursive Newton Euler solver)  

        Args:
            t (:obj:`list of floats`)

        Note:  

            Does not include gravity term G(q).  getGravityForces(g) will need
            to be subtracted from the argument t.  

        Returns:  

            (list of floats): the n-element joint acceleration vector that would
            result from joint torques t in the absence of external forces.  

        """
        return _robotsim.RobotModel_accelFromTorques(self, t)


    def interpolate(self, a, b, u):
        """
        Interpolates smoothly between two configurations, properly taking into account
        nonstandard joints.  

        Args:
            a (:obj:`list of floats`)
            b (:obj:`list of floats`)
            u (float)

        Returns:  

            (list of n floats): The configuration that is u fraction of the way
            from a to b  

        """
        return _robotsim.RobotModel_interpolate(self, a, b, u)


    def distance(self, a, b):
        """
        Computes a distance between two configurations, properly taking into account
        nonstandard joints.  

        Args:
            a (:obj:`list of floats`)
            b (:obj:`list of floats`)
        Returns:
            (float):
        """
        return _robotsim.RobotModel_distance(self, a, b)


    def interpolateDeriv(self, a, b):
        """
        Returns the configuration derivative at a as you interpolate toward b at unit
        speed.  

        Args:
            a (:obj:`list of floats`)
            b (:obj:`list of floats`)
        """
        return _robotsim.RobotModel_interpolateDeriv(self, a, b)


    def randomizeConfig(self, unboundedScale=1.0):
        """
        Samples a random configuration and updates the robot's pose. Properly handles
        non-normal joints and handles DOFs with infinite bounds using a centered
        Laplacian distribution with the given scaling term. (Note that the python random
        seeding does not affect the result.)  

        randomizeConfig (unboundedScale=1.0)

        randomizeConfig ()


        Args:
            unboundedScale (float, optional): default value 1.0
        """
        return _robotsim.RobotModel_randomizeConfig(self, unboundedScale)


    def selfCollisionEnabled(self, link1, link2):
        """
        Queries whether self collisions between two links is enabled.  

        Args:
            link1 (int)
            link2 (int)
        Returns:
            (bool):
        """
        return _robotsim.RobotModel_selfCollisionEnabled(self, link1, link2)


    def enableSelfCollision(self, link1, link2, value):
        """
        Enables/disables self collisions between two links (depending on value)  

        Args:
            link1 (int)
            link2 (int)
            value (bool)
        """
        return _robotsim.RobotModel_enableSelfCollision(self, link1, link2, value)


    def selfCollides(self):
        """
        Returns true if the robot is in self collision (faster than manual testing)  

        Returns:
            (bool):
        """
        return _robotsim.RobotModel_selfCollides(self)


    def drawGL(self, keepAppearance=True):
        """
        Draws the robot geometry. If keepAppearance=true, the current appearance is
        honored. Otherwise, only the raw geometry is drawn.  

        drawGL (keepAppearance=True)

        drawGL ()


        Args:
            keepAppearance (bool, optional): default value True

        PERFORMANCE WARNING: if keepAppearance is false, then this does not properly
        reuse OpenGL display lists. A better approach to changing the robot's
        appearances is to set the link Appearance's directly.  

        """
        return _robotsim.RobotModel_drawGL(self, keepAppearance)

    __swig_setmethods__["world"] = _robotsim.RobotModel_world_set
    __swig_getmethods__["world"] = _robotsim.RobotModel_world_get
    if _newclass:
        world = _swig_property(_robotsim.RobotModel_world_get, _robotsim.RobotModel_world_set)
    __swig_setmethods__["index"] = _robotsim.RobotModel_index_set
    __swig_getmethods__["index"] = _robotsim.RobotModel_index_get
    if _newclass:
        index = _swig_property(_robotsim.RobotModel_index_get, _robotsim.RobotModel_index_set)
    __swig_setmethods__["robot"] = _robotsim.RobotModel_robot_set
    __swig_getmethods__["robot"] = _robotsim.RobotModel_robot_get
    if _newclass:
        robot = _swig_property(_robotsim.RobotModel_robot_get, _robotsim.RobotModel_robot_set)
    __swig_setmethods__["dirty_dynamics"] = _robotsim.RobotModel_dirty_dynamics_set
    __swig_getmethods__["dirty_dynamics"] = _robotsim.RobotModel_dirty_dynamics_get
    if _newclass:
        dirty_dynamics = _swig_property(_robotsim.RobotModel_dirty_dynamics_get, _robotsim.RobotModel_dirty_dynamics_set)
    __swig_destroy__ = _robotsim.delete_RobotModel
    __del__ = lambda self: None
RobotModel_swigregister = _robotsim.RobotModel_swigregister
RobotModel_swigregister(RobotModel)

class RigidObjectModel(_object):
    """


    A rigid movable object.  

    A rigid object has a name, geometry, appearance, mass, surface properties, and
    current transform / velocity.  

    State is retrieved/set using get/setTransform, and get/setVelocity  

    C++ includes: robotmodel.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RigidObjectModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RigidObjectModel, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        """
        this = _robotsim.new_RigidObjectModel()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def loadFile(self, fn):
        """
        Loads the object from the file fn.  

        Args:
            fn (str)
        Returns:
            (bool):
        """
        return _robotsim.RigidObjectModel_loadFile(self, fn)


    def saveFile(self, fn, geometryName=None):
        """
        Saves the object to the file fn. If geometryName is given, the geometry is saved
        to that file.  

        saveFile (fn,geometryName=None): bool

        saveFile (fn): bool


        Args:
            fn (str): 
            geometryName (str, optional): default value None

        Returns:
            (bool):
        """
        return _robotsim.RigidObjectModel_saveFile(self, fn, geometryName)


    def getID(self):
        """
        Returns the ID of the rigid object in its world.  

        Returns:
            (int):

        Note: The world ID is not the same as the rigid object index.  

        """
        return _robotsim.RigidObjectModel_getID(self)


    def getName(self):
        """
        Returns:
            (str):
        """
        return _robotsim.RigidObjectModel_getName(self)


    def setName(self, name):
        """
        Args:
            name (str)
        """
        return _robotsim.RigidObjectModel_setName(self, name)


    def geometry(self):
        """
        Returns a reference to the geometry associated with this object.  

        Returns:
            (:class:`~klampt.Geometry3D`):
        """
        return _robotsim.RigidObjectModel_geometry(self)


    def appearance(self):
        """
        Returns a reference to the appearance associated with this object.  

        Returns:
            (:class:`~klampt.Appearance`):
        """
        return _robotsim.RigidObjectModel_appearance(self)


    def getMass(self):
        """
        Returns a copy of the Mass of this rigid object.  

        Returns:
            (:class:`~klampt.Mass`):

        Note:  

            To change the mass properties, you should call ``m=object.getMass()``,
            change the desired properties in m, and then ``object.setMass(m)``  

        """
        return _robotsim.RigidObjectModel_getMass(self)


    def setMass(self, mass):
        """
        Args:
            mass (:class:`~klampt.Mass`)
        """
        return _robotsim.RigidObjectModel_setMass(self, mass)


    def getContactParameters(self):
        """
        Returns a copy of the ContactParameters of this rigid object.  

        Returns:
            (:class:`~klampt.ContactParameters`):

        Note:  

            To change the contact parameters, you should call
            ``p=object.getContactParameters()``, change the desired properties in
            p, and then call ``object.setContactParameters(p)``  

        """
        return _robotsim.RigidObjectModel_getContactParameters(self)


    def setContactParameters(self, params):
        """
        Args:
            params (:class:`~klampt.ContactParameters`)
        """
        return _robotsim.RigidObjectModel_setContactParameters(self, params)


    def getTransform(self):
        """
        Retrieves the rotation / translation of the rigid object (R,t)  


        Returns:  

            (se3 object): a pair (R,t), with R a 9-list and t a 3-list of floats,
            giving the transform to world coordinates.  

        """
        return _robotsim.RigidObjectModel_getTransform(self)


    def setTransform(self, R, t):
        """
        Sets the rotation / translation (R,t) of the rigid object.  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.RigidObjectModel_setTransform(self, R, t)


    def getVelocity(self):
        """
        Retrieves the (angular velocity, velocity) of the rigid object.  


        Returns:  

            (tuple): a pair of 3-lists (w,v) where w is the angular velocity
            vector and v is the translational velocity vector (both in world
            coordinates)  

        """
        return _robotsim.RigidObjectModel_getVelocity(self)


    def setVelocity(self, angularVelocity, velocity):
        """
        Sets the (angular velocity, velocity) of the rigid object.  

        Args:
            angularVelocity (:obj:`list of 3 floats`)
            velocity (:obj:`list of 3 floats`)
        """
        return _robotsim.RigidObjectModel_setVelocity(self, angularVelocity, velocity)


    def drawGL(self, keepAppearance=True):
        """
        Draws the object's geometry. If keepAppearance=true, the current appearance is
        honored. Otherwise, only the raw geometry is drawn.  

        drawGL (keepAppearance=True)

        drawGL ()


        Args:
            keepAppearance (bool, optional): default value True

        PERFORMANCE WARNING: if keepAppearance is false, then this does not properly
        reuse OpenGL display lists. A better approach is to change the object's
        Appearance directly.  

        """
        return _robotsim.RigidObjectModel_drawGL(self, keepAppearance)

    __swig_setmethods__["world"] = _robotsim.RigidObjectModel_world_set
    __swig_getmethods__["world"] = _robotsim.RigidObjectModel_world_get
    if _newclass:
        world = _swig_property(_robotsim.RigidObjectModel_world_get, _robotsim.RigidObjectModel_world_set)
    __swig_setmethods__["index"] = _robotsim.RigidObjectModel_index_set
    __swig_getmethods__["index"] = _robotsim.RigidObjectModel_index_get
    if _newclass:
        index = _swig_property(_robotsim.RigidObjectModel_index_get, _robotsim.RigidObjectModel_index_set)
    __swig_setmethods__["object"] = _robotsim.RigidObjectModel_object_set
    __swig_getmethods__["object"] = _robotsim.RigidObjectModel_object_get
    if _newclass:
        object = _swig_property(_robotsim.RigidObjectModel_object_get, _robotsim.RigidObjectModel_object_set)
    __swig_destroy__ = _robotsim.delete_RigidObjectModel
    __del__ = lambda self: None
RigidObjectModel_swigregister = _robotsim.RigidObjectModel_swigregister
RigidObjectModel_swigregister(RigidObjectModel)

class TerrainModel(_object):
    """


    Static environment geometry.  

    C++ includes: robotmodel.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TerrainModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TerrainModel, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        """
        this = _robotsim.new_TerrainModel()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def loadFile(self, fn):
        """
        Loads the terrain from the file fn.  

        Args:
            fn (str)
        Returns:
            (bool):
        """
        return _robotsim.TerrainModel_loadFile(self, fn)


    def saveFile(self, fn, geometryName=None):
        """
        Saves the terrain to the file fn. If geometryName is given, the geometry is
        saved to that file.  

        saveFile (fn,geometryName=None): bool

        saveFile (fn): bool


        Args:
            fn (str): 
            geometryName (str, optional): default value None

        Returns:
            (bool):
        """
        return _robotsim.TerrainModel_saveFile(self, fn, geometryName)


    def getID(self):
        """
        Returns the ID of the terrain in its world.  

        Returns:
            (int):

        Note: The world ID is not the same as the terrain index.  

        """
        return _robotsim.TerrainModel_getID(self)


    def getName(self):
        """
        Returns:
            (str):
        """
        return _robotsim.TerrainModel_getName(self)


    def setName(self, name):
        """
        Args:
            name (str)
        """
        return _robotsim.TerrainModel_setName(self, name)


    def geometry(self):
        """
        Returns a reference to the geometry associated with this object.  

        Returns:
            (:class:`~klampt.Geometry3D`):
        """
        return _robotsim.TerrainModel_geometry(self)


    def appearance(self):
        """
        Returns a reference to the appearance associated with this object.  

        Returns:
            (:class:`~klampt.Appearance`):
        """
        return _robotsim.TerrainModel_appearance(self)


    def setFriction(self, friction):
        """
        Changes the friction coefficient for this terrain.  

        Args:
            friction (float)
        """
        return _robotsim.TerrainModel_setFriction(self, friction)


    def drawGL(self, keepAppearance=True):
        """
        Draws the object's geometry. If keepAppearance=true, the current appearance is
        honored. Otherwise, only the raw geometry is drawn.  

        drawGL (keepAppearance=True)

        drawGL ()


        Args:
            keepAppearance (bool, optional): default value True

        PERFORMANCE WARNING: if keepAppearance is false, then this does not properly
        reuse OpenGL display lists. A better approach is to change the object's
        Appearance directly.  

        """
        return _robotsim.TerrainModel_drawGL(self, keepAppearance)

    __swig_setmethods__["world"] = _robotsim.TerrainModel_world_set
    __swig_getmethods__["world"] = _robotsim.TerrainModel_world_get
    if _newclass:
        world = _swig_property(_robotsim.TerrainModel_world_get, _robotsim.TerrainModel_world_set)
    __swig_setmethods__["index"] = _robotsim.TerrainModel_index_set
    __swig_getmethods__["index"] = _robotsim.TerrainModel_index_get
    if _newclass:
        index = _swig_property(_robotsim.TerrainModel_index_get, _robotsim.TerrainModel_index_set)
    __swig_setmethods__["terrain"] = _robotsim.TerrainModel_terrain_set
    __swig_getmethods__["terrain"] = _robotsim.TerrainModel_terrain_get
    if _newclass:
        terrain = _swig_property(_robotsim.TerrainModel_terrain_get, _robotsim.TerrainModel_terrain_set)
    __swig_destroy__ = _robotsim.delete_TerrainModel
    __del__ = lambda self: None
TerrainModel_swigregister = _robotsim.TerrainModel_swigregister
TerrainModel_swigregister(TerrainModel)

class WorldModel(_object):
    """


    The main world class, containing robots, rigid objects, and static environment
    geometry.  

    Note that this is just a model and can be changed at will -- in fact planners
    and simulators will make use of a model to "display" computed  

    Every robot/robot link/terrain/rigid object is given a unique ID in the world.
    This is potentially a source of confusion because some functions take IDs and
    some take indices. Only the WorldModel and Simulator classes use IDs when the
    argument has 'id' as a suffix, e.g., geometry(), appearance(),
    Simulator.inContact(). All other functions use indices, e.g. robot(0),
    terrain(0), etc.  

    To get an object's ID, you can see the value returned by loadElement and/or
    object.getID(). states.  

    To save/restore the state of the model, you must manually maintain copies of the
    states of whichever objects you wish to save/restore.  

    C++ includes: robotmodel.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WorldModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WorldModel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a WorldModel.  

        __init__ (): :class:`~klampt.WorldModel`

        __init__ (ptrRobotWorld): :class:`~klampt.WorldModel`

        __init__ (w): :class:`~klampt.WorldModel`

        __init__ (fn): :class:`~klampt.WorldModel`


        Args:
            ptrRobotWorld (:obj:`void`, optional): 
            w (:class:`~klampt.WorldModel`, optional): 
            fn (str, optional): 

        *   Given no arguments, creates a new world.  
        *   Given another WorldModel instance, creates a reference to an existing world.
            (To create a copy, use the copy() method.)  
        *   Given a string, loads from a file. A PyException is raised on failure.  
        *   Given a pointer to a C++ RobotWorld structure, a reference to that structure
            is returned. (This is advanced usage, seen only when interfacing C++ and
            Python code)  

        """
        this = _robotsim.new_WorldModel(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_WorldModel
    __del__ = lambda self: None

    def copy(self):
        """
        Creates a copy of the world model. Note that geometries and appearances are
        shared, so this is very quick.  

        Returns:
            (:class:`~klampt.WorldModel`):
        """
        return _robotsim.WorldModel_copy(self)


    def readFile(self, fn):
        """
        Reads from a world XML file.  

        Args:
            fn (str)
        Returns:
            (bool):
        """
        return _robotsim.WorldModel_readFile(self, fn)


    def loadFile(self, fn):
        """
        Alias of readFile.  

        Args:
            fn (str)
        Returns:
            (bool):
        """
        return _robotsim.WorldModel_loadFile(self, fn)


    def saveFile(self, fn, elementDir=None):
        """
        Saves to a world XML file. If elementDir is provided, then robots, terrains,
        etc. will be saved there. Otherwise they will be saved to a folder with the same
        base name as fn (without the trailing .xml)  

        saveFile (fn,elementDir=None): bool

        saveFile (fn): bool


        Args:
            fn (str): 
            elementDir (str, optional): default value None

        Returns:
            (bool):
        """
        return _robotsim.WorldModel_saveFile(self, fn, elementDir)


    def numRobots(self):
        """
        Returns:
            (int):
        """
        return _robotsim.WorldModel_numRobots(self)


    def numRobotLinks(self, robot):
        """
        Args:
            robot (int)
        Returns:
            (int):
        """
        return _robotsim.WorldModel_numRobotLinks(self, robot)


    def numRigidObjects(self):
        """
        Returns:
            (int):
        """
        return _robotsim.WorldModel_numRigidObjects(self)


    def numTerrains(self):
        """
        Returns:
            (int):
        """
        return _robotsim.WorldModel_numTerrains(self)


    def numIDs(self):
        """
        Returns:
            (int):
        """
        return _robotsim.WorldModel_numIDs(self)


    def robot(self, *args):
        """
        Returns a RobotModel in the world by index or name.  

        robot (index): :class:`~klampt.RobotModel`

        robot (name): :class:`~klampt.RobotModel`


        Args:
            index (int, optional): 
            name (str, optional): 

        Returns:
            (:class:`~klampt.RobotModel`):
        """
        return _robotsim.WorldModel_robot(self, *args)


    def robotLink(self, *args):
        """
        Returns a RobotModelLink of some RobotModel in the world by index or name.  

        robotLink (robot,index): :class:`~klampt.RobotModelLink`

        robotLink (robot,name): :class:`~klampt.RobotModelLink`


        Args:
            robot (int or str): 
            index (int, optional): 
            name (str, optional): 

        Returns:
            (:class:`~klampt.RobotModelLink`):
        """
        return _robotsim.WorldModel_robotLink(self, *args)


    def rigidObject(self, *args):
        """
        Returns a RigidObjectModel in the world by index or name.  

        rigidObject (index): :class:`~klampt.RigidObjectModel`

        rigidObject (name): :class:`~klampt.RigidObjectModel`


        Args:
            index (int, optional): 
            name (str, optional): 

        Returns:
            (:class:`~klampt.RigidObjectModel`):
        """
        return _robotsim.WorldModel_rigidObject(self, *args)


    def terrain(self, *args):
        """
        Returns a TerrainModel in the world by index or name.  

        terrain (index): :obj:`TerrainModel`

        terrain (name): :obj:`TerrainModel`


        Args:
            index (int, optional): 
            name (str, optional): 

        Returns:
            (:obj:`TerrainModel`):
        """
        return _robotsim.WorldModel_terrain(self, *args)


    def makeRobot(self, name):
        """
        Creates a new empty robot. (Not terribly useful now since you can't resize the
        number of links yet)  

        Args:
            name (str)
        Returns:
            (:class:`~klampt.RobotModel`):
        """
        return _robotsim.WorldModel_makeRobot(self, name)


    def makeRigidObject(self, name):
        """
        Creates a new empty rigid object.  

        Args:
            name (str)
        Returns:
            (:class:`~klampt.RigidObjectModel`):
        """
        return _robotsim.WorldModel_makeRigidObject(self, name)


    def makeTerrain(self, name):
        """
        Creates a new empty terrain.  

        Args:
            name (str)
        Returns:
            (:obj:`TerrainModel`):
        """
        return _robotsim.WorldModel_makeTerrain(self, name)


    def loadRobot(self, fn):
        """
        Loads a robot from a .rob or .urdf file. An empty robot is returned if loading
        fails.  

        Args:
            fn (str)
        Returns:
            (:class:`~klampt.RobotModel`):
        """
        return _robotsim.WorldModel_loadRobot(self, fn)


    def loadRigidObject(self, fn):
        """
        Loads a rigid object from a .obj or a mesh file. An empty rigid object is
        returned if loading fails.  

        Args:
            fn (str)
        Returns:
            (:class:`~klampt.RigidObjectModel`):
        """
        return _robotsim.WorldModel_loadRigidObject(self, fn)


    def loadTerrain(self, fn):
        """
        Loads a rigid object from a mesh file. An empty terrain is returned if loading
        fails.  

        Args:
            fn (str)
        Returns:
            (:obj:`TerrainModel`):
        """
        return _robotsim.WorldModel_loadTerrain(self, fn)


    def loadElement(self, fn):
        """
        Loads some element from a file, automatically detecting its type. Meshes are
        interpreted as terrains. The ID is returned, or -1 if loading failed.  

        Args:
            fn (str)
        Returns:
            (int):
        """
        return _robotsim.WorldModel_loadElement(self, fn)


    def add(self, *args):
        """
        Adds a copy of the given robot, rigid object, or terrain to this world, either
        from this WorldModel or another.  

        add (name,robot): :class:`~klampt.RobotModel`

        add (name,obj): :class:`~klampt.RigidObjectModel`

        add (name,terrain): :obj:`TerrainModel`


        Args:
            name (str): 
            robot (:class:`~klampt.RobotModel`, optional): 
            obj (:class:`~klampt.RigidObjectModel`, optional): 
            terrain (:obj:`TerrainModel`, optional): 

        Returns:
            (:class:`~klampt.RobotModel` or :obj:`TerrainModel` or :class:`~klampt.RigidObjectModel`):
        """
        return _robotsim.WorldModel_add(self, *args)


    def remove(self, *args):
        """
        Removes a robot, rigid object, or terrain from the world. It must be in this
        world or an exception is raised.  

        remove (robot)

        remove (object)

        remove (terrain)


        Args:
            robot (:class:`~klampt.RobotModel`, optional): 
            object (:class:`~klampt.RigidObjectModel`, optional): 
            terrain (:obj:`TerrainModel`, optional): 

        IMPORTANT:  

            All other RobotModel, RigidObjectModel, and TerrainModel references will be
        invalidated.  

        """
        return _robotsim.WorldModel_remove(self, *args)


    def getName(self, id):
        """
        Retrieves the name for a given element ID.  

        Args:
            id (int)
        Returns:
            (str):
        """
        return _robotsim.WorldModel_getName(self, id)


    def geometry(self, id):
        """
        Retrieves a geometry for a given element ID.  

        Args:
            id (int)
        Returns:
            (:class:`~klampt.Geometry3D`):
        """
        return _robotsim.WorldModel_geometry(self, id)


    def appearance(self, id):
        """
        Retrieves an appearance for a given element ID.  

        Args:
            id (int)
        Returns:
            (:class:`~klampt.Appearance`):
        """
        return _robotsim.WorldModel_appearance(self, id)


    def drawGL(self):
        """
        Draws the entire world using OpenGL.  

        """
        return _robotsim.WorldModel_drawGL(self)


    def enableGeometryLoading(self, enabled):
        """
        If geometry loading is set to false, then only the kinematics are loaded from
        disk, and no geometry / visualization / collision detection structures will be
        loaded. Useful for quick scripts that just use kinematics / dynamics of a robot.  

        Args:
            enabled (bool)
        """
        return _robotsim.WorldModel_enableGeometryLoading(self, enabled)


    def enableInitCollisions(self, enabled):
        """
        If collision detection is set to true, then collision acceleration data
        structures will be automatically initialized, with debugging information. Useful
        for scripts that do planning and for which collision initialization may take a
        long time.  

        Args:
            enabled (bool)

        Note that even when this flag is off, the collision acceleration data structures
        will indeed be initialized the first time that geometry collision, distance, or
        ray-casting routines are called.  

        """
        return _robotsim.WorldModel_enableInitCollisions(self, enabled)

    __swig_setmethods__["index"] = _robotsim.WorldModel_index_set
    __swig_getmethods__["index"] = _robotsim.WorldModel_index_get
    if _newclass:
        index = _swig_property(_robotsim.WorldModel_index_get, _robotsim.WorldModel_index_set)
WorldModel_swigregister = _robotsim.WorldModel_swigregister
WorldModel_swigregister(WorldModel)

class IKObjective(_object):
    """


    A class defining an inverse kinematic target. Either a link on a robot can take
    on a fixed position/orientation in the world frame, or a relative
    position/orientation to another frame.  

    Currently only fixed-point constraints and fixed-transform constraints are
    implemented in the Python API.  

    C++ includes: robotik.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IKObjective, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IKObjective, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        With no arguments, constructs a blank IKObjective. Given an IKObjective, acts as
        a copy constructor.  

        __init__ (): :obj:`IKObjective`

        __init__ (arg2): :obj:`IKObjective`


        Args:
            arg2 (:obj:`IKObjective`, optional): 
        """
        this = _robotsim.new_IKObjective(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def copy(self):
        """
        Copy constructor.  

        Returns:
            (:obj:`IKObjective`):
        """
        return _robotsim.IKObjective_copy(self)


    def link(self):
        """
        The index of the robot link that is constrained.  

        Returns:
            (int):
        """
        return _robotsim.IKObjective_link(self)


    def destLink(self):
        """
        The index of the destination link, or -1 if fixed to the world.  

        Returns:
            (int):
        """
        return _robotsim.IKObjective_destLink(self)


    def numPosDims(self):
        """
        Returns the number of position dimensions constrained (0-3)  

        Returns:
            (int):
        """
        return _robotsim.IKObjective_numPosDims(self)


    def numRotDims(self):
        """
        Returns the number of rotation dimensions constrained (0-3)  

        Returns:
            (int):
        """
        return _robotsim.IKObjective_numRotDims(self)


    def setFixedPoint(self, link, plocal, pworld):
        """
        Sets a fixed-point constraint.  

        Args:
            link (int)
            plocal (:obj:`list of 3 floats`)
            pworld (:obj:`list of 3 floats`)
        """
        return _robotsim.IKObjective_setFixedPoint(self, link, plocal, pworld)


    def setFixedPoints(self, link, plocals, pworlds):
        """
        Sets a multiple fixed-point constraint.  

        Args:
            link (int)
            plocals (:obj:`object`)
            pworlds (:obj:`object`)
        """
        return _robotsim.IKObjective_setFixedPoints(self, link, plocals, pworlds)


    def setFixedTransform(self, link, R, t):
        """
        Sets a fixed-transform constraint (R,t)  

        Args:
            link (int)
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.IKObjective_setFixedTransform(self, link, R, t)


    def setRelativePoint(self, link1, link2, p1, p2):
        """
        Sets a fixed-point constraint relative to link2.  

        Args:
            link1 (int)
            link2 (int)
            p1 (:obj:`list of 3 floats`)
            p2 (:obj:`list of 3 floats`)
        """
        return _robotsim.IKObjective_setRelativePoint(self, link1, link2, p1, p2)


    def setRelativePoints(self, link1, link2, p1s, p2s):
        """
        Sets a multiple fixed-point constraint relative to link2.  

        Args:
            link1 (int)
            link2 (int)
            p1s (:obj:`object`)
            p2s (:obj:`object`)
        """
        return _robotsim.IKObjective_setRelativePoints(self, link1, link2, p1s, p2s)


    def setRelativeTransform(self, link, linkTgt, R, t):
        """
        Sets a fixed-transform constraint (R,t) relative to linkTgt.  

        Args:
            link (int)
            linkTgt (int)
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.IKObjective_setRelativeTransform(self, link, linkTgt, R, t)


    def setLinks(self, link, link2=-1):
        """
        Manual construction.  

        setLinks (link,link2=-1)

        setLinks (link)


        Args:
            link (int): 
            link2 (int, optional): default value -1
        """
        return _robotsim.IKObjective_setLinks(self, link, link2)


    def setFreePosition(self):
        """
        Manual: Sets a free position constraint.  

        """
        return _robotsim.IKObjective_setFreePosition(self)


    def setFixedPosConstraint(self, tlocal, tworld):
        """
        Manual: Sets a fixed position constraint.  

        Args:
            tlocal (:obj:`list of 3 floats`)
            tworld (:obj:`list of 3 floats`)
        """
        return _robotsim.IKObjective_setFixedPosConstraint(self, tlocal, tworld)


    def setPlanarPosConstraint(self, tlocal, nworld, oworld):
        """
        Manual: Sets a planar position constraint nworld^T T(link)*tlocal + oworld = 0.  

        Args:
            tlocal (:obj:`list of 3 floats`)
            nworld (:obj:`list of 3 floats`)
            oworld (float)
        """
        return _robotsim.IKObjective_setPlanarPosConstraint(self, tlocal, nworld, oworld)


    def setLinearPosConstraint(self, tlocal, sworld, dworld):
        """
        Manual: Sets a linear position constraint T(link)*tlocal = sworld + u*dworld for
        some real value u.  

        Args:
            tlocal (:obj:`list of 3 floats`)
            sworld (:obj:`list of 3 floats`)
            dworld (:obj:`list of 3 floats`)
        """
        return _robotsim.IKObjective_setLinearPosConstraint(self, tlocal, sworld, dworld)


    def setFreeRotConstraint(self):
        """
        Manual: Sets a free rotation constraint.  

        """
        return _robotsim.IKObjective_setFreeRotConstraint(self)


    def setFixedRotConstraint(self, R):
        """
        Manual: Sets a fixed rotation constraint.  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
        """
        return _robotsim.IKObjective_setFixedRotConstraint(self, R)


    def setAxialRotConstraint(self, alocal, aworld):
        """
        Manual: Sets an axial rotation constraint.  

        Args:
            alocal (:obj:`list of 3 floats`)
            aworld (:obj:`list of 3 floats`)
        """
        return _robotsim.IKObjective_setAxialRotConstraint(self, alocal, aworld)


    def getPosition(self):
        """
        Returns the local and global position of the position constraint.  

        """
        return _robotsim.IKObjective_getPosition(self)


    def getPositionDirection(self):
        """
        For linear and planar constraints, returns the direction.  

        """
        return _robotsim.IKObjective_getPositionDirection(self)


    def getRotation(self):
        """
        For fixed rotation constraints, returns the orientation.  

        """
        return _robotsim.IKObjective_getRotation(self)


    def getRotationAxis(self):
        """
        For axis rotation constraints, returns the local and global axes.  

        """
        return _robotsim.IKObjective_getRotationAxis(self)


    def getTransform(self):
        """
        For fixed-transform constraints, returns the transform (R,t)  

        """
        return _robotsim.IKObjective_getTransform(self)


    def transform(self, R, t):
        """
        Tranforms the target position/rotation of this IK constraint by transform (R,t)  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.IKObjective_transform(self, R, t)


    def transformLocal(self, R, t):
        """
        Tranforms the local position/rotation of this IK constraint by transform (R,t)  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.IKObjective_transformLocal(self, R, t)


    def matchDestination(self, R, t):
        """
        Sets the destination coordinates of this constraint to fit the given target
        transform. In other words, if (R,t) is the current link transform, this sets the
        destination position / orientation so that this objective has zero error. The
        current position/rotation constraint types are kept.  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.IKObjective_matchDestination(self, R, t)


    def loadString(self, str):
        """
        Loads the objective from a Klamp't-native formatted string. For a more readable
        but verbose format, try the JSON IO routines loader.toJson/fromJson()  

        Args:
            str (str)
        Returns:
            (bool):
        """
        return _robotsim.IKObjective_loadString(self, str)


    def saveString(self):
        """
        Saves the objective to a Klamp't-native formatted string. For a more readable
        but verbose format, try the JSON IO routines loader.toJson/fromJson()  

        Returns:
            (str):
        """
        return _robotsim.IKObjective_saveString(self)

    __swig_setmethods__["goal"] = _robotsim.IKObjective_goal_set
    __swig_getmethods__["goal"] = _robotsim.IKObjective_goal_get
    if _newclass:
        goal = _swig_property(_robotsim.IKObjective_goal_get, _robotsim.IKObjective_goal_set)
    __swig_destroy__ = _robotsim.delete_IKObjective
    __del__ = lambda self: None
IKObjective_swigregister = _robotsim.IKObjective_swigregister
IKObjective_swigregister(IKObjective)

class IKSolver(_object):
    """


    An inverse kinematics solver based on the Newton-Raphson technique.  

    Typical calling pattern is::  

        s = IKSolver(robot)
        s.add(objective1)
        s.add(objective2)
        s.setMaxIters(100)
        s.setTolerance(1e-4)
        res = s.solve()
        if res:
            print ("IK solution:",robot.getConfig(),"found in",
                s.lastSolveIters(),"iterations, residual",s.getResidual()
        else:
            print "IK failed:",robot.getConfig(),"found in",
                s.lastSolveIters(),"iterations, residual",s.getResidual()  

    C++ includes: robotik.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IKSolver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IKSolver, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Initializes an IK solver. Given a RobotModel, an empty solver is created. Given
        an IK solver, acts as a copy constructor.  

        __init__ (robot): :obj:`IKSolver`

        __init__ (solver): :obj:`IKSolver`


        Args:
            robot (:class:`~klampt.RobotModel`, optional): 
            solver (:obj:`IKSolver`, optional): 
        """
        this = _robotsim.new_IKSolver(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def copy(self):
        """
        Copy constructor.  

        Returns:
            (:obj:`IKSolver`):
        """
        return _robotsim.IKSolver_copy(self)


    def add(self, objective):
        """
        Adds a new simultaneous objective.  

        Args:
            objective (:obj:`IKObjective`)
        """
        return _robotsim.IKSolver_add(self, objective)


    def set(self, i, objective):
        """
        Assigns an existing objective added by add.  

        Args:
            i (int)
            objective (:obj:`IKObjective`)
        """
        return _robotsim.IKSolver_set(self, i, objective)


    def clear(self):
        """
        Clears objectives.  

        """
        return _robotsim.IKSolver_clear(self)


    def setMaxIters(self, iters):
        """
        Sets the max # of iterations (default 100)  

        Args:
            iters (int)
        """
        return _robotsim.IKSolver_setMaxIters(self, iters)


    def getMaxIters(self):
        """
        Gets the max # of iterations.  

        Returns:
            (int):
        """
        return _robotsim.IKSolver_getMaxIters(self)


    def setTolerance(self, res):
        """
        Sets the constraint solve tolerance (default 1e-3)  

        Args:
            res (float)
        """
        return _robotsim.IKSolver_setTolerance(self, res)


    def getTolerance(self):
        """
        Gets the constraint solve tolerance.  

        Returns:
            (float):
        """
        return _robotsim.IKSolver_getTolerance(self)


    def setActiveDofs(self, active):
        """
        Sets the active degrees of freedom.  

        Args:
            active (:obj:`list of int`)
        """
        return _robotsim.IKSolver_setActiveDofs(self, active)


    def getActiveDofs(self):
        """
        Gets the active degrees of freedom.  

        """
        return _robotsim.IKSolver_getActiveDofs(self)


    def setJointLimits(self, qmin, qmax):
        """
        Sets limits on the robot's configuration. If empty, this turns off joint limits.  

        Args:
            qmin (:obj:`list of floats`)
            qmax (:obj:`list of floats`)
        """
        return _robotsim.IKSolver_setJointLimits(self, qmin, qmax)


    def getJointLimits(self):
        """
        Gets the limits on the robot's configuration (by default this is the robot's
        joint limits.  

        """
        return _robotsim.IKSolver_getJointLimits(self)


    def setBiasConfig(self, biasConfig):
        """
        Biases the solver to approach a given configuration. Setting an empty vector
        clears the bias term.  

        Args:
            biasConfig (:obj:`list of floats`)
        """
        return _robotsim.IKSolver_setBiasConfig(self, biasConfig)


    def getBiasConfig(self):
        """
        Gets the solvers' bias configuration.  

        """
        return _robotsim.IKSolver_getBiasConfig(self)


    def isSolved(self):
        """
        Returns true if the current configuration residual is less than tol.  

        Returns:
            (bool):
        """
        return _robotsim.IKSolver_isSolved(self)


    def getResidual(self):
        """
        Returns a vector describing the error of the objective at the current
        configuration.  

        """
        return _robotsim.IKSolver_getResidual(self)


    def getJacobian(self):
        """
        Returns a matrix describing the instantaneous derivative of the objective with
        respect to the active Dofs.  

        """
        return _robotsim.IKSolver_getJacobian(self)


    def solve(self, *args):
        """
        Old-style: will be deprecated. Specify # of iterations and tolerance. Tries to
        find a configuration that satifies all simultaneous objectives up to the desired
        tolerance. Returns (res,iterations) where res is true if x converged.  

        solve (): bool

        solve (iters,tol): :obj:`object`


        Args:
            iters (int, optional): 
            tol (float, optional): 

        Returns:
            (:obj:`object` or bool):
        """
        return _robotsim.IKSolver_solve(self, *args)


    def lastSolveIters(self):
        """
        Returns the number of Newton-Raphson iterations used in the last solve() call.  

        Returns:
            (int):
        """
        return _robotsim.IKSolver_lastSolveIters(self)


    def sampleInitial(self):
        """
        Samples an initial random configuration. More initial configurations can be
        sampled in case the prior configs lead to local minima.  

        """
        return _robotsim.IKSolver_sampleInitial(self)

    __swig_setmethods__["robot"] = _robotsim.IKSolver_robot_set
    __swig_getmethods__["robot"] = _robotsim.IKSolver_robot_get
    if _newclass:
        robot = _swig_property(_robotsim.IKSolver_robot_get, _robotsim.IKSolver_robot_set)
    __swig_setmethods__["objectives"] = _robotsim.IKSolver_objectives_set
    __swig_getmethods__["objectives"] = _robotsim.IKSolver_objectives_get
    if _newclass:
        objectives = _swig_property(_robotsim.IKSolver_objectives_get, _robotsim.IKSolver_objectives_set)
    __swig_setmethods__["tol"] = _robotsim.IKSolver_tol_set
    __swig_getmethods__["tol"] = _robotsim.IKSolver_tol_get
    if _newclass:
        tol = _swig_property(_robotsim.IKSolver_tol_get, _robotsim.IKSolver_tol_set)
    __swig_setmethods__["maxIters"] = _robotsim.IKSolver_maxIters_set
    __swig_getmethods__["maxIters"] = _robotsim.IKSolver_maxIters_get
    if _newclass:
        maxIters = _swig_property(_robotsim.IKSolver_maxIters_get, _robotsim.IKSolver_maxIters_set)
    __swig_setmethods__["activeDofs"] = _robotsim.IKSolver_activeDofs_set
    __swig_getmethods__["activeDofs"] = _robotsim.IKSolver_activeDofs_get
    if _newclass:
        activeDofs = _swig_property(_robotsim.IKSolver_activeDofs_get, _robotsim.IKSolver_activeDofs_set)
    __swig_setmethods__["useJointLimits"] = _robotsim.IKSolver_useJointLimits_set
    __swig_getmethods__["useJointLimits"] = _robotsim.IKSolver_useJointLimits_get
    if _newclass:
        useJointLimits = _swig_property(_robotsim.IKSolver_useJointLimits_get, _robotsim.IKSolver_useJointLimits_set)
    __swig_setmethods__["qmin"] = _robotsim.IKSolver_qmin_set
    __swig_getmethods__["qmin"] = _robotsim.IKSolver_qmin_get
    if _newclass:
        qmin = _swig_property(_robotsim.IKSolver_qmin_get, _robotsim.IKSolver_qmin_set)
    __swig_setmethods__["qmax"] = _robotsim.IKSolver_qmax_set
    __swig_getmethods__["qmax"] = _robotsim.IKSolver_qmax_get
    if _newclass:
        qmax = _swig_property(_robotsim.IKSolver_qmax_get, _robotsim.IKSolver_qmax_set)
    __swig_setmethods__["biasConfig"] = _robotsim.IKSolver_biasConfig_set
    __swig_getmethods__["biasConfig"] = _robotsim.IKSolver_biasConfig_get
    if _newclass:
        biasConfig = _swig_property(_robotsim.IKSolver_biasConfig_get, _robotsim.IKSolver_biasConfig_set)
    __swig_setmethods__["lastIters"] = _robotsim.IKSolver_lastIters_set
    __swig_getmethods__["lastIters"] = _robotsim.IKSolver_lastIters_get
    if _newclass:
        lastIters = _swig_property(_robotsim.IKSolver_lastIters_get, _robotsim.IKSolver_lastIters_set)
    __swig_destroy__ = _robotsim.delete_IKSolver
    __del__ = lambda self: None
IKSolver_swigregister = _robotsim.IKSolver_swigregister
IKSolver_swigregister(IKSolver)

class GeneralizedIKObjective(_object):
    """


    An inverse kinematics target for matching points between two robots and/or
    objects.  

    The objects are chosen upon construction, so the following are valid:  

    *   GeneralizedIKObjective(a) is an objective for object a to be constrained
        relative to the environment.  
    *   GeneralizedIKObjective(a,b) is an objective for object a to be constrained
        relative to b. Here a and b can be links on any robot or rigid objects.  

    Once constructed, call setPoint, setPoints, or setTransform to specify the
    nature of the constraint.  

    C++ includes: robotik.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeneralizedIKObjective, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GeneralizedIKObjective, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__ (obj): :obj:`GeneralizedIKObjective`

        __init__ (link): :obj:`GeneralizedIKObjective`

        __init__ (link,link2): :obj:`GeneralizedIKObjective`

        __init__ (link,obj2): :obj:`GeneralizedIKObjective`

        __init__ (obj,link2): :obj:`GeneralizedIKObjective`

        __init__ (obj,obj2): :obj:`GeneralizedIKObjective`


        Args:
            obj (:obj:`GeneralizedIKObjective` or :class:`~klampt.RigidObjectModel`, optional): 
            link (:class:`~klampt.RobotModelLink`, optional): 
            link2 (:class:`~klampt.RobotModelLink`, optional): 
            obj2 (:class:`~klampt.RigidObjectModel`, optional): 
        """
        this = _robotsim.new_GeneralizedIKObjective(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def setPoint(self, p1, p2):
        """
        Args:
            p1 (:obj:`list of 3 floats`)
            p2 (:obj:`list of 3 floats`)
        """
        return _robotsim.GeneralizedIKObjective_setPoint(self, p1, p2)


    def setPoints(self, p1s, p2s):
        """
        Args:
            p1s (:obj:`object`)
            p2s (:obj:`object`)
        """
        return _robotsim.GeneralizedIKObjective_setPoints(self, p1s, p2s)


    def setTransform(self, R, t):
        """
        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.GeneralizedIKObjective_setTransform(self, R, t)

    __swig_setmethods__["link1"] = _robotsim.GeneralizedIKObjective_link1_set
    __swig_getmethods__["link1"] = _robotsim.GeneralizedIKObjective_link1_get
    if _newclass:
        link1 = _swig_property(_robotsim.GeneralizedIKObjective_link1_get, _robotsim.GeneralizedIKObjective_link1_set)
    __swig_setmethods__["link2"] = _robotsim.GeneralizedIKObjective_link2_set
    __swig_getmethods__["link2"] = _robotsim.GeneralizedIKObjective_link2_get
    if _newclass:
        link2 = _swig_property(_robotsim.GeneralizedIKObjective_link2_get, _robotsim.GeneralizedIKObjective_link2_set)
    __swig_setmethods__["obj1"] = _robotsim.GeneralizedIKObjective_obj1_set
    __swig_getmethods__["obj1"] = _robotsim.GeneralizedIKObjective_obj1_get
    if _newclass:
        obj1 = _swig_property(_robotsim.GeneralizedIKObjective_obj1_get, _robotsim.GeneralizedIKObjective_obj1_set)
    __swig_setmethods__["obj2"] = _robotsim.GeneralizedIKObjective_obj2_set
    __swig_getmethods__["obj2"] = _robotsim.GeneralizedIKObjective_obj2_get
    if _newclass:
        obj2 = _swig_property(_robotsim.GeneralizedIKObjective_obj2_get, _robotsim.GeneralizedIKObjective_obj2_set)
    __swig_setmethods__["isObj1"] = _robotsim.GeneralizedIKObjective_isObj1_set
    __swig_getmethods__["isObj1"] = _robotsim.GeneralizedIKObjective_isObj1_get
    if _newclass:
        isObj1 = _swig_property(_robotsim.GeneralizedIKObjective_isObj1_get, _robotsim.GeneralizedIKObjective_isObj1_set)
    __swig_setmethods__["isObj2"] = _robotsim.GeneralizedIKObjective_isObj2_set
    __swig_getmethods__["isObj2"] = _robotsim.GeneralizedIKObjective_isObj2_get
    if _newclass:
        isObj2 = _swig_property(_robotsim.GeneralizedIKObjective_isObj2_get, _robotsim.GeneralizedIKObjective_isObj2_set)
    __swig_setmethods__["goal"] = _robotsim.GeneralizedIKObjective_goal_set
    __swig_getmethods__["goal"] = _robotsim.GeneralizedIKObjective_goal_get
    if _newclass:
        goal = _swig_property(_robotsim.GeneralizedIKObjective_goal_get, _robotsim.GeneralizedIKObjective_goal_set)
    __swig_destroy__ = _robotsim.delete_GeneralizedIKObjective
    __del__ = lambda self: None
GeneralizedIKObjective_swigregister = _robotsim.GeneralizedIKObjective_swigregister
GeneralizedIKObjective_swigregister(GeneralizedIKObjective)

class GeneralizedIKSolver(_object):
    """


    An inverse kinematics solver between multiple robots and/or objects. NOT
    IMPLEMENTED YET.  

    C++ includes: robotik.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeneralizedIKSolver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GeneralizedIKSolver, name)
    __repr__ = _swig_repr

    def __init__(self, world):
        """
        Args:
            world (:class:`~klampt.WorldModel`)
        """
        this = _robotsim.new_GeneralizedIKSolver(world)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add(self, objective):
        """
        Adds a new simultaneous objective.  

        Args:
            objective (:obj:`GeneralizedIKObjective`)
        """
        return _robotsim.GeneralizedIKSolver_add(self, objective)


    def setMaxIters(self, iters):
        """
        Sets the max # of iterations (default 100)  

        Args:
            iters (int)
        """
        return _robotsim.GeneralizedIKSolver_setMaxIters(self, iters)


    def setTolerance(self, res):
        """
        Sets the constraint solve tolerance (default 1e-3)  

        Args:
            res (float)
        """
        return _robotsim.GeneralizedIKSolver_setTolerance(self, res)


    def getResidual(self):
        """
        Returns a vector describing the error of the objective.  

        """
        return _robotsim.GeneralizedIKSolver_getResidual(self)


    def getJacobian(self):
        """
        Returns a matrix describing the instantaneous derivative of the objective with
        respect to the active parameters.  

        """
        return _robotsim.GeneralizedIKSolver_getJacobian(self)


    def solve(self):
        """
        Tries to find a configuration that satifies all simultaneous objectives up to
        the desired tolerance.  


        Returns: res,iters (pair of bool, int): res indicates whether x converged, and
        iters is the number of iterations used.  

        """
        return _robotsim.GeneralizedIKSolver_solve(self)


    def sampleInitial(self):
        """
        Samples an initial random configuration.  

        """
        return _robotsim.GeneralizedIKSolver_sampleInitial(self)

    __swig_setmethods__["world"] = _robotsim.GeneralizedIKSolver_world_set
    __swig_getmethods__["world"] = _robotsim.GeneralizedIKSolver_world_get
    if _newclass:
        world = _swig_property(_robotsim.GeneralizedIKSolver_world_get, _robotsim.GeneralizedIKSolver_world_set)
    __swig_setmethods__["objectives"] = _robotsim.GeneralizedIKSolver_objectives_set
    __swig_getmethods__["objectives"] = _robotsim.GeneralizedIKSolver_objectives_get
    if _newclass:
        objectives = _swig_property(_robotsim.GeneralizedIKSolver_objectives_get, _robotsim.GeneralizedIKSolver_objectives_set)
    __swig_setmethods__["tol"] = _robotsim.GeneralizedIKSolver_tol_set
    __swig_getmethods__["tol"] = _robotsim.GeneralizedIKSolver_tol_get
    if _newclass:
        tol = _swig_property(_robotsim.GeneralizedIKSolver_tol_get, _robotsim.GeneralizedIKSolver_tol_set)
    __swig_setmethods__["maxIters"] = _robotsim.GeneralizedIKSolver_maxIters_set
    __swig_getmethods__["maxIters"] = _robotsim.GeneralizedIKSolver_maxIters_get
    if _newclass:
        maxIters = _swig_property(_robotsim.GeneralizedIKSolver_maxIters_get, _robotsim.GeneralizedIKSolver_maxIters_set)
    __swig_setmethods__["useJointLimits"] = _robotsim.GeneralizedIKSolver_useJointLimits_set
    __swig_getmethods__["useJointLimits"] = _robotsim.GeneralizedIKSolver_useJointLimits_get
    if _newclass:
        useJointLimits = _swig_property(_robotsim.GeneralizedIKSolver_useJointLimits_get, _robotsim.GeneralizedIKSolver_useJointLimits_set)
    __swig_destroy__ = _robotsim.delete_GeneralizedIKSolver
    __del__ = lambda self: None
GeneralizedIKSolver_swigregister = _robotsim.GeneralizedIKSolver_swigregister
GeneralizedIKSolver_swigregister(GeneralizedIKSolver)


def SampleTransform(*args):
    """
    Returns a transformation (R,t) from link relative to link2, sampled at random
    from the space of transforms that satisfies the objective obj.  

    SampleTransform (obj)


    Args:
        obj (:obj:`IKObjective` or :obj:`GeneralizedIKObjective`): 
    """
    return _robotsim.SampleTransform(*args)
class SimRobotSensor(_object):
    """


    A sensor on a simulated robot. Retrieve one from the controller using
    :meth:`SimRobotController.getSensor` (), or create a new one using
    SimRobotSensor(robotController,name,type)  

    Use :meth:`getMeasurements` () to get the currently simulated measurement
    vector.  

    Sensors are automatically updated through the :meth:`Simulator.simulate` ()
    call, and :meth:`getMeasurements` () retrieves the updated values. As a result,
    you may get garbage measurements before the first Simulator.simulate call is
    made.  

    There is also a mode for doing kinematic simulation, which is supported (i.e.,
    makes sensible measurements) for some types of sensors when just a robot / world
    model is given. This is similar to Simulation.fakeSimulate but the entire
    controller structure is bypassed. You can arbitrarily set the robot's position,
    call :meth:`kinematicReset` (), and then call :meth:`kinematicSimulate` ().
    Subsequent calls assume the robot is being driven along a trajectory until the
    next :meth:`kinematicReset` () is called.  

    LaserSensor, CameraSensor, TiltSensor, AccelerometerSensor, GyroSensor,
    JointPositionSensor, JointVelocitySensor support kinematic simulation mode.
    FilteredSensor and TimeDelayedSensor also work. The force-related sensors
    (ContactSensor and ForceTorqueSensor) return 0's in kinematic simulation.  

    To use get/setSetting, you will need to know the sensor attribute names and
    types as described in `the Klampt sensor documentation
    <https://github.com/krishauser/Klampt/blob/master/Documentation/Manual-
    Control.md#sensors>`_ (same as in the world or sensor XML file).  

    C++ includes: robotsim.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimRobotSensor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SimRobotSensor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__ (robot,sensor): :class:`~klampt.SimRobotSensor`

        __init__ (robot,name,type): :class:`~klampt.SimRobotSensor`


        Args:
            robot (:class:`~klampt.SimRobotController` or :obj:`Robot`): 
            sensor (:obj:`SensorBase`, optional): 
            name (str, optional): 
            type (str, optional): 
        """
        this = _robotsim.new_SimRobotSensor(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def name(self):
        """
        Returns the name of the sensor.  

        Returns:
            (str):
        """
        return _robotsim.SimRobotSensor_name(self)


    def type(self):
        """
        Returns the type of the sensor.  

        Returns:
            (str):
        """
        return _robotsim.SimRobotSensor_type(self)


    def measurementNames(self):
        """
        Returns a list of names for the measurements (one per measurement).  

        Returns:
            (:obj:`stringVector`):
        """
        return _robotsim.SimRobotSensor_measurementNames(self)


    def getMeasurements(self):
        """
        Returns a list of measurements from the previous simulation (or
        kinematicSimulate) timestep.  

        """
        return _robotsim.SimRobotSensor_getMeasurements(self)


    def getSetting(self, name):
        """
        Returns the value of the named setting (you will need to manually parse this)  

        Args:
            name (str)
        Returns:
            (str):
        """
        return _robotsim.SimRobotSensor_getSetting(self, name)


    def setSetting(self, name, val):
        """
        Sets the value of the named setting (you will need to manually cast an
        int/float/etc to a str)  

        Args:
            name (str)
            val (str)
        """
        return _robotsim.SimRobotSensor_setSetting(self, name, val)


    def drawGL(self, *args):
        """
        Draws a sensor indicator using OpenGL. If measurements are given, the indicator
        is drawn as though these are the latest measurements, otherwise the last
        measurements are given.  

        drawGL ()

        drawGL (measurements)


        Args:
            measurements (:obj:`list of floats`, optional): 
        """
        return _robotsim.SimRobotSensor_drawGL(self, *args)


    def kinematicSimulate(self, world, dt):
        """
        simulates / advances the kinematic simulation  

        Args:
            world (:class:`~klampt.WorldModel`)
            dt (float)
        """
        return _robotsim.SimRobotSensor_kinematicSimulate(self, world, dt)


    def kinematicReset(self):
        """
        resets a kinematic simulation so that a new initial condition can be set  

        """
        return _robotsim.SimRobotSensor_kinematicReset(self)

    __swig_setmethods__["robot"] = _robotsim.SimRobotSensor_robot_set
    __swig_getmethods__["robot"] = _robotsim.SimRobotSensor_robot_get
    if _newclass:
        robot = _swig_property(_robotsim.SimRobotSensor_robot_get, _robotsim.SimRobotSensor_robot_set)
    __swig_setmethods__["sensor"] = _robotsim.SimRobotSensor_sensor_set
    __swig_getmethods__["sensor"] = _robotsim.SimRobotSensor_sensor_get
    if _newclass:
        sensor = _swig_property(_robotsim.SimRobotSensor_sensor_get, _robotsim.SimRobotSensor_sensor_set)
    __swig_destroy__ = _robotsim.delete_SimRobotSensor
    __del__ = lambda self: None
SimRobotSensor_swigregister = _robotsim.SimRobotSensor_swigregister
SimRobotSensor_swigregister(SimRobotSensor)

class SimRobotController(_object):
    """


    A controller for a simulated robot.  

    By default a SimRobotController has three possible modes:  

    *   Motion queue + PID mode: the controller has an internal trajectory queue
        that may be added to and modified. This queue supports piecewise linear
        interpolation, cubic interpolation, and time-optimal move-to commands.  
    *   PID mode: the user controls the motor's PID setpoints directly  
    *   Torque control: the user controlls the motor torques directly.  

    The "standard" way of using this is in move-to mode which accepts a milestone
    (setMilestone) or list of milestones (repeated calls to addMilestone) and
    interpolates dynamically from the current configuration/velocity. To handle
    disturbances, a PID loop is run automatically at the controller's specified
    rate.  

    To get finer-grained control over the motion queue's timing, you may use the
    setLinear/setCubic/addLinear/addCubic functions. In these functions it is up to
    the user to respect velocity, acceleration, and torque limits.  

    Whether in motion queue or PID mode, the constants of the PID loop are initially
    set in the robot file. You can programmatically tune these via the setPIDGains
    function.  

    Arbitrary trajectories can be tracked by using setVelocity over short time
    steps. Force controllers can be implemented using setTorque, again using short
    time steps.  

    If setVelocity, setTorque, or setPID command are called, the motion queue
    behavior will be completely overridden. To reset back to motion queue control,
    the function setManualMode(False) must be called.  

    C++ includes: robotsim.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimRobotController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SimRobotController, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        """
        this = _robotsim.new_SimRobotController()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_SimRobotController
    __del__ = lambda self: None

    def model(self):
        """
        Retrieves the robot model associated with this controller.  

        Returns:
            (:class:`~klampt.RobotModel`):
        """
        return _robotsim.SimRobotController_model(self)


    def setRate(self, dt):
        """
        Sets the current feedback control rate.  

        Args:
            dt (float)
        """
        return _robotsim.SimRobotController_setRate(self, dt)


    def getRate(self):
        """
        Gets the current feedback control rate.  

        Returns:
            (float):
        """
        return _robotsim.SimRobotController_getRate(self)


    def getCommandedConfig(self):
        """
        Returns the current commanded configuration.  

        """
        return _robotsim.SimRobotController_getCommandedConfig(self)


    def getCommandedVelocity(self):
        """
        Returns the current commanded velocity.  

        """
        return _robotsim.SimRobotController_getCommandedVelocity(self)


    def getCommandedTorque(self):
        """
        Returns the current commanded (feedforward) torque.  

        """
        return _robotsim.SimRobotController_getCommandedTorque(self)


    def getSensedConfig(self):
        """
        Returns the current "sensed" configuration from the simulator.  

        """
        return _robotsim.SimRobotController_getSensedConfig(self)


    def getSensedVelocity(self):
        """
        Returns the current "sensed" velocity from the simulator.  

        """
        return _robotsim.SimRobotController_getSensedVelocity(self)


    def getSensedTorque(self):
        """
        Returns the current "sensed" (feedback) torque from the simulator. Note: a
        default robot doesn't have a torque sensor, so this will be 0.  

        """
        return _robotsim.SimRobotController_getSensedTorque(self)


    def sensor(self, *args):
        """
        Returns a sensor by index or by name. If out of bounds or unavailable, a null
        sensor is returned.  

        sensor (index): :class:`~klampt.SimRobotSensor`

        sensor (name): :class:`~klampt.SimRobotSensor`


        Args:
            index (int, optional): 
            name (str, optional): 

        Returns:
            (:class:`~klampt.SimRobotSensor`):
        """
        return _robotsim.SimRobotController_sensor(self, *args)


    def commands(self):
        """
        gets a command list  

        Returns:
            (:obj:`stringVector`):
        """
        return _robotsim.SimRobotController_commands(self)


    def sendCommand(self, name, args):
        """
        sends a command to the controller  

        Args:
            name (str)
            args (str)
        Returns:
            (bool):
        """
        return _robotsim.SimRobotController_sendCommand(self, name, args)


    def getSetting(self, name):
        """
        gets a setting of the controller  

        Args:
            name (str)
        Returns:
            (str):
        """
        return _robotsim.SimRobotController_getSetting(self, name)


    def setSetting(self, name, val):
        """
        sets a setting of the controller  

        Args:
            name (str)
            val (str)
        Returns:
            (bool):
        """
        return _robotsim.SimRobotController_setSetting(self, name, val)


    def setMilestone(self, *args):
        """
        Uses a dynamic interpolant to get from the current state to the desired
        milestone (with optional ending velocity). This interpolant is time-optimal with
        respect to the velocity and acceleration bounds.  

        setMilestone (q)

        setMilestone (q,dq)


        Args:
            q (:obj:`list of floats`): 
            dq (:obj:`list of floats`, optional): 
        """
        return _robotsim.SimRobotController_setMilestone(self, *args)


    def addMilestone(self, *args):
        """
        Same as setMilestone, but appends an interpolant onto an internal motion queue
        starting at the current queued end state.  

        addMilestone (q)

        addMilestone (q,dq)


        Args:
            q (:obj:`list of floats`): 
            dq (:obj:`list of floats`, optional): 
        """
        return _robotsim.SimRobotController_addMilestone(self, *args)


    def addMilestoneLinear(self, q):
        """
        Same as addMilestone, but enforces that the motion should move along a straight-
        line joint-space path.  

        Args:
            q (:obj:`list of floats`)
        """
        return _robotsim.SimRobotController_addMilestoneLinear(self, q)


    def setLinear(self, q, dt):
        """
        Uses linear interpolation to get from the current configuration to the desired
        configuration after time dt.  

        Args:
            q (:obj:`list of floats`)
            dt (float)
        """
        return _robotsim.SimRobotController_setLinear(self, q, dt)


    def setCubic(self, q, v, dt):
        """
        Uses cubic (Hermite) interpolation to get from the current
        configuration/velocity to the desired configuration/velocity after time dt.  

        Args:
            q (:obj:`list of floats`)
            v (:obj:`list of floats`)
            dt (float)
        """
        return _robotsim.SimRobotController_setCubic(self, q, v, dt)


    def addLinear(self, q, dt):
        """
        Same as setLinear but appends an interpolant onto the motion queue.  

        Args:
            q (:obj:`list of floats`)
            dt (float)
        """
        return _robotsim.SimRobotController_addLinear(self, q, dt)


    def addCubic(self, q, v, dt):
        """
        Same as setCubic but appends an interpolant onto the motion queue.  

        Args:
            q (:obj:`list of floats`)
            v (:obj:`list of floats`)
            dt (float)
        """
        return _robotsim.SimRobotController_addCubic(self, q, v, dt)


    def remainingTime(self):
        """
        Returns the remaining duration of the motion queue.  

        Returns:
            (float):
        """
        return _robotsim.SimRobotController_remainingTime(self)


    def setVelocity(self, dq, dt):
        """
        Sets a rate controller from the current commanded config to move at rate dq for
        time dt.  

        Args:
            dq (:obj:`list of floats`)
            dt (float)
        """
        return _robotsim.SimRobotController_setVelocity(self, dq, dt)


    def setTorque(self, t):
        """
        Sets a torque command controller.  

        Args:
            t (:obj:`list of floats`)
        """
        return _robotsim.SimRobotController_setTorque(self, t)


    def setPIDCommand(self, *args):
        """
        Sets a PID command controller. If tfeedforward is provided, it is the
        feedforward torque vector.  

        setPIDCommand (qdes,dqdes)

        setPIDCommand (qdes,dqdes,tfeedforward)


        Args:
            qdes (:obj:`list of floats`): 
            dqdes (:obj:`list of floats`): 
            tfeedforward (:obj:`list of floats`, optional): 
        """
        return _robotsim.SimRobotController_setPIDCommand(self, *args)


    def setManualMode(self, enabled):
        """
        Turns on/off manual mode, if either the setTorque or setPID command were
        previously set.  

        Args:
            enabled (bool)
        """
        return _robotsim.SimRobotController_setManualMode(self, enabled)


    def getControlType(self):
        """
        Returns the control type for the active controller.  

        Returns:
            (str):

        Possible return values are:  

        *   unknown  
        *   off  
        *   torque  
        *   PID  
        *   locked_velocity  

        """
        return _robotsim.SimRobotController_getControlType(self)


    def setPIDGains(self, kP, kI, kD):
        """
        Sets the PID gains.  

        Args:
            kP (:obj:`list of floats`)
            kI (:obj:`list of floats`)
            kD (:obj:`list of floats`)
        """
        return _robotsim.SimRobotController_setPIDGains(self, kP, kI, kD)


    def getPIDGains(self):
        """
        Gets the PID gains for the PID controller.  

        """
        return _robotsim.SimRobotController_getPIDGains(self)

    __swig_setmethods__["index"] = _robotsim.SimRobotController_index_set
    __swig_getmethods__["index"] = _robotsim.SimRobotController_index_get
    if _newclass:
        index = _swig_property(_robotsim.SimRobotController_index_get, _robotsim.SimRobotController_index_set)
    __swig_setmethods__["sim"] = _robotsim.SimRobotController_sim_set
    __swig_getmethods__["sim"] = _robotsim.SimRobotController_sim_get
    if _newclass:
        sim = _swig_property(_robotsim.SimRobotController_sim_get, _robotsim.SimRobotController_sim_set)
    __swig_setmethods__["controller"] = _robotsim.SimRobotController_controller_set
    __swig_getmethods__["controller"] = _robotsim.SimRobotController_controller_get
    if _newclass:
        controller = _swig_property(_robotsim.SimRobotController_controller_get, _robotsim.SimRobotController_controller_set)
SimRobotController_swigregister = _robotsim.SimRobotController_swigregister
SimRobotController_swigregister(SimRobotController)

class SimBody(_object):
    """


    A reference to a rigid body inside a Simulator (either a RigidObjectModel,
    TerrainModel, or a link of a RobotModel).  

    Can use this class to directly apply forces to or control positions / velocities
    of objects in the simulation.  

    Note: All changes are applied in the current simulation substep, not the
    duration provided to Simulation.simulate(). If you need fine-grained control,
    make sure to call Simulation.simulate() with time steps equal to the value
    provided to Simulation.setSimStep() (this is 0.001s by default).  

    Note: The transform of the object is centered at the *object's center of mass*
    rather than the reference frame given in the RobotModelLink or RigidObjectModel.  

    C++ includes: robotsim.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimBody, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SimBody, name)
    __repr__ = _swig_repr

    def getID(self):
        """
        Returns the object ID that this body associated with.  

        Returns:
            (int):
        """
        return _robotsim.SimBody_getID(self)


    def enable(self, enabled=True):
        """
        Sets the simulation of this body on/off.  

        enable (enabled=True)

        enable ()


        Args:
            enabled (bool, optional): default value True
        """
        return _robotsim.SimBody_enable(self, enabled)


    def isEnabled(self):
        """
        Returns true if this body is being simulated.  

        Returns:
            (bool):
        """
        return _robotsim.SimBody_isEnabled(self)


    def enableDynamics(self, enabled=True):
        """
        Sets the dynamic simulation of the body on/off. If false, velocities will simply
        be integrated forward, and forces will not affect velocity i.e., it will be pure
        kinematic simulation.  

        enableDynamics (enabled=True)

        enableDynamics ()


        Args:
            enabled (bool, optional): default value True
        """
        return _robotsim.SimBody_enableDynamics(self, enabled)


    def isDynamicsEnabled(self):
        """
        Returns:
            (bool):
        """
        return _robotsim.SimBody_isDynamicsEnabled(self)


    def applyWrench(self, f, t):
        """
        Applies a force and torque about the COM over the duration of the next
        Simulator.simulate(t) call.  

        Args:
            f (:obj:`list of 3 floats`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.SimBody_applyWrench(self, f, t)


    def applyForceAtPoint(self, f, pworld):
        """
        Applies a force at a given point (in world coordinates) over the duration of the
        next Simulator.simulate(t) call.  

        Args:
            f (:obj:`list of 3 floats`)
            pworld (:obj:`list of 3 floats`)
        """
        return _robotsim.SimBody_applyForceAtPoint(self, f, pworld)


    def applyForceAtLocalPoint(self, f, plocal):
        """
        Applies a force at a given point (in local center-of-mass-centered coordinates)
        over the duration of the next Simulator.simulate(t) call.  

        Args:
            f (:obj:`list of 3 floats`)
            plocal (:obj:`list of 3 floats`)
        """
        return _robotsim.SimBody_applyForceAtLocalPoint(self, f, plocal)


    def setTransform(self, R, t):
        """
        Sets the body's transformation at the current simulation time step (in center-
        of-mass centered coordinates).  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.SimBody_setTransform(self, R, t)


    def getTransform(self):
        """
        Gets the body's transformation at the current simulation time step (in center-
        of-mass centered coordinates).  

        """
        return _robotsim.SimBody_getTransform(self)


    def setObjectTransform(self, R, t):
        """
        Sets the body's transformation at the current simulation time step (in object-
        native coordinates)  

        Args:
            R (:obj:`list of 9 floats (so3 element)`)
            t (:obj:`list of 3 floats`)
        """
        return _robotsim.SimBody_setObjectTransform(self, R, t)


    def getObjectTransform(self):
        """
        Gets the body's transformation at the current simulation time step (in object-
        native coordinates).  

        """
        return _robotsim.SimBody_getObjectTransform(self)


    def setVelocity(self, w, v):
        """
        Sets the angular velocity and translational velocity at the current simulation
        time step.  

        Args:
            w (:obj:`list of 3 floats`)
            v (:obj:`list of 3 floats`)
        """
        return _robotsim.SimBody_setVelocity(self, w, v)


    def getVelocity(self):
        """
        Returns the angular velocity and translational velocity.  

        """
        return _robotsim.SimBody_getVelocity(self)


    def setCollisionPadding(self, padding):
        """
        Sets the collision padding used for contact generation. At 0 padding the
        simulation will be unstable for triangle mesh and point cloud geometries. A
        larger value is useful to maintain simulation stability for thin or soft
        objects. Default is 0.0025.  

        Args:
            padding (float)
        """
        return _robotsim.SimBody_setCollisionPadding(self, padding)


    def getCollisionPadding(self):
        """
        Returns:
            (float):
        """
        return _robotsim.SimBody_getCollisionPadding(self)


    def setCollisionPreshrink(self, shrinkVisualization=False):
        """
        If set, preshrinks the geometry so that the padded geometry better matches the
        original mesh. If shrinkVisualization=true, the underlying mesh is also shrunk
        (helps debug simulation artifacts due to preshrink)  

        setCollisionPreshrink (shrinkVisualization=False)

        setCollisionPreshrink ()


        Args:
            shrinkVisualization (bool, optional): default value False
        """
        return _robotsim.SimBody_setCollisionPreshrink(self, shrinkVisualization)


    def getSurface(self):
        """
        Gets (a copy of) the surface properties.  

        Returns:
            (:class:`~klampt.ContactParameters`):
        """
        return _robotsim.SimBody_getSurface(self)


    def setSurface(self, params):
        """
        Sets the surface properties.  

        Args:
            params (:class:`~klampt.ContactParameters`)
        """
        return _robotsim.SimBody_setSurface(self, params)

    __swig_setmethods__["sim"] = _robotsim.SimBody_sim_set
    __swig_getmethods__["sim"] = _robotsim.SimBody_sim_get
    if _newclass:
        sim = _swig_property(_robotsim.SimBody_sim_get, _robotsim.SimBody_sim_set)
    __swig_setmethods__["objectID"] = _robotsim.SimBody_objectID_set
    __swig_getmethods__["objectID"] = _robotsim.SimBody_objectID_get
    if _newclass:
        objectID = _swig_property(_robotsim.SimBody_objectID_get, _robotsim.SimBody_objectID_set)
    __swig_setmethods__["geometry"] = _robotsim.SimBody_geometry_set
    __swig_getmethods__["geometry"] = _robotsim.SimBody_geometry_get
    if _newclass:
        geometry = _swig_property(_robotsim.SimBody_geometry_get, _robotsim.SimBody_geometry_set)
    __swig_setmethods__["body"] = _robotsim.SimBody_body_set
    __swig_getmethods__["body"] = _robotsim.SimBody_body_get
    if _newclass:
        body = _swig_property(_robotsim.SimBody_body_get, _robotsim.SimBody_body_set)

    def __init__(self):
        """
        A reference to a rigid body inside a Simulator (either a RigidObjectModel,
        TerrainModel, or a link of a RobotModel).  


        Can use this class to directly apply forces to or control positions / velocities
        of objects in the simulation.  

        Note: All changes are applied in the current simulation substep, not the
        duration provided to Simulation.simulate(). If you need fine-grained control,
        make sure to call Simulation.simulate() with time steps equal to the value
        provided to Simulation.setSimStep() (this is 0.001s by default).  

        Note: The transform of the object is centered at the *object's center of mass*
        rather than the reference frame given in the RobotModelLink or RigidObjectModel.  

        C++ includes: robotsim.h

        """
        this = _robotsim.new_SimBody()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_SimBody
    __del__ = lambda self: None
SimBody_swigregister = _robotsim.SimBody_swigregister
SimBody_swigregister(SimBody)

class Simulator(_object):
    """


    A dynamics simulator for a WorldModel.  

    C++ includes: robotsim.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Simulator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Simulator, name)
    __repr__ = _swig_repr
    STATUS_NORMAL = _robotsim.Simulator_STATUS_NORMAL
    STATUS_ADAPTIVE_TIME_STEPPING = _robotsim.Simulator_STATUS_ADAPTIVE_TIME_STEPPING
    STATUS_CONTACT_UNRELIABLE = _robotsim.Simulator_STATUS_CONTACT_UNRELIABLE
    STATUS_UNSTABLE = _robotsim.Simulator_STATUS_UNSTABLE
    STATUS_ERROR = _robotsim.Simulator_STATUS_ERROR

    def __init__(self, model):
        """
        Constructs the simulator from a WorldModel. If the WorldModel was loaded from an
        XML file, then the simulation setup is loaded from it.  

        Args:
            model (:class:`~klampt.WorldModel`)
        """
        this = _robotsim.new_Simulator(model)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _robotsim.delete_Simulator
    __del__ = lambda self: None

    def reset(self):
        """
        Resets to the initial state (same as setState(initialState))  

        """
        return _robotsim.Simulator_reset(self)


    def getStatus(self):
        """
        Returns an indicator code for the simulator status. The return result is one of
        the STATUS_X flags. (Technically, this returns the *worst* status over the last
        simulate() call)  

        Returns:
            (int):
        """
        return _robotsim.Simulator_getStatus(self)


    def getStatusString(self, s=-1):
        """
        Returns a string indicating the simulator's status. If s is provided and >= 0,
        this function maps the indicator code s to a string.  

        getStatusString (s=-1): str

        getStatusString (): str


        Args:
            s (int, optional): default value -1

        Returns:
            (str):
        """
        return _robotsim.Simulator_getStatusString(self, s)


    def checkObjectOverlap(self):
        """
        Checks if any objects are overlapping. Returns a pair of lists of integers,
        giving the pairs of object ids that are overlapping.  

        """
        return _robotsim.Simulator_checkObjectOverlap(self)


    def getState(self):
        """
        Returns a Base64 string representing the binary data for the current simulation
        state, including controller parameters, etc.  

        Returns:
            (str):
        """
        return _robotsim.Simulator_getState(self)


    def setState(self, str):
        """
        Sets the current simulation state from a Base64 string returned by a prior
        getState call.  

        Args:
            str (str)
        """
        return _robotsim.Simulator_setState(self, str)


    def simulate(self, t):
        """
        Advances the simulation by time t, and updates the world model from the
        simulation state.  

        Args:
            t (float)
        """
        return _robotsim.Simulator_simulate(self, t)


    def fakeSimulate(self, t):
        """
        Advances a faked simulation by time t, and updates the world model from the
        faked simulation state.  

        Args:
            t (float)
        """
        return _robotsim.Simulator_fakeSimulate(self, t)


    def getTime(self):
        """
        Returns the simulation time.  

        Returns:
            (float):
        """
        return _robotsim.Simulator_getTime(self)


    def updateWorld(self):
        """
        Updates the world model from the current simulation state. This only needs to be
        called if you change the world model and want to revert back to the simulation
        state.  

        """
        return _robotsim.Simulator_updateWorld(self)


    def getActualConfig(self, robot):
        """
        Returns the current actual configuration of the robot from the simulator.  

        Args:
            robot (int)
        """
        return _robotsim.Simulator_getActualConfig(self, robot)


    def getActualVelocity(self, robot):
        """
        Returns the current actual velocity of the robot from the simulator.  

        Args:
            robot (int)
        """
        return _robotsim.Simulator_getActualVelocity(self, robot)


    def getActualTorque(self, robot):
        """
        Returns the current actual torques on the robot's drivers from the simulator.  

        Args:
            robot (int)
        """
        return _robotsim.Simulator_getActualTorque(self, robot)


    def getActualTorques(self, robot):
        """
        Deprecated: renamed to getActualTorque to be consistent with SimRobotController
        methods.  

        Args:
            robot (int)
        """
        return _robotsim.Simulator_getActualTorques(self, robot)


    def enableContactFeedback(self, obj1, obj2):
        """
        Call this to enable contact feedback between the two objects (arguments are
        indexes returned by object.getID()). Contact feedback has a small overhead so
        you may want to do this selectively. This must be called before using inContact,
        getContacts, getContactForces, contactForce, contactTorque, hadContact,
        hadSeparation, hadPenetration, and meanContactForce.  

        Args:
            obj1 (int)
            obj2 (int)
        """
        return _robotsim.Simulator_enableContactFeedback(self, obj1, obj2)


    def enableContactFeedbackAll(self):
        """
        Call this to enable contact feedback between all pairs of objects. Contact
        feedback has a small overhead so you may want to do this selectively.  

        """
        return _robotsim.Simulator_enableContactFeedbackAll(self)


    def inContact(self, aid, bid):
        """
        Returns true if the objects (indexes returned by object.getID()) are in contact
        on the current time step. You can set bid=-1 to tell if object `a` is in contact
        with any object.  

        Args:
            aid (int)
            bid (int)
        Returns:
            (bool):
        """
        return _robotsim.Simulator_inContact(self, aid, bid)


    def getContacts(self, aid, bid):
        """
        Returns the list of contacts (x,n,kFriction) at the last time step. Normals
        point into object `a`. The contact point (x,n,kFriction) is represented as a
        7-element vector.  

        Args:
            aid (int)
            bid (int)
        """
        return _robotsim.Simulator_getContacts(self, aid, bid)


    def getContactForces(self, aid, bid):
        """
        Returns the list of contact forces on object a at the last time step.  

        Args:
            aid (int)
            bid (int)
        """
        return _robotsim.Simulator_getContactForces(self, aid, bid)


    def contactForce(self, aid, bid):
        """
        Returns the contact force on object a at the last time step. You can set bid to
        -1 to get the overall contact force on object a.  

        Args:
            aid (int)
            bid (int)
        """
        return _robotsim.Simulator_contactForce(self, aid, bid)


    def contactTorque(self, aid, bid):
        """
        Returns the contact force on object `a` (about `a`'s origin) at the last time
        step. You can set `bid` to -1 to get the overall contact force on object `a`.  

        Args:
            aid (int)
            bid (int)
        """
        return _robotsim.Simulator_contactTorque(self, aid, bid)


    def hadContact(self, aid, bid):
        """
        Returns true if the objects had contact over the last simulate() call. You can
        set `bid` to -1 to determine if object `a` had contact with any other object.  

        Args:
            aid (int)
            bid (int)
        Returns:
            (bool):
        """
        return _robotsim.Simulator_hadContact(self, aid, bid)


    def hadSeparation(self, aid, bid):
        """
        Returns true if the objects had ever separated during the last simulate() call.
        You can set `bid` to -1 to determine if object `a` had no contact with any other
        object.  

        Args:
            aid (int)
            bid (int)
        Returns:
            (bool):
        """
        return _robotsim.Simulator_hadSeparation(self, aid, bid)


    def hadPenetration(self, aid, bid):
        """
        Returns true if the objects interpenetrated during the last simulate() call. If
        so, the simulation may lead to very inaccurate results or artifacts.  

        Args:
            aid (int)
            bid (int)
        Returns:
            (bool):

        You can set `bid` to -1 to determine if object `a` penetrated any object, or you
        can set `aid=bid=-1` to determine whether any object is penetrating any other
        (indicating that the simulation will not be functioning properly in general).  

        """
        return _robotsim.Simulator_hadPenetration(self, aid, bid)


    def meanContactForce(self, aid, bid):
        """
        Returns the average contact force on object a over the last simulate() call.  

        Args:
            aid (int)
            bid (int)
        """
        return _robotsim.Simulator_meanContactForce(self, aid, bid)


    def controller(self, *args):
        """
        Returns a controller for the indicated robot, either by index or by RobotModel.  

        controller (robot): :class:`~klampt.SimRobotController`


        Args:
            robot (int or :class:`~klampt.RobotModel`): 

        Returns:
            (:class:`~klampt.SimRobotController`):
        """
        return _robotsim.Simulator_controller(self, *args)


    def body(self, *args):
        """
        Returns the SimBody corresponding to the given link, rigid object, or terrain.  

        body (link): :class:`~klampt.SimBody`

        body (object): :class:`~klampt.SimBody`

        body (terrain): :class:`~klampt.SimBody`


        Args:
            link (:class:`~klampt.RobotModelLink`, optional): 
            object (:class:`~klampt.RigidObjectModel`, optional): 
            terrain (:obj:`TerrainModel`, optional): 

        Returns:
            (:class:`~klampt.SimBody`):
        """
        return _robotsim.Simulator_body(self, *args)


    def getJointForces(self, link):
        """
        Returns the joint force and torque local to the link, as would be read by a
        force-torque sensor mounted at the given link's origin. The 6 entries are
        (fx,fy,fz,mx,my,mz)  

        Args:
            link (:class:`~klampt.RobotModelLink`)
        """
        return _robotsim.Simulator_getJointForces(self, link)


    def setGravity(self, g):
        """
        Sets the overall gravity vector.  

        Args:
            g (:obj:`list of 3 floats`)
        """
        return _robotsim.Simulator_setGravity(self, g)


    def setSimStep(self, dt):
        """
        Sets the internal simulation substep. Values < 0.01 are recommended.  

        Args:
            dt (float)
        """
        return _robotsim.Simulator_setSimStep(self, dt)


    def getSetting(self, name):
        """
        Retrieves some simulation setting.  

        Args:
            name (str)
        Returns:
            (str):

        Valid names are:  

        *   gravity  
        *   simStep  
        *   boundaryLayerCollisions  
        *   rigidObjectCollisions  
        *   robotSelfCollisions  
        *   robotRobotCollisions  
        *   adaptiveTimeStepping  
        *   minimumAdaptiveTimeStep  
        *   maxContacts  
        *   clusterNormalScale  
        *   errorReductionParameter  
        *   dampedLeastSquaresParameter  
        *   instabilityConstantEnergyThreshold  
        *   instabilityLinearEnergyThreshold  
        *   instabilityMaxEnergyThreshold  
        *   instabilityPostCorrectionEnergy  

        See `Klampt/Simulation/ODESimulator.h
        <http://motion.pratt.duke.edu/klampt/klampt_docs/ODESimulator_8h_source.html>`_
        for detailed descriptions of these parameters.  

        """
        return _robotsim.Simulator_getSetting(self, name)


    def setSetting(self, name, value):
        """
        Sets some simulation setting. Raises an exception if the name is unknown or the
        value is of improper format.  

        Args:
            name (str)
            value (str)
        """
        return _robotsim.Simulator_setSetting(self, name, value)

    __swig_setmethods__["index"] = _robotsim.Simulator_index_set
    __swig_getmethods__["index"] = _robotsim.Simulator_index_get
    if _newclass:
        index = _swig_property(_robotsim.Simulator_index_get, _robotsim.Simulator_index_set)
    __swig_setmethods__["world"] = _robotsim.Simulator_world_set
    __swig_getmethods__["world"] = _robotsim.Simulator_world_get
    if _newclass:
        world = _swig_property(_robotsim.Simulator_world_get, _robotsim.Simulator_world_set)
    __swig_setmethods__["sim"] = _robotsim.Simulator_sim_set
    __swig_getmethods__["sim"] = _robotsim.Simulator_sim_get
    if _newclass:
        sim = _swig_property(_robotsim.Simulator_sim_get, _robotsim.Simulator_sim_set)
    __swig_setmethods__["initialState"] = _robotsim.Simulator_initialState_set
    __swig_getmethods__["initialState"] = _robotsim.Simulator_initialState_get
    if _newclass:
        initialState = _swig_property(_robotsim.Simulator_initialState_get, _robotsim.Simulator_initialState_set)
Simulator_swigregister = _robotsim.Simulator_swigregister
Simulator_swigregister(Simulator)


def setRandomSeed(seed):
    """
    Sets the random seed used by the configuration sampler.  

    Args:
        seed (int)
    """
    return _robotsim.setRandomSeed(seed)

def destroy():
    """
    destroys internal data structures  

    """
    return _robotsim.destroy()

def SubscribeToStream(*args):
    """
    Subscribes a Geometry3D to a stream.  

    SubscribeToStream (g,protocol,name,type): bool

    SubscribeToStream (g,protocol,name): bool


    Args:  

        g (Geometry3D): the geometry that will be updated
        protocol (str): only "ros" accepted for now.
        name (str): the name of the stream, i.e., ROS topic.
        type (str, optional): If provided, specifies the format of the data
            to be subscribed to. If not, tries to determine the type
            automatically.  

    Only ROS point clouds (PointCloud2) are supported for now. Note that you can
    also call `Geometry3D.loadFile("ros://[ROS_TOPIC]")` or
    `Geometry3D.loadFile("ros:PointCloud2//[ROS_TOPIC]")` to accomplish the same
    thing.  

    TODO: It has not yet been determined whether this interferes with Rospy, i.e.,
    klampt.io.ros.  

    Returns: (bool): True if successful.  

    """
    return _robotsim.SubscribeToStream(*args)

def DetachFromStream(protocol, name):
    """
    Unsubscribes from a stream previously subscribed to via
    :func:`SubscribeToStream`  

    Args:
        protocol (str)
        name (str)
    Returns:
        (bool):
    """
    return _robotsim.DetachFromStream(protocol, name)

def ProcessStreams(*args):
    """
    Does some processing on stream subscriptions.  

    ProcessStreams (protocol): bool

    ProcessStreams (): bool


    Args:  

        protocol (str): either name the protocol to be updated, or "all" for
            updating all subscribed streams  

    Returns: (bool): True if any stream was updated.  

    """
    return _robotsim.ProcessStreams(*args)

def WaitForStream(protocol, name, timeout):
    """
    Waits up to timeout seconds for an update on the given stream.  

    Args:
        protocol (str)
        name (str)
        timeout (float)
    Returns:
        (bool):

    Return:  

        (bool): True if the stream was updated.  

    """
    return _robotsim.WaitForStream(protocol, name, timeout)

def ThreeJSGetScene(arg1):
    """
    Exports the WorldModel to a JSON string ready for use in Three.js.  

    Args:
        arg1 (:class:`~klampt.WorldModel`)
    Returns:
        (str):
    """
    return _robotsim.ThreeJSGetScene(arg1)

def ThreeJSGetTransforms(arg1):
    """
    Exports the WorldModel to a JSON string ready for use in Three.js.  

    Args:
        arg1 (:class:`~klampt.WorldModel`)
    Returns:
        (str):
    """
    return _robotsim.ThreeJSGetTransforms(arg1)

def setFrictionConeApproximationEdges(numEdges):
    """
    Globally sets the number of edges used in the friction cone approximation. The
    default value is 4.  

    Args:
        numEdges (int)
    """
    return _robotsim.setFrictionConeApproximationEdges(numEdges)

def forceClosure(*args):
    """
    Returns true if the list of contact points has force closure.  

    forceClosure (contacts): bool

    forceClosure (contactPositions,frictionCones): bool


    Returns:
        (bool):

    In the 1-argument version, each contact point is specified by a list of 7
    floats, [x,y,z,nx,ny,nz,k] where (x,y,z) is the position, (nx,ny,nz) is the
    normal, and k is the coefficient of friction.  

    The 2-argument version is a "fancy" version that allows more control over the
    constraint planes.  

    Args:  

         contacts (list of 7-float lists or tuples): the list of contacts, each
             specified as a 7-list or tuple [x,y,z,nx,ny,nz,k], with:

                 * (x,y,z): the contact position
                 * (nx,ny,nz): the contact normal
                 * k: the coefficient of friction (>= 0)

         contactPositions (list of 3-float lists or tuples): the list of contact
             point positions.
         frictionCones (list of lists): Each item of this list specifies linear
             inequalities that must be met of the force at the corresponding
             contact point.  The item must have length k*4 where k is an integer,
             and each inequality gives the entries (ax,ay,az,b) of a constraint
             ax*fx+ay*fy+az*fz <= b that limits the contact force (fx,fy,fz) at
             the i'th contact.  Each of the k 4-tuples is laid out sequentially
             per-contact.  

    """
    return _robotsim.forceClosure(*args)

def forceClosure2D(*args):
    """
    Returns true if the list of 2D contact points has force closure.  

    forceClosure2D (contacts): bool

    forceClosure2D (contactPositions,frictionCones): bool


    Returns:
        (bool):

    In the 1-argument version, each contact point is given by a list of 4 floats,
    [x,y,theta,k] where (x,y) is the position, theta is the normal angle, and k is
    the coefficient of friction  

    The 2-argument version is a "fancy" version that allows more control over the
    constraint planes.  

    Args:  

         contacts (list of 4-float lists or tuples): the list of contacts, each
             specified as a 4-list or tuple [x,y,theta,k], with:

                 * (x,y): the contact position
                 * theta: is the normal angle (in radians, CCW to the x axis)
                 * k: the coefficient of friction (>= 0)

         contactPositions (list of 2-float lists or tuples): the list of contact
             point positions.
         frictionCones (list of lists): The i'th element in this list has length
             k*3 (for some integer k), and gives the contact force constraints
             (ax,ay,b) where ax*fx+ay*fy <= b limits the contact force (fx,fy)
             at the i'th contact. Each of the k 3-tuples is laid out sequentially
             per-contact.  

    """
    return _robotsim.forceClosure2D(*args)

def comEquilibrium(*args):
    """
    Tests whether the given COM com is stable for the given contacts and the given
    external force fext.  

    comEquilibrium (contacts,fext,com): :obj:`object`

    comEquilibrium (contactPositions,frictionCones,fext,com): :obj:`object`


    The 2-argument version is a "fancy" version that allows more control over the
    constraint planes.  

    Args: contacts (list of 7-float lists or tuples): the list of contacts, each
    specified as a 7-list or tuple [x,y,z,nx,ny,nz,k], with:  

        * (x,y,z): the contact position
        * (nx,ny,nz): the contact normal
        * k: the coefficient of friction (>= 0)  

    contactPositions (list of 3-float lists or tuples): the list of contact point
    positions. frictionCones (list of lists): Each item of this list specifies
    linear inequalities that must be met of the force at the corresponding contact
    point. The item must have length k*4 where k is an integer, and each inequality
    gives the entries (ax,ay,az,b) of a constraint ax*fx+ay*fy+az*fz <= b that
    limits the contact force (fx,fy,fz) at the i'th contact. Each of the k 4-tuples
    is laid out sequentially per-contact. fext (3-tuple or list): the external force
    vector. com (3-tuple or list, or None): the center of mass coordinates. If None,
    assumes that you want to test whether ANY COM may be in equilibrium for the
    given contacts.  

    Returns:  

        (bool, None, or list): if com is given, and there are feasible
            equilibrium forces, this returns a list of 3 tuples giving
            equilibrium forces at each of the contacts. None is returned if
            no such forces exist.  

            If com = None, the result is True or False.  

    """
    return _robotsim.comEquilibrium(*args)

def comEquilibrium2D(*args):
    """
    Tests whether the given COM com is stable for the given contacts and the given
    external force fext.  

    comEquilibrium2D (contacts,fext,com): :obj:`object`

    comEquilibrium2D (contactPositions,frictionCones,fext,com): :obj:`object`


    The 2-argument version is a "fancy" version that allows more control over the
    constraint planes.  

    Args:  

         contacts (list of 4-float lists or tuples): the list of contacts, each
             specified as a 4-list or tuple [x,y,theta,k], with:

                 * (x,y,z): the contact position
                 * theta: is the normal angle (in radians, CCW to the x axis)
                 * k: the coefficient of friction (>= 0)

         contactPositions (list of 2-float lists or tuples): the list of contact
             point positions.
         frictionCones (list of lists): The i'th element in this list has length
             k*3 (for some integer k), and gives the contact force constraints
             (ax,ay,b) where ax*fx+ay*fy <= b limits the contact force (fx,fy)
             at the i'th contact. Each of the k 3-tuples is laid out sequentially
             per-contact.
         fext (2-tuple or list): the external force vector.
         com (2-tuple or list, or None): the center of mass coordinates.  If None,
             assumes that you want to test whether ANY COM may be in equilibrium
             for the given contacts.  

    Returns:  

        (bool, None, or list): if com is given, and there are feasible
            equilibrium forces, this returns a list of 2-tuples giving
            equilibrium forces at each of the contacts. None is returned if
            no such forces exist.

            If com = None, the result is True or False.  

    """
    return _robotsim.comEquilibrium2D(*args)

def supportPolygon(*args):
    """
    Calculates the support polygon for a given set of contacts and a downward
    external force (0,0,-g).  

    supportPolygon (contacts): :obj:`object`

    supportPolygon (contactPositions,frictionCones): :obj:`object`


    In the 1-argument version, a contact point is given by a list of 7 floats,
    [x,y,z,nx,ny,nz,k] as usual. The 2-argument version is a "fancy" version that
    allows more control over the constraint planes.  

    Args:  

         contacts (list of 7-float lists or tuples): the list of contacts, each
             specified as a 7-list or tuple [x,y,z,nx,ny,nz,k], with:

                 * (x,y,z): the contact position
                 * (nx,ny,nz): the contact normal
                 * k: the coefficient of friction (>= 0)

         contactPositions (list of 3-float lists or tuples): the list of contact
             point positions.
         frictionCones (list of lists): Each item of this list specifies linear
             inequalities that must be met of the force at the corresponding
             contact point.  The item must have length k*4 where k is an integer,
             and each inequality gives the entries (ax,ay,az,b) of a constraint
             ax*fx+ay*fy+az*fz <= b that limits the contact force (fx,fy,fz) at
             the i'th contact.  Each of the k 4-tuples is laid out sequentially
             per-contact.  

    Returns:  

        (list of 3-tuples): The sorted plane boundaries of the support
            polygon. The format of a plane is (nx,ny,ofs) where (nx,ny) are the
            outward facing normals, and ofs is the offset from 0.  In other words
            to test stability of a com with x-y coordinates [x,y], you can test
            whether dot([nx,ny],[x,y]) <= ofs  for all planes.

            Hint: with numpy, you can do::

                Ab = np.array(supportPolygon(args))
                A=Ab[:,0:2]
                b=Ab[:,2]
                myComEquilibrium = lambda x: np.all(np.dot(A,x)<=b)  

    """
    return _robotsim.supportPolygon(*args)

def supportPolygon2D(*args):
    """
    Calculates the support polygon (interval) for a given set of contacts and a
    downward external force (0,-g).  

    supportPolygon2D (contacts): :obj:`object`

    supportPolygon2D (contacts,frictionCones): :obj:`object`


    The 2-argument version is a "fancy" version that allows more control over the
    constraint planes.  

    Args:  

        contacts (list of 4-float lists or tuples): the list of contacts, each
            specified as a 4-list or tuple [x,y,theta,k], with:

                * (x,y,z): the contact position
                * theta: is the normal angle (in radians, CCW to the x axis)
                * k: the coefficient of friction (>= 0)

        contactPositions (list of 2-float lists or tuples): the list of contact
            point positions.
         frictionCones (list of lists): The i'th element in this list has length
             k*3 (for some integer k), and gives the contact force constraints
             (ax,ay,b) where ax*fx+ay*fy <= b limits the contact force (fx,fy)
             at the i'th contact. Each of the k 3-tuples is laid out sequentially
             per-contact.  

    Returns:  

        (2-tuple): gives the min/max extents of the support polygon.
            If the support interval is empty, (inf,inf) is returned.  

    """
    return _robotsim.supportPolygon2D(*args)

def equilibriumTorques(*args):
    """
    Solves for the torques / forces that keep the robot balanced against gravity.  

    equilibriumTorques (robot,contacts,links,fext,norm=0): :obj:`object`

    equilibriumTorques (robot,contacts,links,fext): :obj:`object`

    equilibriumTorques (robot,contacts,links,fext,internalTorques,norm=0): :obj:`object`

    equilibriumTorques (robot,contacts,links,fext,internalTorques): :obj:`object`


    The problem being solved is  

    :math:`min_{t,f_1,...,f_N} \|t\|_p`  

    :math:`s.t. t_{int} + G(q) = t + sum_{i=1}^N J_i(q)^T f_i`  

    :math:`|t| \leq t_{max}`  

    :math:`f_i \in FC_i`  

    Args:  

        robot (RobotModel): the robot, posed in its current configuration
        contacts (list of N 7-lists): a list of contact points, given as 7-lists
            [x,y,z,nx,ny,nz,kFriction]
        links (list of N ints): a list of the links on which those contact points
            lie
        fext (list of 3 floats): the external force (e.g., gravity)
        norm (double): the torque norm to minimize.  

            * If 0, minimizes the l-infinity norm (default)
            * If 1, minimizes the l-1 norm.
            * If 2, minimizes the l-2 norm (experimental, may not get good results).
        internalTorques (list of robot.numLinks() floats, optional): allows you to
            solve for dynamic situations, e.g., with coriolis forces taken into
            account.  These are added to the RHS of the torque balance equation.
            If not given, t_int is assumed to be zero.

            To use dynamics, set the robot's joint velocities dq, calculate
            then calculate the torques via robot.torquesFromAccel(ddq), and pass
            the result into internalTorques.  

    Returns:  

        (pair of lists, optional): a pair (torque,force) if a solution exists,
             giving valid joint torques t and frictional contact forces (f1,...,fn).

             None is returned if no solution exists.  

    """
    return _robotsim.equilibriumTorques(*args)
# This file is compatible with both classic and new-style classes.


